#!/bin/sh
# ------------------------------------------------------------------------------
#
# This file holds many useful (mostly agnostic) commands to improve life in the
#  shell
#
# Sections:
# 1. Environment Variables
# 2. Shell Enhancements
# 4. Prompt
# 4. Aliases
# 5. Functions
#
# ------------------------------------------------------------------------------


# --------------------------------------------------------------------
# 1. Environment Variables
# --------------------------------------------------------------------

export BASH_SILENCE_DEPRECATION_WARNING=1 # MacOS nuissance
export EDITOR=vim
export GPG_TTY=$(tty)
export JSH=$HOME/.jsh
export JSH_CUSTOM=$HOME/.jsh_local
export PATH=$HOME/.local/bin:$JSH/.bin:$HOME/go/bin:$PATH
export PYTHONDONTWRITEBYTECODE=1 # No .pyc files when importing
export SH=${SHELL##*/}
export SSHRC_EXTRAS='.inputrc .tmux.conf .vimrc'
export VISUAL=vim

# Color palette
# ----------------------------------------------------------
if [[ $(uname) == 'Darwin' || $(command -v tput &>/dev/null) ]]; then
  black="\001$(tput setaf 0)\002"
  red="\001$(tput setaf 1)\002"
  green="\001$(tput setaf 2)\002"
  orange="\001$(tput setaf 3)\002"
  blue="\001$(tput setaf 4)\002"
  purple="\001$(tput setaf 5)\002"
  cyan="\001$(tput setaf 6)\002"
  lightgray="\001$(tput setaf 7)\002"
  darkgray="\001$(tput setaf 8)\002"
  pink="\001$(tput setaf 9)\002"
  lime="\001$(tput setaf 10)\002"
  yellow="\001$(tput setaf 11)\002"
  aqua="\001$(tput setaf 12)\002"
  lavender="\001$(tput setaf 13)\002"
  ice="\001$(tput setaf 14)\002"
  white="\001$(tput setaf 15)\002"
  bold="\001$(tput bold)\002"
  underline="\001$(tput smul)\002"
  reset="\001$(tput sgr0)\002"
else
  black="\033[30m"
  red="\033[31m"
  green="\033[32m"
  orange="\033[33m"
  blue="\033[34m"
  purple="\033[35m"
  cyan="\033[36m"
  lightgray="\033[37m"
  darkgray="\033[90m"
  pink="\033[91m"
  lime="\033[92m"
  yellow="\033[93m"
  aqua="\033[94m"
  lavender="\033[95m"
  ice="\033[96m"
  white="\033[97m"
  bold="\033[1m"
  underline="\033[4m"
  reset="\033[0m"
fi


# --------------------------------------------------------------------
# 2. Shell Enhancements
# --------------------------------------------------------------------

# Standard logging messages
# ----------------------------------------------------------
abort() { echo; echo "${red}$@${reset}" 1>&2; exit 1; }
error() { echo -e ${red}$@${reset}; return 1; }
warn() { echo -e ${orange}$@${reset}; }
success() { echo -e ${green}$@${reset}; }
info() { echo -e ${blue}$@${reset}; }

# quiet: Mute output of a command or redirection
# ----------------------------------------------------------
quiet() { [[ $# == 0 ]] && &> /dev/null || "$*" &> /dev/null ; }

# Show only two levels of pwd in prompt (Bash >=4 only)
# ----------------------------------------------------------
[[ $SH == 'bash' ]] && PROMPT_DIRTRIM=2

# Enable vi mode
# ----------------------------------------------------------
set -o vi

# Disable CTRL-S and CTRL-Q
# ----------------------------------------------------------
[[ $- =~ i && $SH == 'bash' ]] && stty -ixoff -ixon

# Use SHM for storing sensitive information
# ----------------------------------------------------------
if [[ "$(uname)" =~ "Darwin" ]]; then
  export SHM=$HOME
else
  export SHM=/dev/shm/$USER
fi
if [[ ! -d "$SHM" ]]; then
  mkdir $SHM | quiet
  chmod 700 $SHM | quiet
fi

# Enable shell completion
# ----------------------------------------------------------
if [[ -f /etc/${SH}_completion ]]; then
  source /etc/${SH}_completion
elif [[ -f /usr/local/etc/${SH}_completion ]]; then
  source /usr/local/etc/${SH}_completion
fi

# Enable k8s completion
# ----------------------------------------------------------
if [[ $(command -v kubectl) == 0 ]]; then
  source <(kubectl completion $SH)
fi

# Get kubeconfigs by cluster
# ----------------------------------------------------------
if [[ -d $HOME/.kube/clusters ]]; then
  export KUBECONFIG=$(find $HOME/.kube/clusters -type f | sed ':a;N;s/\n/:/;ba')
fi

# Enable color support of ls and also add handy aliases
# ----------------------------------------------------------
if [[ -x /usr/bin/dircolors ]]; then
  test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
fi

# Enable shortcut to iCloud Drive
# ----------------------------------------------------------
if [[ $(uname) == "Darwin" ]]; then
  export ICLOUD_DRIVE_PATH='~/Library/Mobile\ Documents/com~apple~CloudDocs'
  alias ic='cd '$ICLOUD_DRIVE_PATH
fi

# Augment sshrc experience
# ----------------------------------------------------------
if [[ -n $SSHHOME ]]; then

  # Source included .inputrc
  export INPUTRC=$SSHHOME/.inputrc

  # Add .sshrc.d to PATH
  if [[ ! "$PATH" == *$SSHHOME/.sshrc.d* && -d $SSHHOME/.sshrc.d ]]; then
    export PATH="${PATH:+${PATH}:}$SSHHOME/.sshrc.d"
  fi

  # Enable custom tmux, vim configs while on remote hosts via sshrc
  [[ -f $SSHHOME/.tmux.conf ]] && alias tmux='tmux -f $SSHHOME/.tmux.conf'
  [[ -f $SSHHOME/.vimrc ]] && alias vim='vim -u $SSHHOME/.vimrc'

fi

# Ancillary functionality
# ----------------------------------------------------------
[[ -n $JSH_CUSTOM && -f $JSH_CUSTOM ]] && source $JSH_CUSTOM

# Rid PATH of duplicates
# ----------------------------------------------------------
_path=$(echo -n "$PATH" | sed 's/:\/usr\/local\/bin//g' | sed 's/:\/usr\/bin//g')
export PATH=$(echo "$_path" | tr ':' '\n' | tr -d '^$' | sort -u | tr '\n' ':' | sed 's/:$//g'):/usr/local/bin:/usr/bin # prioritize local binaries


# --------------------------------------------------------------------
# 3. Prompt
# --------------------------------------------------------------------

prompt_cmd() {
  [[ $? == 0 ]] && ret="\[${green}\]" || ret="\[${red}\]"
  [[ -n $PROMPT_SYMBOL ]] && local prompt_symbol="$PROMPT_SYMBOL" || local prompt_symbol='>'
  local dir="\[${cyan}\]\w\[${reset}\]"
  local git="\[${purple}\]\$(git branch 2>/dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/(\1)/')\[${reset}\]"
  local host="\[${yellow}\]\h\[${reset}\]"
  local user="\[${orange}\]\u\[${reset}\]"
  if [[ -n "$WORKSPACE" ]]; then
    local workspace="\[${red}\][$WORKSPACE]\[${reset}\]"
  fi
  if [[ -n $PROMPT_CUSTOM ]]; then
    PS1=${PROMPT_CUSTOM}
  else
    if [[ $PROMPT == 'mini' ]]; then
      local prompt="${ret}${prompt_symbol} ${reset}"
      PS1="${prompt}${dir}${git}${workspace} "
    elif [[ $PROMPT == 'full' ]]; then
      local prompt="${ret}└─╼ ${reset}"
      PS1="${bold}┌─[${reset}${user}@${host}:${dir}${git}${bold}]${reset}${workspace}\n${prompt}"
    else
      PS1="${workspace}${user}@${host}:${dir}${git}${ret}$ ${reset}"
    fi
  fi
}
[[ $SH == 'bash' ]] && export PROMPT_COMMAND=prompt_cmd || unset PROMPT_COMMAND


# --------------------------------------------------------------------
# 4. Aliases
# --------------------------------------------------------------------

# More elaborate coloring
# ----------------------------------------------------------
if [[ $(which grc 2>/dev/null) == 0 ]]; then
  alias colorize="$(which grc) -es --colour=auto"
  alias as='colorize as'
  alias configure='colorize ./configure'
  alias df='colorize df'
  alias diff='colorize diff'
  alias dig='colorize dig'
  alias g++='colorize g++'
  alias gas='colorize gas'
  alias gcc='colorize gcc'
  alias head='colorize head'
  alias ld='colorize ld'
  alias make='colorize make'
  alias mount='colorize mount'
  alias mtr='colorize mtr'
  alias netstat='colorize netstat'
  alias ping='colorize ping'
  alias ps='colorize ps'
  alias tail='colorize tail'
  alias traceroute='colorize /usr/sbin/traceroute'
fi

# Conditional
# ----------------------------------------------------------
command -v exa >/dev/null 2>&1 && alias ls='exa -lag --header'
command -v kubecolor >/dev/null 2>&1 && alias kubectl='kubecolor'

# Assorted
# ----------------------------------------------------------
alias ..='cd ..'
alias ..='cd ../' # Go back 1 directory level
alias .2='cd ../../' # Go back 2 directory levels
alias .3='cd ../../../' # Go back 3 directory levels
alias .4='cd ../../../../' # Go back 4 directory levels
alias .5='cd ../../../../../' # Go back 5 directory levels
alias .6='cd ../../../../../../' # Go back 6 directory levels
alias 000='chmod 000' # ---------- (nobody)
alias 640='chmod 640' # -rw-r----- (user: rw, group: r, other: -)
alias 644='chmod 644' # -rw-r--r-- (user: rw, group: r, other: -)
alias 755='chmod 755' # -rwxr-xr-x (user: rwx, group: rx, other: x)
alias 775='chmod 775' # -rwxrwxr-x (user: rwx, group: rwx, other: rx)
alias _='sudo' # Evolve into superuser
alias a='ansible' # Abbreviation
alias ap='ansible-playbook' # Abbreviation
alias av='ansible-vault' # Abbreviation
alias c='clear' # c: Clear terminal display
alias ccd='clear && cd' # Reset shell
alias cd..='cd ../' # Go back 1 directory level (for fast typers)
alias cp='cp -iv' # Preferred 'cp' implementation
alias curl='curl -w "\n"'
alias d='dirs -v | head -10' # Display dir
alias dud='du -d 1 -h' # Short and human-readable file listing
alias duf='du -sh *' # Short and human-readable directory listing
alias edit='vim'
alias epochtime='date +%s' # Current epoch time
alias fix_stty='stty sane' # fix_stty: Restore terminal settings when screwed up
alias g='grep --color=auto -i' # grep > git
alias gdiff='git diff --name-only master' # List files changed in this branch compared to master
alias gdiffcp='gdiff | xargs -I{} rsync --relative {}' # Copy modified files to another dir
alias gitv='git log --graph --format="%C(auto)%h%d %s %C(black)%C(bold)%cr"' # Beautify logs
alias glances='glances -1 -t 0.5' # Faster output from glances
alias grep='grep --color=auto -i' # Preferred 'grep' implementation
alias gvimdiff='git difftool --tool=vimdiff --no-prompt' # Open all git changes in vimdiff
alias h='history'
alias k='kubectl' # Abbreviate kube control
alias kaf='kubectl apply -f' # Apply k8s manifest
alias kar='kubectl api-resources --verbs=list --namespaced -o name | grep -v "events.events.k8s.io" | grep -v "events" | sort | uniq' # Get all possible kinds
alias kav='kubectl api-versions' # List all APIs
alias kctx='kubectx' # Change kube context
alias kdel='kubectl delete' # Delete resource
alias kdelp='kubectl delete pods' # Delete all pods matching passed arguments
alias kdp='kubectl describe pods' # Describe all pods
alias keti='kubectl exec -it' # Open terminal into pod
alias kgd='kubectl get deployments' # Get the deployment
alias kgp='kubectl get pods' # List all pods in ps output format
alias kns='kubens' # Change kube namespace
alias l='ls -la' # Long, show hidden files
alias less='less -FSRXc' # Preferred 'less' implementation
alias md='mkdir -p' # Create directory
alias mkdir='mkdir -pv' # Preferred 'mkdir' implementation
alias mountReadWrite='/sbin/mount -uw /' # mountReadWrite: For use when booted into single-user
alias mv='mv -iv' # Preferred 'mv' implementation
alias mx='chmod a+x' # ---x--x--x (user: --x, group: --x, other: --x)
alias nano='nano -W' # Preferred 'nano' implementation
alias netshoot='kubectl run tmp-shell --rm -i --tty --image nicolaka/netshoot' # quick pod for troubleshooting
alias passgen='openssl passwd -1' # pass: Generate salted hash for passwords
alias path='echo -e ${PATH//:/\\n}' # path: Echo all executable Paths
alias perm='stat --printf "%a %n \n "' # perm: Show permission of target in number
alias please='sudo ' # Politely ask for superuser
alias pn='pnpm'
alias proxy='http_proxy=$PROXY_ENDPOINT https_proxy=$PROXY_ENDPOINT no_proxy=$PROXY_EXCEPTION' # proxy: set as per env and on command
alias rm='rm -i' # Always prompt before deleting
alias show_options='shopt' # Show_options: display bash options settings
alias sshx='eval $(ssh-agent) && ssh-add 2>/dev/null' # sshx: Import SSH keys
alias sudo='sudo '
alias tf='terraform' # Abbreviation
alias timestamp='date "+%Y%m%dT%H%M%S"' # Filename ready complete time format
alias tmux="tmux -2" # Force 256 color support
alias vscode='open -a "Visual Studio Code"' # VSCode shortcut
alias w='watch -n1 -d -t ' # Faster watch, highlight changes and no title
alias wget='wget -c' # Preferred 'wget' implementation (resume download)
alias whatis='declare -f' # Print function definition
alias which='type -a'


# --------------------------------------------------------------------
# 5. Functions
# --------------------------------------------------------------------

# Searching
# ----------------------------------------------------------
ff() { /usr/bin/find . -name "$@" ; }     # ff: Find file under the current directory
ffs() { /usr/bin/find . -name "$@"'*' ; } # ffs: Find file whose name starts with a given string
ffe() { /usr/bin/find . -name '*'"$@" ; } # ffe: Find file whose name ends with a given string
ffpid() { lsof -t -c "$@" } # ffpid: Find pid of matching process

# curldebug: Download a web page and show info on what took time
# ----------------------------------------------------------
curldebug() {
  /usr/bin/curl "$@" -o /dev/null -w "dns: %{time_namelookup} connect: %{time_connect} pretransfer: %{time_pretransfer} starttransfer: %{time_starttransfer} total: %{time_total}\\n"
}

# curldiag: Exhaustive output for given web request
# ----------------------------------------------------------
curldiag() {
  CURL_FORMAT="
      content_type: %{content_type}
filename_effective: %{filename_effective}
    ftp_entry_path: %{ftp_entry_path}
         http_code: %{http_code}
      http_connect: %{http_connect}
      num_connects: %{num_connects}
     num_redirects: %{num_redirects}
      redirect_url: %{redirect_url}
     size_download: %{size_download}
       size_header: %{size_header}
      size_request: %{size_request}
       size_upload: %{size_upload}
    speed_download: %{speed_download}
      speed_upload: %{speed_upload}
 ssl_verify_result: %{ssl_verify_result}
     url_effective: %{url_effective}


   time_namelookup: %{time_namelookup}
      time_connect: %{time_connect}
   time_appconnect: %{time_appconnect}
  time_pretransfer: %{time_pretransfer}
     time_redirect: %{time_redirect}
time_starttransfer: %{time_starttransfer}
                   -------
        time_total: %{time_total}
"

  for arg in $@; do
    curl -v -w "$CURL_FORMAT" -o /dev/null -s $arg
  done
}

# curlheader: Grabs headers from web page
# ----------------------------------------------------------
curlheader() {
  curl -I -L "$@"
}

# duh: Disk usage per directory, sorted by ascending size
# ----------------------------------------------------------
duh() {
  if [[ $(uname) == "Darwin" ]]; then
    if [[ -n $1 ]]; then
      du -hd 1 "$1" | sort -h
    else
      du -hd 1 | sort -h
    fi
  elif [[ $(uname) == "Linux" ]]; then
    if [[ -n $1 ]]; then
      du -h --max-depth=1 "$1" | sort -h
    else
      du -h --max-depth=1 | sort -h
    fi
  fi
}

# extract: Extract most know archives with one command
# ----------------------------------------------------------
extract() {
  if [ -f "$1" ]
  then
    case "$1" in
      *.tar.bz2)   tar xjf "$1"     ;;
      *.tar.gz)    tar xzf "$1"     ;;
      *.bz2)       bunzip2 "$1"     ;;
      *.rar)       unrar e "$1"     ;;
      *.gz)        gunzip "$1"      ;;
      *.tar)       tar xf "$1"      ;;
      *.tbz2)      tar xjf "$1"     ;;
      *.tgz)       tar xzf "$1"     ;;
      *.zip)       unzip "$1"       ;;
      *.Z)         uncompress "$1"  ;;
      *.7z)        7z x "$1"        ;;
      *)     echo "'$1' cannot be extracted via extract()" ;;
    esac
  else
    echo "'$1' is not a valid file"
  fi
}

# gitsync: Git pull from all defined repos
# ----------------------------------------------------------
gitsync() {
  SSH_KEY=${HOME}/.ssh/id_rsa
  if [[ $(ssh-add -l | grep "${SSH_KEY}" | wc -l) == 0 ]]; then
      eval $(ssh-agent)
      ssh-add ~/.ssh/id_rsa
  fi

  REPOS=($(echo "$GIT_REPOS" | tr ',' '\n'))
  for REPO in ${REPOS[@]}
  do
    echo "Checking for ${REPO} repository."
    TARGET_DIR=$(pwd)
    if [[ $# == 0 ]]; then
      TARGET_DIR="${HOME}"
    fi
    cd ${TARGET_DIR}
    REPO_DIR="${TARGET_DIR}/$(echo ${REPO} | sed 's/^\w*\///g')"
    echo $REPO_DIR
    BRANCH=master
    R=$(echo ${REPO} | sed 's/^\w*\///g')
    if [ -d "${REPO_DIR}" ]
    then
      echo "${R}@${BRANCH} found locally. Overwriting master branch with latest remote."
      pushd ${REPO_DIR} && git checkout -f ${BRANCH} && git fetch --all && git reset --hard origin/${BRANCH} && popd
    else
      echo "${R}@${BRANCH} not found locally. Pulling from remote."
      echo git clone ssh://git@$GIT_URL:7999/${REPO}.git
      git clone ssh://git@$GIT_URL:7999/${REPO}.git
      pushd ${REPO_DIR} && git checkout -f ${BRANCH} && git pull && popd
    fi
  done
}

# http2ssh: Convert gitconfig URL from HTTP(S) to SSH
#   Credit: github.com/m14t/fix_github_https_repo.sh
# ----------------------------------------------------------
http2ssh() {
  REPO_URL=$(git remote -v | grep -m1 '^origin' | sed -Ene's#.*(https://[^[:space:]]*).*#\1#p')
  if [ -z "$REPO_URL" ]; then
    error "Could not identify repo url."
    if [ -n "$(grep 'git@github.com' .git/config)" ]; then
      warn "SSH-like url found in gitconfig"
    fi
    return 1
  fi

  USER=$(echo $REPO_URL | sed -Ene's#https://github.com/([^/]*)/(.*)#\1#p')
  if [ -z "$USER" ]; then
    error "Could not identify user"
    return 2
  fi

  REPO=$(echo $REPO_URL | sed -Ene's#https://github.com/([^/]*)/(.*)#\2#p')
  if [ -z "$REPO" ]; then
    error "Could not identify repo"
    return 3
  fi

  NEW_URL="git@github.com:$USER/$REPO"
  warn "Changing repo url from "
  warn "  '$REPO_URL'"
  warn "      to "
  warn "  '$NEW_URL'"
  warn ""

  git remote set-url origin $NEW_URL
  [[ $# ]] && success "Success" || error "Failed to set new URL origin"
}

# inv: Move to ansible inventory (or root) if defined
# ----------------------------------------------------------
inv() {
  if [[ -n $ANSIBLE_INVENTORY ]]; then
    cd $ANSIBLE_INVENTORY
    if [[ $# == 1 ]]; then
      cd $(git rev-parse --show-toplevel)
    fi
  fi
}

# ipmi: Common ipmitool shortcuts with no plaintext password
# ----------------------------------------------------------
ipmi() {
  if [[ $1 == "fan" ]]; then
    ipmitool -I lanplus -H ${IPMI_HOST} -U ${IPMI_USER} -f ${IPMI_CRED_FILE} raw 0x30 0x30 0x01 0x00
    if [[ $# == 2 ]]; then
      ipmitool -I lanplus -H ${IPMI_HOST} -U ${IPMI_USER} -f ${IPMI_CRED_FILE} raw 0x30 0x30 0x02 0xff 0x$(printf '%x\n' $2)
      return $?
    else
      error "example: ipmi fan 20"
    fi
  fi

  ipmitool -I lanplus -H ${IPMI_HOST} -U ${IPMI_USER} -f ${IPMI_CRED_FILE} $@
}

# ips: Display all ip addresses for this host
# ----------------------------------------------------------
ips() {
  if command -v ifconfig &>/dev/null; then
    ifconfig | awk '/inet /{ print $2 }'
  elif command -v ip 2>/dev/null; then
    ip addr | grep -oP 'inet \K[\d.]+'
  else
    echo "You don't have ifconfig or ip command installed!"
  fi
}

# kc: Fetch admin config from remote server
# ----------------------------------------------------------
kc() {
  if [[ $# == 1 ]]; then
    [[ ! -d $HOME/.kube ]] && mkdir -p $HOME/.kube
    scp $1:/etc/kubernetes/admin.conf $HOME/.kube/config
  else
    error "Usage: kc <admin host>"
  fi
}

# kdrain: Drain any node
# ----------------------------------------------------------
kdrain() {
  node=$1
  option=$2
  #kubectl drain $node --ignore-daemonsets --delete-emptydir-data

  # delete all pods on node to avoid daemonset-backed service outages (e.g. traefik DS when one node is unreachable)
  if [[ $option =~ '--force' ]]; then
    #for resource in "$(kubectl get pods -A -o custom-columns=:.metadata.namespace,:.metadata.name --no-headers | grep $node)"; do
    IFS=$'\n'
    for resource in $(kubectl get pods -A -o wide --no-headers | grep $node); do
      namespace=$(echo $resource | awk '{print $1}')
      pod=$(echo $resource | awk '{print $2}')
      echo "Deleting pod/$pod in $namespace namespace"
      kubectl -n $namespace delete pod $pod --force --grace-period=0
    done
  fi
}

# kt: Create a cluster-admin SA and fetch bearer token
# ----------------------------------------------------------
kt() {
  kubectl get ns admin || kubectl create ns admin
  kubectl -n admin get sa jay || kubectl -n admin create sa jay
  kubectl get clusterrolebinding cluster-admin-jay || kubectl create clusterrolebinding cluster-admin-jay --clusterrole=cluster-admin --serviceaccount=admin:jay
  kubectl -n admin get secret $(kubectl -n admin get serviceaccounts jay -o json | python -c 'import sys,json; print json.load(sys.stdin)["secrets"][0]["name"]') -o json | python -c 'import sys,json; print json.load(sys.stdin)["data"]["token"]' | base64 -d
  printf "\nPress any key to cleanup..." && read key
  kubectl -n admin delete sa jay
  kubectl delete clusterrolebinding cluster-admin-jay
}

# kx: Execute command in new busybox instance
# ----------------------------------------------------------
kx() {
  if [[ $# > 0 ]]; then
    kubectl run -i --tty $1 --image=busybox --restart=Never --rm -- \
      $@
  else
    error "Usage: <command> <arguments> (command is also name of pod)"
  fi
}

# lsgrep: Search through directory contents with grep
# ----------------------------------------------------------
lsgrep() { ls | grep "$*" ; }

# mkd: Makes new dir and jumps inside
# ----------------------------------------------------------
mkd() { mkdir -p -- "$*" ; cd -- "$*" || exit ; }

# myip: Display public IP
# ----------------------------------------------------------
myip() {
  res=$(curl -s checkip.dyndns.org | grep -Eo '[0-9\.]+')
  echo -e "Your public IP is: ${green} $res ${reset}"
}

# myps: List processes owned by current user
# ----------------------------------------------------------
myps() {
  ps "$@" -u "$USER" -o pid,%cpu,%mem,start,time,bsdtime,command
}

# src: Batch source files
# ----------------------------------------------------------
src() {
  if [[ $# == 0 ]]; then
    source $JSH/.jshrc
  else
    for f in $@; do
      if [[ -f $f ]]; then
        source $f
      else
        warn Could not find $f
      fi
    done
  fi
}

# Source: https://stackoverflow.com/questions/54814543/bash-how-to-use-an-alias-command-in-combination-with-watch
# ----------------------------------------------------------
swatch_usage() {
    cat <<EOF >&2
NAME
       swatch - execute a program periodically with "watch". Supports aliases.

SYNOPSIS
       swatch [options] command

OPTIONS
       -n, --interval seconds (default: 1)
              Specify update interval.  The command will not allow quicker than 0.1 second interval.
EOF
}

swatch() {
    if [ $# -eq 0 ]; then
        swatch_usage
        return 1
    fi
    seconds=1
    case "$1" in
    -n)
        seconds="$2"
        args=${*:3}
        ;;
    -h)
        swatch_usage
        ;;
    *)
        seconds=1
        args=${*:1}
        ;;
    esac
    watch --color -n "$seconds" -d -t --exec ${SH} -ic "$args || true"
}

# viw: Edit at source
# ----------------------------------------------------------
viw() {
  if [[ $# == 1 && -n $EDITOR ]]; then
    $EDITOR $(which $1)
  fi
}

# vk: Prompt and store vault key
# ----------------------------------------------------------
vk() {
  [[ -z $SHM ]] && error "$SHM not set"
  [[ -n $WORKSPACE ]] && VAULT=$WORKSPACE
  [[ $# == 1 ]] && VAULT=$1
  if [[ -n $VAULT ]]; then
    local e_data
    local dir=$SHM/.vault
    if [[ ! -d $dir ]]; then
      mkdir $dir
    fi
    local target="${dir}/$VAULT"
    if [[ ! -f $target ]]; then
      echo -n "Enter vault key for $VAULT: "
      read -s e_data
      echo ""
      echo $e_data > $target
      chmod 600 $target
      success "Wrote key to ${target}"
    fi
  else
    error "Usage: vk VAULT_NAME"
  fi
}

# ws: Change workspace
# ----------------------------------------------------------
ws() {
  # Define workspace
  if [[ $# == 1 ]]; then
    info "Setting WORKSPACE to $1"
    export WORKSPACE=$1
  elif [[ $# > 1 ]]; then
    error "Usage: ws WORKSPACE"
    return 1
  else
    if [[ -z $WORKSPACE && -n $DEFAULT_WORKSPACE ]]; then
      info "Setting WORKSPACE to default $DEFAULT_WORKSPACE"
      export WORKSPACE=$DEFAULT_WORKSPACE
    else
      error "Usage: ws WORKSPACE"
      return 2
    fi
  fi

  # Black box
  if command -v setw &>/dev/null; then
    setw $WORKSPACE
    return $?
  fi

  # Set ansible vault password file
  if command -v ansible-playbook &>/dev/null; then

    # Ensure a workspace is defined
    if [[ -n $WORKSPACE ]]; then

      # Prompt/set vault key if not already
      if [[ ! -f $SHM/.vault-$WORKSPACE || $(cat $SHM/.vault-$WORKSPACE) == '' ]]; then
        info "Opening vault for $WORKSPACE"
        vk $WORKSPACE
      fi

      # Check for base definition
      if [[ -z $GIT_INV ]]; then
        if [[ $(git status 2>/dev/null) ]]; then
          if [[ -d $(pwd)/ansible ]]; then
            info "Setting GIT_INV to $(pwd)/ansible/inv"
            GIT_INV=$(pwd)/ansible/inventory
          else
            info "Setting GIT_INV to $(pwd)/inv"
            GIT_INV=$(pwd)/inventory
          fi
        else
          info "Setting GIT_INV to ./inv"
          GIT_INV=./inventory
        fi
      fi

      # Check/prompt for valid inventory
      if [[ -d $GIT_INV/$WORKSPACE ]]; then
        info "Setting ANSIBLE_INVENTORY to $GIT_INV/$WORKSPACE"
        export ANSIBLE_INVENTORY="$GIT_INV/$WORKSPACE"
        alias ap="ansible-playbook -i $ANSIBLE_INVENTORY"
        alias a="ansible -i $ANSIBLE_INVENTORY"
      else
        printf "Ansible Inventory Root: "
        read ANSIBLE_INV
        if [[ -d $ANSIBLE_INV ]]; then
          pushd $ANSIBLE_INV &>/dev/null
          [[ -d $(git rev-parse --show-toplevel)/inv ]] && export GIT_INV=$(git rev-parse --show-toplevel)/inventory
          popd &>/dev/null
          export ANSIBLE_INVENTORY=$GIT_INV/$WORKSPACE
          alias ap="ansible-playbook -i $ANSIBLE_INVENTORY"
          alias a="ansible -i $ANSIBLE_INVENTORY"
          success "Ansible inventory set to $ANSIBLE_INVENTORY"
        else
          if [[ ! -d $ANSIBLE_INV ]]; then
            error "Ansible inventory $ANSIBLE_INV not valid!"
            return 3
          else
            error "Ansible inventory $GIT_INV/$WORKSPACE not found!"
            return 4
          fi
        fi
      fi
      if [[ -f $SHM/.vault/$WORKSPACE ]]; then
        export ANSIBLE_VAULT_PASSWORD_FILE="$SHM/.vault/$WORKSPACE"
      else
        error "Ansible vault password file $SHM/.vault/$WORKSPACE not found!"
        return 5
      fi

    # Clean up if no workspace defined
    else
      unset ANSIBLE_INVENTORY
      unset ANSIBLE_VAULT_PASSWORD_FILE
      alias ap="ansible-playbook"
      alias a="ansible"
    fi

  else

    warn "Ansible not installed!"

  fi
}
