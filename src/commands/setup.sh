# setup.sh - Setup, teardown, and symlink commands
# shellcheck disable=SC2034,SC1091

[[ -n "${_JSH_SETUP_LOADED:-}" ]] && return 0
_JSH_SETUP_LOADED=1

# Attempt to change default shell to zsh
set_default_shell_zsh() {
  local zsh_path

  # Find zsh path
  if has zsh; then
    zsh_path=$(command -v zsh)
  else
    prefix_warn "zsh not found, skipping shell change"
    return 0
  fi

  if [[ "${JSH_DRY_RUN:-0}" == "1" ]]; then
    if [[ "${SHELL}" == *"zsh"* ]]; then
      prefix_info "Default shell is already zsh"
    else
      prefix_info "Would attempt to set default shell to ${zsh_path}"
    fi
    return 0
  fi

  # Check if already using zsh
  if [[ "${SHELL}" == *"zsh"* ]]; then
    prefix_info "Default shell is already zsh"
    return 0
  fi

  # Check if user is a local user (exists in /etc/passwd) or domain/AD user
  local is_local_user=false
  local username="${USER%%@*}" # Strip domain suffix if present
  if grep -q "^${username}:" /etc/passwd 2>/dev/null; then
    is_local_user=true
  fi

  if [[ "${is_local_user}" == true ]]; then
    # Local user: try chsh
    # Ensure zsh is in /etc/shells
    if ! grep -qx "${zsh_path}" /etc/shells 2>/dev/null; then
      prefix_warn "zsh not in /etc/shells, attempting to add..."
      if ! echo "${zsh_path}" | sudo tee -a /etc/shells >/dev/null 2>&1; then
        prefix_warn "Could not add zsh to /etc/shells (requires sudo), skipping shell change"
        return 0
      fi
    fi

    # Attempt to change shell
    info "Changing default shell to zsh..."
    if chsh -s "${zsh_path}" 2>/dev/null; then
      prefix_success "Default shell changed to zsh"
    else
      prefix_warn "Could not change default shell (may require password or sudo)"
      prefix_info "Run manually: chsh -s ${zsh_path}"
    fi
  else
    # Domain/AD user: chsh won't work, use .bashrc exec fallback
    info "Domain user detected, configuring zsh via .bashrc..."
    _configure_bashrc_zsh_exec "${zsh_path}"
  fi
}

# Configure .bashrc to exec zsh for domain/AD users where chsh doesn't work
_configure_bashrc_zsh_exec() {
  local zsh_path="$1"
  local bashrc="${HOME}/.bashrc"
  local marker="# jsh: exec zsh"

  # Check if already configured
  if [[ -f "${bashrc}" ]] && grep -q "${marker}" "${bashrc}" 2>/dev/null; then
    prefix_info ".bashrc already configured to exec zsh"
    return 0
  fi

  # Create .bashrc if it doesn't exist
  touch "${bashrc}" 2>/dev/null || {
    prefix_warn "Could not create/modify .bashrc, skipping"
    return 0
  }

  # Append zsh exec block
  cat >>"${bashrc}" <<EOF

${marker}
# Switch to zsh if available and not already running
if [ -x "${zsh_path}" ] && [ -z "\$ZSH_VERSION" ]; then
    exec "${zsh_path}" -l
fi
EOF

  if [[ $? -eq 0 ]]; then
    prefix_success "Configured .bashrc to launch zsh"
  else
    prefix_warn "Could not configure .bashrc"
  fi
}

# Interactive setup wizard
_setup_interactive() {
  echo ""
  echo "${BOLD}Welcome to Jsh! Let's configure your shell.${RST}"
  echo ""

  # Editor selection
  local editor
  editor="$(ui_input "Select your preferred editor [vim/code/nano] (vim): " "vim")" || {
    warn "Editor selection cancelled, defaulting to vim"
    editor="vim"
  }

  # Vi-mode
  local vi_mode="n"
  if ui_confirm "Enable vi-mode keybindings?" "y"; then
    vi_mode="y"
  fi

  echo ""
  info "Saving configuration..."

  # Write configuration
  mkdir -p "${JSH_DIR}/local"
  cat >"${JSH_DIR}/local/.jshrc" <<EOF
# Jsh Configuration (generated by setup --interactive)
export EDITOR="${editor}"
export JSH_VI_MODE=$([[ "${vi_mode,,}" =~ ^y ]] && echo 1 || echo 0)
EOF

  prefix_success "Configuration saved to local/.jshrc"
  echo ""

  info "Continuing with setup..."

  # Initialize submodules (lazyvim handled separately with nvim)
  if [[ -d "${JSH_DIR}/.git" ]]; then
    info "Initializing submodules..."
    git -C "${JSH_DIR}" submodule update --init --depth 1 -- lib/fzf lib/fzf-tab lib/zsh-completions 2>/dev/null || warn "Failed to init submodules"
  fi

  # Create symlinks
  cmd_link

  # Attempt to set zsh as default shell
  set_default_shell_zsh

  success "Jsh setup complete!"
  show_next_steps
}

# Expand a user-provided path into an absolute path.
# Supports "~" and "~/...". Relative paths are resolved from $PWD.
_setup_abs_path() {
  local input_path="$1"
  local expanded="${input_path}"

  if [[ "${expanded}" == "~" ]]; then
    expanded="${HOME}"
  elif [[ "${expanded}" == \~/* ]]; then
    expanded="${HOME}/${expanded#~/}"
  elif [[ "${expanded}" != /* ]]; then
    expanded="$(pwd)/${expanded}"
  fi

  local parent
  parent="$(dirname "${expanded}")"
  if [[ -d "${parent}" ]]; then
    expanded="$(cd "${parent}" && pwd -P)/$(basename "${expanded}")"
  fi

  echo "${expanded}"
}

# Compute the managed dotfiles destination for an adopted path.
_setup_adopt_destination() {
  local original_abs="$1"
  local home_abs="${HOME}"
  if [[ -d "${HOME}" ]]; then
    home_abs="$(cd "${HOME}" && pwd -P)"
  fi
  local rel=""

  case "${original_abs}" in
  "${HOME}" | "${HOME}/")
    error "Refusing to adopt \$HOME directly"
    return 1
    ;;
  "${HOME}"/*)
    rel="${original_abs#"${HOME}"/}"
    ;;
  "${home_abs}" | "${home_abs}/")
    error "Refusing to adopt \$HOME directly"
    return 1
    ;;
  "${home_abs}"/*)
    rel="${original_abs#"${home_abs}"/}"
    ;;
  *)
    error "Adopt supports only paths under ${HOME}"
    return 1
    ;;
  esac

  echo "${JSH_DIR}/dotfiles/${rel}"
}

# Move a home path into dotfiles and symlink it back.
_setup_adopt_path() {
  local input_path="$1"
  local dry_run="${2:-false}"
  local original_abs dest

  original_abs="$(_setup_abs_path "${input_path}")"

  if [[ ! -e "${original_abs}" && ! -L "${original_abs}" ]]; then
    error "Path not found: ${input_path}"
    return 1
  fi

  if [[ -L "${original_abs}" ]]; then
    error "Cannot adopt a symlink directly: ${original_abs}"
    prefix_info "Point --adopt to a regular file or directory"
    return 1
  fi

  case "${original_abs}" in
  "${JSH_DIR}/dotfiles" | "${JSH_DIR}/dotfiles/"*)
    error "Path is already inside ${JSH_DIR}/dotfiles: ${original_abs}"
    return 1
    ;;
  *)
    if [[ -d "${JSH_DIR}/dotfiles" ]]; then
      local dotfiles_abs
      dotfiles_abs="$(cd "${JSH_DIR}/dotfiles" && pwd -P)"
      case "${original_abs}" in
      "${dotfiles_abs}" | "${dotfiles_abs}/"*)
        error "Path is already inside ${JSH_DIR}/dotfiles: ${original_abs}"
        return 1
        ;;
      esac
    fi
    ;;
  esac

  dest="$(_setup_adopt_destination "${original_abs}")" || return 1

  if [[ -e "${dest}" || -L "${dest}" ]]; then
    error "Destination already exists: ${dest}"
    prefix_info "Move or delete the existing destination first"
    return 1
  fi

  if [[ "${dry_run}" == true ]]; then
    prefix_info "Would move ${original_abs} -> ${dest}"
    prefix_info "Would link ${original_abs} -> ${dest}"
    return 0
  fi

  mkdir -p "$(dirname "${dest}")"

  if ! mv "${original_abs}" "${dest}"; then
    error "Failed to move ${original_abs} into dotfiles"
    return 1
  fi

  if ! ln -s "${dest}" "${original_abs}"; then
    mv "${dest}" "${original_abs}" 2>/dev/null || true
    error "Failed to create symlink at ${original_abs}"
    return 1
  fi

  prefix_success "Adopted ${original_abs}"
  prefix_info "Managed target: ${dest}"
}

# Remove empty directories up to a base path (inclusive stop).
_setup_remove_empty_parents() {
  local dir="$1"
  local stop_at="$2"

  while [[ -n "${dir}" && "${dir}" != "/" ]]; do
    [[ "${dir}" == "${stop_at}" ]] && break
    if [[ -d "${dir}" ]] && [[ -z "$(ls -A "${dir}" 2>/dev/null)" ]]; then
      rmdir "${dir}" 2>/dev/null || break
      dir="$(dirname "${dir}")"
      continue
    fi
    break
  done
}

# Undo adopt by moving the managed target back to its original path.
_setup_decom_path() {
  local input_path="$1"
  local dry_run="${2:-false}"
  local skip_confirm="${3:-false}"
  local original_abs raw_link resolved_link

  original_abs="$(_setup_abs_path "${input_path}")"

  if [[ ! -L "${original_abs}" ]]; then
    error "Path is not a symlink: ${original_abs}"
    return 1
  fi

  raw_link="$(readlink "${original_abs}")"
  if [[ "${raw_link}" == /* ]]; then
    resolved_link="${raw_link}"
  else
    resolved_link="$(cd "$(dirname "${original_abs}")" && pwd -P)/${raw_link}"
  fi

  if [[ -e "${resolved_link}" || -L "${resolved_link}" ]]; then
    resolved_link="$(cd "$(dirname "${resolved_link}")" && pwd -P)/$(basename "${resolved_link}")"
  fi

  local dotfiles_root="${JSH_DIR}/dotfiles"
  local dotfiles_abs="${dotfiles_root}"
  if [[ -d "${dotfiles_root}" ]]; then
    dotfiles_abs="$(cd "${dotfiles_root}" && pwd -P)"
  fi

  case "${resolved_link}" in
  "${dotfiles_root}/"* | "${dotfiles_abs}/"*) ;;
  *)
    error "Symlink is not managed by jsh dotfiles: ${original_abs} -> ${resolved_link}"
    return 1
    ;;
  esac

  if [[ ! -e "${resolved_link}" && ! -L "${resolved_link}" ]]; then
    error "Managed target is missing: ${resolved_link}"
    return 1
  fi

  if [[ "${skip_confirm}" != true ]]; then
    echo ""
    echo "${YLW}Decommission adopted path?${RST}"
    echo "This will remove symlink: ${CYN}${original_abs}${RST}"
    echo "And move back target: ${CYN}${resolved_link}${RST}"
    echo ""
    if ! ui_confirm_token "Type 'yes' to confirm:" "yes"; then
      info "Decommission cancelled."
      return 0
    fi
  fi

  if [[ "${dry_run}" == true ]]; then
    prefix_info "Would remove symlink ${original_abs}"
    prefix_info "Would move ${resolved_link} -> ${original_abs}"
    return 0
  fi

  rm "${original_abs}" || {
    error "Failed to remove symlink: ${original_abs}"
    return 1
  }

  mkdir -p "$(dirname "${original_abs}")"
  if ! mv "${resolved_link}" "${original_abs}"; then
    ln -s "${resolved_link}" "${original_abs}" 2>/dev/null || true
    error "Failed to restore original path: ${original_abs}"
    return 1
  fi

  _setup_remove_empty_parents "$(dirname "${resolved_link}")" "${JSH_DIR}/dotfiles"

  prefix_success "Decommissioned ${original_abs}"
}

# @jsh-cmd setup Setup jsh environment
# @jsh-opt -i,--interactive Run interactive setup wizard
# @jsh-opt --no-git Skip git operations (submodule init)
# @jsh-opt --links Create only managed dotfile symlinks
# @jsh-opt --adopt=PATH Move PATH into dotfiles and link it back
# @jsh-opt --decom=PATH Undo adopted symlink and restore original path
# @jsh-opt -y,--yes Skip confirmation for --decom
# @jsh-opt -n,--dry-run Preview actions without making changes
cmd_setup() {
  local interactive=false
  local skip_git=false
  local links_only=false
  local dry_run=false
  local skip_confirm=false
  local adopt_path=""
  local decom_path=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
    -i | --interactive)
      interactive=true
      shift
      ;;
    --no-git)
      skip_git=true
      shift
      ;;
    --links)
      links_only=true
      shift
      ;;
    --adopt=*)
      adopt_path="${1#--adopt=}"
      shift
      ;;
    --adopt)
      shift
      adopt_path="${1:-}"
      [[ -z "${adopt_path}" ]] && {
        error "Missing value for --adopt"
        return 1
      }
      shift
      ;;
    --decom=*)
      decom_path="${1#--decom=}"
      shift
      ;;
    --decom)
      shift
      decom_path="${1:-}"
      [[ -z "${decom_path}" ]] && {
        error "Missing value for --decom"
        return 1
      }
      shift
      ;;
    --yes | -y)
      skip_confirm=true
      shift
      ;;
    -n | --dry-run)
      dry_run=true
      shift
      ;;
    *) shift ;;
    esac
  done

  show_banner

  if [[ "${dry_run}" == true ]]; then
    info "Dry run mode enabled"
  fi

  if [[ "${links_only}" == true ]] && [[ "${interactive}" == true ]]; then
    error "setup --interactive cannot be combined with --links"
    return 1
  fi

  if [[ -n "${adopt_path}" && -n "${decom_path}" ]]; then
    error "setup --adopt and --decom cannot be combined"
    return 1
  fi

  if [[ -n "${adopt_path}" ]] && [[ "${interactive}" == true || "${links_only}" == true ]]; then
    error "setup --adopt cannot be combined with --interactive or --links"
    return 1
  fi

  if [[ -n "${decom_path}" ]] && [[ "${interactive}" == true || "${links_only}" == true ]]; then
    error "setup --decom cannot be combined with --interactive or --links"
    return 1
  fi

  if [[ -n "${adopt_path}" ]]; then
    _setup_adopt_path "${adopt_path}" "${dry_run}"
    [[ $? -eq 0 ]] && success "Adopt complete"
    return $?
  fi

  if [[ -n "${decom_path}" ]]; then
    _setup_decom_path "${decom_path}" "${dry_run}" "${skip_confirm}"
    [[ $? -eq 0 ]] && success "Decommission complete"
    return $?
  fi

  if [[ "$interactive" == true ]]; then
    if [[ "${dry_run}" == true ]]; then
      error "setup --interactive cannot be combined with --dry-run"
      return 1
    fi
    _setup_interactive
    return
  fi

  if [[ "${links_only}" == true ]]; then
    if [[ "${dry_run}" == true ]]; then
      cmd_link --dry-run
      success "Dry run complete"
    else
      cmd_link
      success "Links setup complete"
    fi
    return 0
  fi

  info "Setting up jsh..."

  # Initialize submodules (unless --no-git or git unavailable)
  if [[ "${skip_git}" == true ]]; then
    prefix_info "Skipping git operations (--no-git)"
  elif ! has git; then
    prefix_info "git not found, skipping submodule init"
  elif [[ -d "${JSH_DIR}/.git" ]]; then
    # Init core submodules (lazyvim handled separately with nvim)
    local core_submodules=(lib/fzf lib/fzf-tab lib/zsh-completions)
    if [[ "${dry_run}" == true ]]; then
      prefix_info "Would run: git -C ${JSH_DIR} submodule update --init --depth 1 -- ${core_submodules[*]}"
    elif git -C "${JSH_DIR}" submodule update --init --depth 1 -- "${core_submodules[@]}" 2>/dev/null; then
      _show_submodule_status "${JSH_DIR}" "${core_submodules[@]}"
    else
      warn "Failed to init submodules"
    fi
  fi

  # Create symlinks
  if [[ "${dry_run}" == true ]]; then
    cmd_link --dry-run
  else
    cmd_link
  fi

  # Create local config directory
  if [[ "${dry_run}" == true ]]; then
    prefix_info "Would create ${JSH_DIR}/local"
  else
    mkdir -p "${JSH_DIR}/local"
  fi

  # Attempt to set zsh as default shell
  if [[ "${dry_run}" == true ]]; then
    JSH_DRY_RUN=1 set_default_shell_zsh
  else
    set_default_shell_zsh
  fi

  if [[ "${dry_run}" == true ]]; then
    success "Dry run complete"
  else
    success "Jsh setup complete!"
  fi
  show_next_steps
}

# @jsh-cmd teardown Remove jsh symlinks and optionally the entire installation
# @jsh-opt --full Remove entire Jsh directory
# @jsh-opt -r,--restore Restore backed up dotfiles
# @jsh-opt --restore=NAME Restore from a specific backup name
# @jsh-opt -y,--yes Skip confirmation prompt
# @jsh-opt --links Remove only managed dotfile symlinks
cmd_teardown() {
  local full_teardown=false
  local restore_backup=""
  local skip_confirm=false
  local links_only=false

  while [[ $# -gt 0 ]]; do
    case "$1" in
    --full | -f)
      full_teardown=true
      shift
      ;;
    --restore=*)
      restore_backup="${1#--restore=}"
      shift
      ;;
    --restore | -r)
      restore_backup="latest"
      shift
      ;;
    --yes | -y)
      skip_confirm=true
      shift
      ;;
    --links)
      links_only=true
      shift
      ;;
    *)
      shift
      ;;
    esac
  done

  if [[ "${links_only}" == true ]]; then
    if [[ "${full_teardown}" == true ]]; then
      error "teardown --links cannot be combined with --full"
      return 1
    fi
    if [[ -n "${restore_backup}" ]]; then
      if [[ "${restore_backup}" == "latest" ]]; then
        cmd_unlink --restore
      else
        cmd_unlink "--restore=${restore_backup}"
      fi
    else
      cmd_unlink
    fi
    success "Link teardown complete."
    return 0
  fi

  if [[ "${skip_confirm}" != true ]]; then
    echo ""
    echo "${YLW}Are you sure you want to teardown jsh? T_T${RST}"
    if [[ "${full_teardown}" == true ]]; then
      echo "${RED}This will completely remove ${JSH_DIR}!${RST}"
    fi
    echo ""
    if ! ui_confirm_token "Type 'yes' to confirm:" "yes"; then
      info "Teardown cancelled. Phew! :)"
      return 0
    fi
    echo ""
  fi

  info "Tearing down jsh..."

  if [[ -n "${restore_backup}" ]]; then
    if [[ "${restore_backup}" == "latest" ]]; then
      cmd_unlink --restore
    else
      cmd_unlink "--restore=${restore_backup}"
    fi
  else
    cmd_unlink
  fi

  if [[ "${full_teardown}" == true ]]; then
    if [[ -d "${JSH_DIR}" ]]; then
      warn "Removing ${JSH_DIR}..."
      if ! rm -rf "${JSH_DIR}" 2>/dev/null; then
        error "Could not remove ${JSH_DIR}"
        return 1
      fi
      success "Jsh completely removed from ${JSH_DIR}"
    fi
  else
    success "jsh teardown complete (dotfiles unlinked)."
  fi

  echo ""
  echo "Don't forget to remove the 'source ~/.jsh/src/init.sh' line"
  echo "from your .zshrc or .bashrc"
}

# Internal helper: create symlinks for managed dotfiles
cmd_link() {
  local dry_run=false

  while [[ $# -gt 0 ]]; do
    case "$1" in
    -n | --dry-run)
      dry_run=true
      shift
      ;;
    *)
      shift
      ;;
    esac
  done

  local backup_dir
  backup_dir="${HOME}/.jsh_backup/$(date +%Y%m%d_%H%M%S)"

  if [[ "${dry_run}" == true ]]; then
    info "Dry run: previewing symlink changes..."
    local had_dry_run=false
    [[ -n "${JSH_DRY_RUN+x}" ]] && had_dry_run=true
    local prev_dry_run="${JSH_DRY_RUN:-}"
    JSH_DRY_RUN=1 _process_symlink_rules "${backup_dir}" "link"
    if [[ "${had_dry_run}" == true ]]; then
      JSH_DRY_RUN="${prev_dry_run}"
    else
      unset JSH_DRY_RUN
    fi
    success "Dry run complete"
  else
    info "Creating symlinks..."
    _process_symlink_rules "${backup_dir}" "link"
    success "Symlinks created"
  fi
}

# Internal helper: remove symlinks (optionally restore backups)
cmd_unlink() {
  local restore_backup=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
    --restore=*)
      restore_backup="${1#--restore=}"
      shift
      ;;
    --restore)
      restore_backup="latest"
      shift
      ;;
    *)
      shift
      ;;
    esac
  done

  info "Removing symlinks..."
  _process_symlink_rules "" "unlink"
  success "Symlinks removed"

  # Restore from backup if requested
  if [[ -n "${restore_backup}" ]]; then
    echo ""
    _restore_backup "${restore_backup}"
  fi
}

_restore_backup() {
  local selected_backup="${1:-}"
  local backup_base="${HOME}/.jsh_backup"

  if [[ ! -d "${backup_base}" ]]; then
    warn "No backups found at ${backup_base}"
    return 1
  fi

  local backups=()
  while IFS= read -r dir; do
    [[ -d "${dir}" ]] && backups+=("$(basename "${dir}")")
  done < <(find "${backup_base}" -mindepth 1 -maxdepth 1 -type d | sort -r)

  if [[ ${#backups[@]} -eq 0 ]]; then
    warn "No backups found in ${backup_base}"
    return 1
  fi

  # List backups if no selection
  if [[ -z "${selected_backup}" ]]; then
    jsh_section "Available Backups"
    for i in "${!backups[@]}"; do
      local backup="${backups[${i}]}"
      local backup_path="${backup_base}/${backup}"
      local file_count
      file_count=$(find "${backup_path}" -type f 2>/dev/null | wc -l | tr -d ' ')
      if [[ ${i} -eq 0 ]]; then
        echo "${CYN}${backup}${RST} (${file_count} files) ${GRN}[latest]${RST}"
      else
        echo "${backup} (${file_count} files)"
      fi
    done
    echo ""
    echo "Usage: ${CYN}jsh teardown --links --restore${RST}"
    return 0
  fi

  if [[ "${selected_backup}" == "latest" ]]; then
    selected_backup="${backups[0]}"
  fi

  local backup_path="${backup_base}/${selected_backup}"

  if [[ ! -d "${backup_path}" ]]; then
    error "Backup not found: ${selected_backup}"
    jsh_section "Available Backups"
    printf '%s\n' "${backups[@]}"
    return 1
  fi

  info "Restoring from backup: ${selected_backup}"

  local restored=0
  while IFS= read -r backup_file; do
    local filename
    filename=$(basename "${backup_file}")
    local relative_path="${backup_file#"${backup_path}"/}"
    local dest

    dest="${HOME}/${filename}"

    if [[ -L "${dest}" ]]; then
      local resolved
      resolved=$(readlink -f "${dest}" 2>/dev/null || readlink "${dest}")
      if [[ "${resolved}" == "${JSH_DIR}/"* ]] || [[ "${resolved}" == "${JSH_DIR}" ]]; then
        rm "${dest}"
        prefix_info "Removed symlink: ${dest}"
      else
        prefix_warn "Skipping ${filename}: symlink points to non-jsh location"
        continue
      fi
    elif [[ -e "${dest}" ]]; then
      prefix_warn "Skipping ${filename}: destination exists and is not a jsh symlink"
      continue
    fi

    if [[ -d "${backup_file}" ]]; then
      cp -R "${backup_file}" "${dest}"
    else
      cp "${backup_file}" "${dest}"
    fi
    prefix_success "Restored ${relative_path}"
    ((restored++))
  done < <(find "${backup_path}" -mindepth 1 -maxdepth 1)

  if [[ ${restored} -eq 0 ]]; then
    prefix_warn "No files were restored"
  else
    prefix_success "Restored ${restored} file(s) from ${selected_backup}"
  fi
}

# @jsh-cmd reload Reload shell and re-initialize jsh
cmd_reload() {
  if [[ "${1:-}" == "-h" ]] || [[ "${1:-}" == "--help" ]]; then
    echo "${BOLD}jsh reload${RST} - Reload shell and re-initialize jsh"
    echo ""
    echo "${BOLD}USAGE:${RST}"
    echo "jsh reload"
    echo ""
    return 0
  fi

  local shell_bin="${SHELL:-}"

  if [[ -z "${shell_bin}" ]] || [[ ! -x "${shell_bin}" ]]; then
    shell_bin="$(command -v zsh 2>/dev/null || command -v bash 2>/dev/null || command -v sh 2>/dev/null || true)"
  fi

  if [[ -z "${shell_bin}" ]]; then
    error "Could not determine a shell binary to reload"
    return 1
  fi

  info "Reloading shell with jsh initialization..."
  exec "${shell_bin}" -l
}
