#compdef j
# shellcheck shell=bash
# shellcheck disable=SC2207,SC2296,SC2034,SC2154,SC2206,SC2155,SC2128,SC1087
# SC2207: zsh array syntax differs from bash
# SC2296: zsh parameter expansion syntax
# SC2034: variables used by zsh completion system
# SC2154: variables provided by zsh completion system
# SC2206: word splitting is intentional for zsh arrays
# SC2155: declare and assign separately - acceptable in completions
# SC2128: zsh array subscripting syntax differs from bash
# SC1087: zsh uses $var[idx] not ${var[idx]}

# ============================================================================
# j - Zsh Completion (Smart Directory Jumping)
# ============================================================================
# Tab completion for the j command (zoxide-like directory jumping)
# Provides directory suggestions from the frecency database and projects
# ============================================================================

_j() {
    local curcontext="$curcontext" state line
    typeset -A opt_args

    local -a commands
    commands=(
        '-c:Open in VS Code after jumping'
        '--code:Open in VS Code after jumping'
        '-r:Open remote project in VS Code'
        '--remote:Open remote project in VS Code'
        '--add:Add current directory to database'
        '-a:Add current directory to database'
        '--remove:Remove current directory from database'
        '--list:List all directories with scores'
        '-l:List all directories with scores'
        '--clean:Remove non-existent directories'
        '--help:Show help'
        '-h:Show help'
        '-:Jump to previous directory'
    )

    _arguments -C \
        '1: :->first_arg' \
        '*: :->query'

    case $state in
        first_arg)
            # Offer commands and directories
            _describe -t commands 'j commands' commands

            # Add directory completions
            _j_directories
            ;;
        query)
            # After -r, complete with remote project names
            local prev_word="${words[CURRENT-1]:-}"
            if [[ "$prev_word" == "-r" || "$prev_word" == "--remote" ]]; then
                _j_remote_projects
                return
            fi

            # Additional query terms - offer directories only
            _j_directories
            ;;
    esac
}

# Complete directories from j database and projects
_j_directories() {
    local j_data="${J_DATA:-${XDG_DATA_HOME:-${HOME}/.local/share}/jsh/j.db}"
    local -a dirs

    # Load from j database
    if [[ -f "$j_data" ]]; then
        local line path score time
        while IFS='|' read -r path score time; do
            [[ -z "$path" ]] && continue
            [[ ! -d "$path" ]] && continue
            # Convert to display format (~/ prefix)
            local display_path="$path"
            [[ "$path" == "${HOME}"* ]] && display_path="~${path#$HOME}"
            dirs+=("${display_path}:Frecency score ${score}")
        done < "$j_data"
    fi

    # Add projects from JSH_PROJECTS paths (fast - no git status)
    local projects_paths="${JSH_PROJECTS:-${HOME}/.jsh,${HOME}/projects/*}"
    local entry
    # Use zsh (s:,:) parameter expansion to split on commas
    for entry in ${(s:,:)projects_paths}; do
        entry="${entry/#\~/${HOME}}"
        entry="${entry#"${entry%%[![:space:]]*}"}"  # trim leading whitespace
        entry="${entry%"${entry##*[![:space:]]}"}"  # trim trailing whitespace

        if [[ "$entry" == *"*"* ]]; then
            # Expand glob pattern using zsh ${~var} syntax
            local dir
            for dir in ${~entry}; do
                [[ ! -d "$dir" ]] && continue
                local display_path="$dir"
                [[ "$dir" == "${HOME}"* ]] && display_path="~${dir#$HOME}"
                dirs+=("${display_path}:Project")
            done
        elif [[ -d "$entry" ]]; then
            local display_path="$entry"
            [[ "$entry" == "${HOME}"* ]] && display_path="~${entry#$HOME}"
            dirs+=("${display_path}:Project")
        fi
    done

    if [[ ${#dirs[@]} -gt 0 ]]; then
        _describe -t directories 'directories' dirs
    fi
}

# Complete remote project names from projects.json
_j_remote_projects() {
    local config_file="${JSH_DIR:-${HOME}/.jsh}/local/projects.json"
    local -a remotes

    if [[ -f "$config_file" ]] && command -v jq &>/dev/null; then
        local name host path
        while IFS=$'\t' read -r name host path; do
            [[ -z "$name" ]] && continue
            remotes+=("${name}:${host}:${path}")
        done < <(jq -r '.remotes | to_entries[] | [.key, .value.host, .value.path] | @tsv' "$config_file" 2>/dev/null)
    fi

    if [[ ${#remotes[@]} -gt 0 ]]; then
        _describe -t remotes 'remote projects' remotes
    fi
}

_j "$@"
