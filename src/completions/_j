#compdef j
# shellcheck shell=bash
# shellcheck disable=SC2207,SC2296,SC2034,SC2154,SC2206,SC2155,SC2128,SC1087
# SC2207: zsh array syntax differs from bash
# SC2296: zsh parameter expansion syntax
# SC2034: variables used by zsh completion system
# SC2154: variables provided by zsh completion system
# SC2206: word splitting is intentional for zsh arrays
# SC2155: declare and assign separately - acceptable in completions
# SC2128: zsh array subscripting syntax differs from bash
# SC1087: zsh uses $var[idx] not ${var[idx]}

# ============================================================================
# j - Zsh Completion (Smart Directory Jumping)
# ============================================================================
# Tab completion for the j command (zoxide-like directory jumping)
# Provides directory suggestions from the frecency database and projects
# ============================================================================

_j() {
    local curcontext="$curcontext" state line
    typeset -A opt_args

    _arguments -C \
        '1: :->first_arg' \
        '*: :->query'

    case $state in
        first_arg)
            # After -r, complete with remote project names
            if [[ "${words[1]}" == "-r" || "${words[1]}" == "--remote" ]]; then
                _j_remote_projects
                return
            fi

            # Only show directories/projects (no flags)
            _j_directories
            ;;
        query)
            # After -r, complete with remote project names
            local prev_word="${words[CURRENT-1]:-}"
            if [[ "$prev_word" == "-r" || "$prev_word" == "--remote" ]]; then
                _j_remote_projects
                return
            fi

            # Additional query terms - directories only
            _j_directories
            ;;
    esac
}

# Complete directories from j database and projects
# j uses fuzzy matching, so we complete with basenames (what users type)
# and show full paths as descriptions (for context)
_j_directories() {
    local j_data="${J_DATA:-${XDG_DATA_HOME:-${HOME}/.local/share}/jsh/j.db}"
    local -a dirs
    local -A seen  # Track seen basenames to avoid duplicates

    # Load from j database
    if [[ -f "$j_data" ]]; then
        local line path score time
        while IFS='|' read -r path score time; do
            [[ -z "$path" ]] && continue
            [[ ! -d "$path" ]] && continue

            local basename="${path:t}"  # zsh :t modifier = basename
            local display_path="$path"
            [[ "$path" == "${HOME}"* ]] && display_path="~${path#$HOME}"

            # Skip if we've seen this basename (keep highest score)
            [[ -n "${seen[$basename]}" ]] && continue
            seen[$basename]=1

            dirs+=("${basename}:${display_path}")
        done < "$j_data"
    fi

    # Add projects from JSH_PROJECTS paths (fast - no git status)
    local projects_paths="${JSH_PROJECTS:-${HOME}/.jsh,${HOME}/projects/*}"
    local entry
    # Use zsh (s:,:) parameter expansion to split on commas
    for entry in ${(s:,:)projects_paths}; do
        entry="${entry/#\~/${HOME}}"
        entry="${entry#"${entry%%[![:space:]]*}"}"  # trim leading whitespace
        entry="${entry%"${entry##*[![:space:]]}"}"  # trim trailing whitespace

        if [[ "$entry" == *"*"* ]]; then
            # Expand glob pattern using zsh ${~var} syntax
            local dir
            for dir in ${~entry}; do
                [[ ! -d "$dir" ]] && continue

                local basename="${dir:t}"
                local display_path="$dir"
                [[ "$dir" == "${HOME}"* ]] && display_path="~${dir#$HOME}"

                [[ -n "${seen[$basename]}" ]] && continue
                seen[$basename]=1

                dirs+=("${basename}:${display_path}")
            done
        elif [[ -d "$entry" ]]; then
            local basename="${entry:t}"
            local display_path="$entry"
            [[ "$entry" == "${HOME}"* ]] && display_path="~${entry#$HOME}"

            [[ -n "${seen[$basename]}" ]] && continue
            seen[$basename]=1

            dirs+=("${basename}:${display_path}")
        fi
    done

    if [[ ${#dirs[@]} -gt 0 ]]; then
        _describe -t directories 'directories' dirs
    fi
}

# Complete remote project names from projects.json
_j_remote_projects() {
    local config_file="${JSH_DIR:-${HOME}/.jsh}/local/projects.json"
    local -a remotes

    if [[ -f "$config_file" ]] && command -v jq &>/dev/null; then
        local name host path
        while IFS=$'\t' read -r name host path; do
            [[ -z "$name" ]] && continue
            remotes+=("${name}:${host}:${path}")
        done < <(jq -r '.remotes | to_entries[] | [.key, .value.host, .value.path] | @tsv' "$config_file" 2>/dev/null)
    fi

    if [[ ${#remotes[@]} -gt 0 ]]; then
        _describe -t remotes 'remote projects' remotes
    fi
}

_j "$@"
