#compdef j p jj
# shellcheck shell=bash
# shellcheck disable=SC2207,SC2296,SC2034,SC2154,SC2206,SC2155,SC2128,SC1087
# SC2207: zsh array syntax differs from bash
# SC2296: zsh parameter expansion syntax
# SC2034: variables used by zsh completion system
# SC2154: variables provided by zsh completion system
# SC2206: word splitting is intentional for zsh arrays
# SC2155: declare and assign separately - acceptable in completions
# SC2128: zsh array subscripting syntax differs from bash
# SC1087: zsh uses $var[idx] not ${var[idx]}

# ============================================================================
# j - Zsh Completion (Smart Directory Jumping + Project Management)
# ============================================================================
# Tab completion for the j command
# Provides directory/project navigation, cloning, creation, and profiles
# ============================================================================

_j() {
    local curcontext="$curcontext" state line
    typeset -A opt_args

    # Handle jj alias: directly complete profile arguments
    if [[ "$service" == "jj" ]]; then
        _j_profile
        return
    fi

    _arguments -C \
        '(-v --verbose)'{-v,--verbose}'[Show search steps]' \
        '(-c --code)'{-c,--code}'[Open in VS Code]' \
        '(-r --remote)'{-r,--remote}'[Open remote project]' \
        '1: :->first_arg' \
        '*::arg:->args'

    case $state in
        first_arg)
            # After -r, complete with remote project names
            if [[ "${words[1]}" == "-r" || "${words[1]}" == "--remote" ]]; then
                _j_remote_projects
                return
            fi

            # Show subcommands + directories/projects
            _j_commands_and_directories
            ;;
        args)
            case $words[1] in
                profile)
                    _j_profile
                    ;;
                add)
                    _j_add
                    ;;
                create)
                    _arguments '1:project name:'
                    ;;
                -r|--remote)
                    _j_remote_projects
                    ;;
                *)
                    # Additional query terms - directories only
                    _j_directories
                    ;;
            esac
            ;;
    esac
}

# Main completion: subcommands + directories/projects
_j_commands_and_directories() {
    local -a commands
    commands=(
        'add:Clone repository and cd into it'
        'create:Create project directory and cd into it'
        'profile:Git profile management'
        'update:Safe pull with stash and rebase'
    )

    _describe -t commands 'commands' commands

    # Also complete directories/projects for quick navigation
    _j_directories
}

# Complete directories from j database and projects
# j uses fuzzy matching, so we complete with basenames (what users type)
# and show full paths as descriptions (for context)
_j_directories() {
    local j_data="${J_DATA:-${XDG_DATA_HOME:-${HOME}/.local/share}/jsh/j.db}"
    local -a dirs
    local -A seen  # Track seen basenames to avoid duplicates

    # Load from j database
    if [[ -f "$j_data" ]]; then
        local line path score time
        while IFS='|' read -r path score time; do
            [[ -z "$path" ]] && continue
            [[ ! -d "$path" ]] && continue

            local basename="${path:t}"  # zsh :t modifier = basename
            local display_path="$path"
            [[ "$path" == "${HOME}"* ]] && display_path="~${path#$HOME}"

            # Skip if we've seen this basename (keep highest score)
            [[ -n "${seen[$basename]}" ]] && continue
            seen[$basename]=1

            dirs+=("${basename}:${display_path}")
        done < "$j_data"
    fi

    # Add projects from JSH_PROJECTS paths (fast - no git status)
    local projects_paths="${JSH_PROJECTS:-${HOME}/.jsh,${HOME}/projects/*}"
    local entry
    # Use zsh (s:,:) parameter expansion to split on commas
    for entry in ${(s:,:)projects_paths}; do
        entry="${entry/#\~/${HOME}}"
        entry="${entry#"${entry%%[![:space:]]*}"}"  # trim leading whitespace
        entry="${entry%"${entry##*[![:space:]]}"}"  # trim trailing whitespace

        if [[ "$entry" == *"*"* ]]; then
            # Expand glob pattern using zsh ${~var} syntax
            local dir
            for dir in ${~entry}; do
                [[ ! -d "$dir" ]] && continue

                local basename="${dir:t}"
                local display_path="$dir"
                [[ "$dir" == "${HOME}"* ]] && display_path="~${dir#$HOME}"

                [[ -n "${seen[$basename]}" ]] && continue
                seen[$basename]=1

                dirs+=("${basename}:${display_path}")
            done
        elif [[ -d "$entry" ]]; then
            local basename="${entry:t}"
            local display_path="$entry"
            [[ "$entry" == "${HOME}"* ]] && display_path="~${entry#$HOME}"

            [[ -n "${seen[$basename]}" ]] && continue
            seen[$basename]=1

            dirs+=("${basename}:${display_path}")
        fi
    done

    if [[ ${#dirs[@]} -gt 0 ]]; then
        _describe -t directories 'directories' dirs
    fi
}

# Complete remote project names from projects.json
_j_remote_projects() {
    local config_file="${JSH_DIR:-${HOME}/.jsh}/local/projects.json"
    local -a remotes

    if [[ -f "$config_file" ]] && command -v jq &>/dev/null; then
        local name host path
        while IFS=$'\t' read -r name host path; do
            [[ -z "$name" ]] && continue
            remotes+=("${name}:${host}:${path}")
        done < <(jq -r '.remotes | to_entries[] | [.key, .value.host, .value.path] | @tsv' "$config_file" 2>/dev/null)
    fi

    if [[ ${#remotes[@]} -gt 0 ]]; then
        _describe -t remotes 'remote projects' remotes
    fi
}

# Profile subcommands + profile names
_j_profile() {
    local -a commands profiles
    commands=(
        'list:List all configured profiles'
        'status:Show current profile for this repo'
        'check:Verify profile configuration'
        'docs:Show profile documentation'
    )

    # Add dynamic profile names if config exists
    local jsh_profiles="${JSH_PROFILES:-${HOME}/.jsh/local/profiles.json}"
    if [[ -f "$jsh_profiles" ]] && command -v jq &>/dev/null; then
        local p
        for p in $(jq -r '.profiles | keys | .[]' "$jsh_profiles" 2>/dev/null); do
            [[ -n "$p" ]] && profiles+=("${p}:Apply profile '${p}' to current repo")
        done
    fi

    _describe -t commands 'command' commands
    (( ${#profiles[@]} )) && _describe -t profiles 'profile' profiles
}

# Add command - git URL then optional name
_j_add() {
    _arguments -C \
        '1:git URL:_urls' \
        '2:local name (optional):'
}

_j "$@"
