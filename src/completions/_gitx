#compdef gitx
# shellcheck shell=bash
# shellcheck disable=SC2207,SC2296,SC2034,SC2154,SC2206,SC2155,SC2128,SC1087
# Zsh completion for gitx - fully dynamic from help output

# ============================================================================
# gitx - Zsh Completion (Fully Dynamic)
# ============================================================================
# All completions are dynamically extracted from gitx help output.
# Adding/removing commands in bin/gitx automatically updates completions.
# ============================================================================

_gitx() {
    local curcontext="$curcontext" state line
    typeset -A opt_args

    _arguments -C \
        '(-h --help)'{-h,--help}'[Show help message]' \
        '(-i --interactive)'{-i,--interactive}'[Enable interactive mode]' \
        '(-t --timestamp)'{-t,--timestamp}'[Set timestamp]:timestamp:' \
        '(-v --verbose)'{-v,--verbose}'[Verbose output]' \
        '1: :->command' \
        '*::arg:->args'

    case $state in
        command)
            _gitx_commands
            ;;
        args)
            _gitx_subcommands "${words[1]}"
            ;;
    esac
}

# Cache for help output (avoid repeated calls)
typeset -gA _gitx_help_cache

# Get gitx help output (cached)
_gitx_get_help() {
    local gitx_path="${JSH_DIR:-${HOME}/.jsh}/bin/gitx"

    if [[ -z "${_gitx_help_cache[main]:-}" ]]; then
        if [[ -x "$gitx_path" ]]; then
            _gitx_help_cache[main]=$("$gitx_path" --help 2>/dev/null | perl -pe 's/\e\[[0-9;]*m//g')
        fi
    fi
    printf '%s' "${_gitx_help_cache[main]:-}"
}

# Dynamically extract main commands from gitx help output
_gitx_commands() {
    local -a commands
    local help_output
    help_output=$(_gitx_get_help)

    if [[ -n "$help_output" ]]; then
        # Extract commands from COMMANDS section
        commands=(${(f)"$(
            printf '%s' "$help_output" | awk '
                /^COMMANDS/ { in_section=1; next }
                /^[A-Z]/ { in_section=0 }
                in_section && /^[ \t]+[a-z]/ {
                    line = $0
                    gsub(/^[ \t]+/, "", line)
                    # Extract command (first word)
                    cmd = line
                    sub(/[ \t].*/, "", cmd)
                    # Extract description (after command and args like <name>)
                    desc = line
                    sub(/^[^ \t]+[ \t]+/, "", desc)
                    sub(/^<[^>]+>[ \t]+/, "", desc)
                    if (cmd && desc) print cmd ":" desc
                }
            '
        )"})
    fi

    # Fallback if dynamic extraction fails
    if [[ ${#commands[@]} -eq 0 ]]; then
        commands=(
            'update:Safe pull with stash and rebase'
            'profile:Show or apply git profile'
            'clone:Clone repository with smart SSH'
            'create:Create new project'
            'list:List all projects'
            'path:Output project path'
        )
    fi

    _describe -t commands 'gitx commands' commands
}

# Dynamically extract subcommands for a given command
_gitx_subcommands() {
    local cmd="$1"
    local -a subcommands
    local help_output
    help_output=$(_gitx_get_help)

    # First, check SUBCOMMANDS section for command:subcommand entries
    if [[ -n "$help_output" ]]; then
        subcommands=(${(f)"$(
            printf '%s' "$help_output" | awk -v cmd="$cmd" '
                /^SUBCOMMANDS/ { in_section=1; next }
                /^[A-Z]/ && !/^SUBCOMMANDS/ { in_section=0 }
                in_section && $0 ~ "^[ \t]+"cmd":" {
                    line = $0
                    gsub(/^[ \t]+/, "", line)
                    # Format: command:subcommand  description
                    sub(/^[^:]+:/, "", line)  # Remove "command:"
                    subcmd = line
                    sub(/[ \t].*/, "", subcmd)
                    desc = line
                    sub(/^[^ \t]+[ \t]+/, "", desc)
                    if (subcmd && desc) print subcmd ":" desc
                }
            '
        )"})
    fi

    # If we found subcommands, offer them
    if [[ ${#subcommands[@]} -gt 0 ]]; then
        _describe -t subcommands "${cmd} subcommands" subcommands
        return
    fi

    # Special handling for commands that need dynamic data
    case "$cmd" in
        profile)
            # Add profile names from config
            local jsh_profiles="${JSH_PROFILES:-${HOME}/.jsh/local/profiles.json}"
            if [[ -f "$jsh_profiles" ]] && command -v jq &>/dev/null; then
                local -a profiles
                profiles=(${(f)"$(jq -r '.profiles | keys | .[]' "$jsh_profiles" 2>/dev/null)"})
                for p in "${profiles[@]}"; do
                    [[ -n "$p" ]] && subcommands+=("$p:Apply profile '$p' to current repo")
                done
                _describe -t profiles 'profiles' subcommands
            fi
            ;;
        remote)
            # List remote projects from config
            local remote_config="${JSH_DIR:-${HOME}/.jsh}/local/projects.json"
            if [[ -f "$remote_config" ]] && command -v jq &>/dev/null; then
                local -a remotes
                remotes=(${(f)"$(jq -r '.remotes | keys[]' "$remote_config" 2>/dev/null)"})
                for r in "${remotes[@]}"; do
                    [[ -n "$r" ]] && subcommands+=("$r:Open remote project '$r'")
                done
                _describe -t remotes 'remote projects' subcommands
            fi
            ;;
        path)
            # List local projects
            _gitx_path_projects
            ;;
        clone|add)
            # URL completion
            _arguments '1:git URL:_urls' '2:local name:'
            ;;
        *)
            # For unknown commands, try git completion as fallback
            _git
            ;;
    esac
}

# Path command - complete project names dynamically
_gitx_path_projects() {
    local -a projects
    local projects_paths="${JSH_PROJECTS:-${HOME}/.jsh,${HOME}/projects/*}"

    local entry
    for entry in ${(s:,:)projects_paths}; do
        entry="${entry/#\~/${HOME}}"
        entry="${entry#"${entry%%[![:space:]]*}"}"
        entry="${entry%"${entry##*[![:space:]]}"}"

        if [[ "$entry" == *"*"* ]]; then
            local dir
            for dir in ${~entry}; do
                [[ -d "$dir" ]] && projects+=("${dir##*/}:$dir")
            done
        elif [[ -d "$entry" ]]; then
            projects+=("${entry##*/}:$entry")
        fi
    done

    _describe -t projects 'projects' projects
}

_gitx "$@"
