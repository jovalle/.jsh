#compdef jgit
# shellcheck shell=bash
# shellcheck disable=SC2207,SC2296,SC2034,SC2154,SC2206,SC2155,SC2128,SC1087
# Zsh completion for jgit - dynamically extracted from help output

# ============================================================================
# jgit - Zsh Completion (Dynamic)
# ============================================================================
# All completions are dynamically extracted from jgit help output
# to stay synchronized automatically
# ============================================================================

_jgit() {
    local curcontext="$curcontext" state line
    typeset -A opt_args

    local jgit_path="${JSH_DIR:-${HOME}/.jsh}/bin/jgit"

    _arguments -C \
        '(-h --help)'{-h,--help}'[Show help]' \
        '1: :->command' \
        '*::arg:->args'

    case $state in
        command)
            _jgit_commands
            ;;
        args)
            case $words[1] in
                profile)
                    _jgit_profile
                    ;;
                list|-l)
                    _jgit_list
                    ;;
                add)
                    _jgit_add
                    ;;
                create)
                    _jgit_create
                    ;;
                path)
                    _jgit_path
                    ;;
                update)
                    # No additional args
                    ;;
                *)
                    # Git passthrough - use git's own completion
                    _git
                    ;;
            esac
            ;;
    esac
}

# Dynamically extract main commands from jgit help output
_jgit_commands() {
    local -a commands
    local jgit_path="${JSH_DIR:-${HOME}/.jsh}/bin/jgit"

    if [[ -x "$jgit_path" ]]; then
        # Extract commands from COMMANDS section of help
        # Strip ANSI codes and parse indented command lines
        commands=(${(f)"$(
            "$jgit_path" --help 2>/dev/null | \
            perl -pe 's/\e\[[0-9;]*m//g' | \
            awk '
                /^COMMANDS:/ { in_section=1; next }
                /^[A-Z]/ { in_section=0 }
                in_section && /^  [a-z(<]/ {
                    line = $0
                    gsub(/^[ \t]+/, "", line)
                    # Handle (none) specially
                    if (line ~ /^\(none\)/) next
                    # Extract first word as command
                    cmd = line
                    sub(/[ \t].*/, "", cmd)
                    # Extract description (after spaces)
                    desc = line
                    sub(/^[^ \t]+[ \t]+/, "", desc)
                    if (cmd && desc) print cmd ":" desc
                }
            '
        )"})
    fi

    # Fallback if dynamic extraction fails
    if [[ ${#commands[@]} -eq 0 ]]; then
        commands=(
            'update:Safe pull with stash and rebase'
            'profile:Show or apply git profile'
            'add:Clone repository with smart SSH'
            'create:Create new project'
            'list:List all projects'
            'path:Output project path'
        )
    fi

    _describe -t commands 'jgit commands' commands
}

# Profile subcommands
_jgit_profile() {
    local -a subcommands
    subcommands=(
        'list:List all configured profiles'
        'status:Show current profile for this repo'
    )

    # Add dynamic profile names if config exists
    local jsh_profiles="${JSH_PROFILES:-${HOME}/.jsh/local/profiles.json}"
    if [[ -f "$jsh_profiles" ]] && command -v jq &>/dev/null; then
        local -a profiles
        profiles=(${(f)"$(jq -r '.profiles | keys | .[]' "$jsh_profiles" 2>/dev/null)"})
        for p in "${profiles[@]}"; do
            [[ -n "$p" ]] && subcommands+=("$p:Apply profile '$p' to current repo")
        done
    fi

    _describe -t subcommands 'profile subcommand' subcommands
}

# List command options
_jgit_list() {
    _arguments \
        '(-v --verbose)'{-v,--verbose}'[Show profile column]'
}

# Add command - complete git URLs
_jgit_add() {
    local curcontext="$curcontext" state line
    typeset -A opt_args

    _arguments -C \
        '1:git URL:_urls' \
        '2:local name:'
}

# Create command - complete project name
_jgit_create() {
    _arguments \
        '1:project name:'
}

# Path command - complete project names dynamically
_jgit_path() {
    local -a projects
    local projects_paths="${JSH_PROJECTS:-${HOME}/.jsh,${HOME}/projects/*}"

    # Expand paths and collect project names
    # Use zsh (s:,:) parameter expansion to split on commas
    local entry
    for entry in ${(s:,:)projects_paths}; do
        entry="${entry/#\~/${HOME}}"
        entry="${entry#"${entry%%[![:space:]]*}"}"
        entry="${entry%"${entry##*[![:space:]]}"}"

        if [[ "$entry" == *"*"* ]]; then
            local dir
            for dir in ${~entry}; do
                [[ -d "$dir" ]] && projects+=("${dir##*/}:$dir")
            done
        elif [[ -d "$entry" ]]; then
            projects+=("${entry##*/}:$entry")
        fi
    done

    _describe -t projects 'projects' projects
}

_jgit "$@"
