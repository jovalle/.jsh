#compdef jsh
# shellcheck shell=bash
# shellcheck disable=SC2207,SC2296,SC2034,SC2154,SC2206,SC2155,SC2128,SC1087
# Zsh completion for jsh - dynamically generated from @jsh-* metadata

_jsh() {
    local curcontext="$curcontext" state line
    typeset -A opt_args

    local jsh_complete="${JSH_DIR:-${HOME}/.jsh}/bin/jsh-complete"

    _arguments -C \
        '(-h --help)'{-h,--help}'[Show help]' \
        '(-v --version)'{-v,--version}'[Show version]' \
        '1: :->command' \
        '*::arg:->args'

    case $state in
        command)
            local -a commands
            if [[ -x "$jsh_complete" ]]; then
                commands=(${(f)"$("$jsh_complete" commands 2>/dev/null)"})
            fi
            _describe -t commands 'jsh commands' commands
            ;;
        args)
            local cmd="${words[1]}"
            local -a subcommands options

            if [[ -x "$jsh_complete" ]]; then
                # Get subcommands for this command
                subcommands=(${(f)"$("$jsh_complete" subcommands "$cmd" 2>/dev/null)"})

                # Get options for this command
                local -a opts_raw
                opts_raw=(${(f)"$("$jsh_complete" options "$cmd" 2>/dev/null)"})

                # Convert options to zsh _arguments format
                for opt_line in "${opts_raw[@]}"; do
                    [[ -z "$opt_line" ]] && continue
                    local opt_spec="${opt_line%%:*}"
                    local opt_desc="${opt_line#*:}"

                    if [[ "$opt_spec" == *","* ]]; then
                        # Format: -s,--long
                        local short="${opt_spec%%,*}"
                        local long="${opt_spec#*,}"
                        options+=("(${short} ${long})"{${short},${long}}"[${opt_desc}]")
                    else
                        # Format: --long only
                        options+=("${opt_spec}[${opt_desc}]")
                    fi
                done
            fi

            # Determine completion context
            if [[ ${#words[@]} -eq 2 ]]; then
                # After command, completing first arg (subcommand or option)
                if [[ ${#subcommands[@]} -gt 0 ]]; then
                    _describe -t subcommands "${cmd} subcommands" subcommands
                fi
                if [[ ${#options[@]} -gt 0 ]]; then
                    _arguments "${options[@]}"
                fi
            else
                # After subcommand, completing options
                if [[ ${#options[@]} -gt 0 ]]; then
                    _arguments "${options[@]}"
                fi
            fi

            # Handle special dynamic completions
            case "$cmd" in
                cli)
                    # CLI helper subcommands
                    if [[ ${#words[@]} -eq 2 ]]; then
                        local -a cli_commands
                        cli_commands=(
                            'discover:Find all scripts with @name metadata'
                            'completions:Generate shell completions for discovered scripts'
                            'help:Show help for a specific script'
                        )
                        _describe -t cli-commands 'cli commands' cli_commands
                    elif [[ ${#words[@]} -eq 3 ]] && [[ "${words[2]}" == "help" ]]; then
                        # Complete script names for 'jsh cli help <name>'
                        _jsh_cli_script_names
                    fi
                    ;;
                host)
                    if [[ "${words[2]}" =~ ^(status|refresh|reset)$ ]] && [[ ${#words[@]} -eq 3 ]]; then
                        _jsh_host_names
                    fi
                    ;;
                unlink)
                    if [[ "${words[-1]}" == "--restore="* ]] || [[ "${words[-2]}" == "--restore" ]]; then
                        _jsh_backup_names
                    fi
                    ;;
            esac
            ;;
    esac
}

# Dynamic completion: remote host names
_jsh_host_names() {
    local hosts_dir="${JSH_DIR:-${HOME}/.jsh}/local/hosts"
    local -a hosts

    if [[ -d "$hosts_dir" ]]; then
        hosts=(${(f)"$(find "$hosts_dir" -maxdepth 1 -name '*.json' 2>/dev/null | xargs -I {} basename {} .json)"})
    fi

    if [[ ${#hosts[@]} -gt 0 ]]; then
        _describe -t hosts 'remote hosts' hosts
    fi
}

# Dynamic completion: backup names
_jsh_backup_names() {
    local backup_dir="${HOME}/.jsh_backup"
    local -a backups

    backups=('latest:Restore from the most recent backup')

    if [[ -d "$backup_dir" ]]; then
        local -a backup_dirs
        backup_dirs=(${(f)"$(find "$backup_dir" -maxdepth 1 -type d -name '[0-9]*' 2>/dev/null | sort -r)"})

        for backup in "${backup_dirs[@]}"; do
            local backup_name=$(basename "$backup")
            backups+=("${backup_name}:Backup from ${backup_name}")
        done
    fi

    _describe -t backups 'available backups' backups
}

# Dynamic completion: CLI script names (for jsh cli help)
_jsh_cli_script_names() {
    local jsh_dir="${JSH_DIR:-${HOME}/.jsh}"
    local bin_dir="${jsh_dir}/bin"
    local -a scripts

    if [[ -d "$bin_dir" ]]; then
        # Find scripts with @name metadata
        for script in "$bin_dir"/*; do
            [[ -x "$script" ]] || continue
            local name
            name=$(head -50 "$script" 2>/dev/null | grep -m1 "^# @name " | sed 's/^# @name //')
            if [[ -n "$name" ]]; then
                local desc
                desc=$(head -50 "$script" 2>/dev/null | grep -m1 "^# @desc " | sed 's/^# @desc //')
                scripts+=("${name}:${desc:-No description}")
            fi
        done
    fi

    if [[ ${#scripts[@]} -gt 0 ]]; then
        _describe -t scripts 'available scripts' scripts
    fi
}

_jsh "$@"
