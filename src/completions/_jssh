#compdef jssh
# shellcheck shell=bash
# shellcheck disable=SC2207,SC2296,SC2034,SC2154,SC2206,SC2155,SC2128,SC1087
# SC2207: zsh array syntax differs from bash
# SC2296: zsh parameter expansion syntax
# SC2034: variables used by zsh completion system
# SC2154: variables provided by zsh completion system
# SC2206: word splitting is intentional for zsh arrays
# SC2155: declare and assign separately - acceptable in completions
# SC2128: zsh array subscripting syntax differs from bash
# SC1087: zsh uses $var[idx] not ${var[idx]}

# ============================================================================
# jssh - Zsh Completion
# ============================================================================
# Tab completion for jssh (SSH with portable Jsh environment)
# Extends ssh completion with jssh-specific options
# ============================================================================

_jssh() {
    local curcontext="$curcontext" state line
    typeset -A opt_args

    # Check if first argument is a jssh-specific flag
    if [[ $CURRENT -eq 2 ]]; then
        case "${words[2]}" in
            -h|--help|--check|--status|--rebuild)
                # These are terminal commands, no further completion
                return 0
                ;;
        esac
    fi

    # jssh-specific options + ssh passthrough
    _arguments -C \
        '(-h --help)'{-h,--help}'[Show help]' \
        '(--check --status)'{--check,--status}'[Validate jssh setup and show status]' \
        '--rebuild[Force rebuild of payload cache]' \
        '*::ssh args:_jssh_ssh_passthrough'
}

# SSH passthrough completion - use ssh's completion for remaining args
_jssh_ssh_passthrough() {
    local curcontext="$curcontext"

    # Check if we've already seen jssh-specific options
    # If not, we're completing SSH arguments
    local has_jssh_opt=0
    for word in "${words[@]}"; do
        case "$word" in
            --check|--status|--rebuild|--help|-h)
                has_jssh_opt=1
                break
                ;;
        esac
    done

    # If a jssh-specific flag was given, no further completion needed
    [[ $has_jssh_opt -eq 1 ]] && return 0

    # Otherwise, complete SSH options and hosts
    # Use _ssh_hosts for host completion, plus common SSH options
    _alternative \
        'hosts:remote host:_ssh_hosts' \
        'users:user@host:_ssh_users_hosts' \
        'options:ssh option:_jssh_ssh_options'
}

# Complete common SSH options (subset most relevant to jssh)
_jssh_ssh_options() {
    local -a ssh_opts
    ssh_opts=(
        '-p[Port to connect to]:port:_ports'
        '-i[Identity file]:identity file:_files'
        '-l[Login name]:login name:_ssh_users'
        '-o[SSH option]:option:_ssh_options'
        '-F[Config file]:config file:_files'
        '-J[Jump host]:jump host:_ssh_hosts'
        '-4[Force IPv4]'
        '-6[Force IPv6]'
        '-A[Enable agent forwarding]'
        '-C[Enable compression]'
        '-q[Quiet mode]'
        '-v[Verbose mode]'
        '-X[Enable X11 forwarding]'
        '-Y[Enable trusted X11 forwarding]'
        '-N[No remote command]'
        '-T[Disable pseudo-terminal]'
        '-t[Force pseudo-terminal]'
    )

    _arguments -s "${ssh_opts[@]}"
}

# Complete SSH hosts from known_hosts and ssh_config
_ssh_hosts() {
    local -a hosts
    local config_hosts known_hosts

    # From ssh_config
    if [[ -f ~/.ssh/config ]]; then
        config_hosts=(${(f)"$(awk '/^Host / && !/\*/ {print $2}' ~/.ssh/config 2>/dev/null)"})
        hosts+=("${config_hosts[@]}")
    fi

    # From known_hosts (without hashed entries)
    if [[ -f ~/.ssh/known_hosts ]]; then
        known_hosts=(${(f)"$(/usr/bin/cut -f1 -d' ' ~/.ssh/known_hosts 2>/dev/null | /usr/bin/tr ',' '\n' | /usr/bin/grep -v '^#' | /usr/bin/grep -v '^\[' | /usr/bin/grep -v '^|' | sort -u)"})
        hosts+=("${known_hosts[@]}")
    fi

    # Remove duplicates and describe
    local -a unique_hosts
    unique_hosts=(${(u)hosts[@]})

    _describe -t hosts 'remote host' unique_hosts
}

# Complete user@host combinations
_ssh_users_hosts() {
    local -a users hosts combinations

    # Common usernames
    users=(root admin ubuntu ec2-user centos debian)

    # Get current user
    users+=("$USER")

    # Get hosts
    local -a host_list
    if [[ -f ~/.ssh/config ]]; then
        host_list+=(${(f)"$(awk '/^Host / && !/\*/ {print $2}' ~/.ssh/config 2>/dev/null)"})
    fi

    # Build user@host combinations for current input
    local cur="${words[CURRENT]}"
    if [[ "$cur" == *@* ]]; then
        # User already typed user@, complete hosts
        local user="${cur%%@*}"
        for h in "${host_list[@]}"; do
            combinations+=("${user}@${h}")
        done
    fi

    [[ ${#combinations[@]} -gt 0 ]] && _describe -t combinations 'user@host' combinations
}

_jssh "$@"
