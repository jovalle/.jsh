#!/bin/bash

[[ -n $DEBUG ]] && set -x

set -eou pipefail
IFS=$'\n\t'

abort() { echo; echo "\033[31m$@\033[0m" 1>&2; exit 1 ; }
error() { echo -e "\033[31m$@\033[0m" ; }
warn() { echo -e "\033[33m$@\033[0m" ; }
success() { echo -e "\033[32m$@\033[0m" ; }
info() { echo -e "\033[34m$@\033[0m" ; }
usage() {
  error "Usage: git update|<git_command>"
  exit 1
}

get_repos() {
  repo=""
  if [ -n "${GIT_REPOS+x}" ] && [ -n "${GIT_REPOS}" ]; then
    if [ -n "${GIT_BASE}" ]; then
      repo="${GIT_BASE}/"
    fi
    # Extract repo names from URLs
    git_repos=()
    for url in "${GIT_REPOS[@]}"; do
      repo_name=$(basename "${url%%@*}" .git)
      git_repos+=("$repo_name")
    done
  else
    git_repos=( $(find . -maxdepth 2 -type d -name .git -prune -print | xargs -n1 dirname | grep -vE '^\.?$') )
    # Always include current directory if it is a git repo
    if [ -d .git ]; then
      git_repos=("$(pwd)" "${git_repos[@]}")
    fi
  fi
  for git_repo in ${git_repos[@]}; do
    echo "$git_repo"
  done
}

case "$1" in
  update)
    repos=($(get_repos))
    for repo in ${repos[@]}; do
      if [ -z "$repo" ]; then
        repo="$(pwd)"
        info "No repository path provided, using current directory: $repo"
      fi
      if [ -n "$GIT_BASE" ]; then
        if [ -d "$GIT_BASE/$repo/.git" ]; then
          info "Found repository at $GIT_BASE/$repo"
          repo="$GIT_BASE/$repo"
        elif [ -d "$GIT_BASE/$repo" ]; then
          info "Found repository at $GIT_BASE/$repo"
          repo="$GIT_BASE/$repo"
        fi
      fi
      if [ ! -d "$repo/.git" ]; then
        echo "No repository at $repo"
        exit 1
      fi

      pushd "$repo" >/dev/null || exit 1

      # Stash changes if any (including untracked)
      stash_applied=false
      if ! git diff --quiet || ! git diff --cached --quiet || [ -n "$(git ls-files --others --exclude-standard)" ]; then
        git stash push -u -m "Auto-stash before update $(date +%Y-%m-%dT%H:%M:%S)" || { popd >/dev/null; exit 1; }
        stash_applied=true
      fi

      # Checkout branch: prefer master, then main, then develop
      branch=""
      for b in master main develop; do
        if git show-ref --verify --quiet refs/heads/$b; then
          branch="$b"
          break
        fi
      done
      if [ -z "$branch" ]; then
        echo "No common upstream branch (master/main/develop) found."
        popd >/dev/null
        exit 1
      fi
      git checkout "$branch" || { popd >/dev/null; exit 1; }

      # Pull latest
      git pull || { popd >/dev/null; exit 1; }

      # Apply stash if it was created
      if [ "$stash_applied" = true ]; then
        git stash list | grep 'Auto-stash before update' >/dev/null && git stash pop
        if [ $? -ne 0 ]; then
          echo "Conflicts occurred when applying stash. Please resolve them manually."
        fi
      fi

      popd >/dev/null
    done
    ;;
  *)
    repos=($(get_repos))
    for repo in ${repos[@]}; do
      info "Processing repository: $repo"
      if [ ! -d "$repo/.git" ]; then
        warn "$repo is not a git repository, skipping."
        continue
      fi
      warn "git $@"
      pushd "$repo" >/dev/null || exit 1
      git "$@"
      popd >/dev/null || exit 1
    done
    ;;
esac
