#!/usr/bin/env bash
#
# kubectx(1) is a utility to manage and switch between kubectl contexts.

# Copyright 2017 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

[[ -n $DEBUG ]] && set -x

set -eou pipefail
IFS=$'\n\t'

SELF_CMD="$0"

KUBECTX="${XDG_CACHE_HOME:-$HOME/.kube}/kubectx"

usage() {
  local SELF
  SELF="kubectx"
  if [[ "$(basename "$0")" == kubectl-* ]]; then # invoked as plugin
    SELF="kubectl ctx"
  fi

  cat << EOF
USAGE:
  $SELF                        : list the contexts
  $SELF <NAME>                 : switch to context <NAME>
  $SELF -                      : switch to the previous context
  $SELF -a, --add <kubeconfig> : merge kubeconfig file into main config
  $SELF -c, --current          : show the current context name
  $SELF -d, --delete <NAME>    : delete context with cleanup (removes unused cluster/user)
  $SELF -u, --unset            : unset the current context
  $SELF <NEW_NAME>=.           : rename current-context to <NEW_NAME>
  $SELF <NEW_NAME>=<NAME>      : rename context <NAME> to <NEW_NAME>

  $SELF -h,--help              : show this message
EOF
}

exit_err() {
  echo >&2 "${1}"
  exit 1
}

current_context() {
  $KUBECTL config view -o=jsonpath='{.current-context}'
}

get_contexts() {
  $KUBECTL config get-contexts -o=name | sort -n
}

list_contexts() {
  set -u pipefail
  local cur ctx_list
  cur="$(current_context)" || exit_err "error getting current context"
  ctx_list=$(get_contexts) || exit_err "error getting context list"

  local yellow darkbg normal
  yellow=$(tput setaf 3 || true)
  darkbg=$(tput setab 0 || true)
  normal=$(tput sgr0 || true)

  local cur_ctx_fg cur_ctx_bg
  cur_ctx_fg=${KUBECTX_CURRENT_FGCOLOR:-$yellow}
  cur_ctx_bg=${KUBECTX_CURRENT_BGCOLOR:-$darkbg}

  for c in $ctx_list; do
    if [[ -n "${_KUBECTX_FORCE_COLOR:-}" ||
      -t 1 && -z "${NO_COLOR:-}" ]]; then
      # colored output mode
      if [[ "${c}" = "${cur}" ]]; then
        echo "${cur_ctx_bg}${cur_ctx_fg}${c}${normal}"
      else
        echo "${c}"
      fi
    else
      echo "${c}"
    fi
  done
}

read_context() {
  if [[ -f "${KUBECTX}" ]]; then
    cat "${KUBECTX}"
  fi
}

save_context() {
  local saved
  saved="$(read_context)"

  if [[ "${saved}" != "${1}" ]]; then
    printf %s "${1}" > "${KUBECTX}"
  fi
}

switch_context() {
  $KUBECTL config use-context "${1}"
}

choose_context_interactive() {
  local choice
  choice="$(_KUBECTX_FORCE_COLOR=1 \
    FZF_DEFAULT_COMMAND="${SELF_CMD}" \
    fzf --ansi --no-preview || true)"
  if [[ -z "${choice}" ]]; then
    echo 2>&1 "error: you did not choose any of the options"
    exit 1
  else
    set_context "${choice}"
  fi
}

set_context() {
  local prev
  prev="$(current_context)" || exit_err "error getting current context"

  switch_context "${1}"

  if [[ "${prev}" != "${1}" ]]; then
    save_context "${prev}"
  fi
}

swap_context() {
  local ctx
  ctx="$(read_context)"
  if [[ -z "${ctx}" ]]; then
    echo "error: No previous context found." >&2
    exit 1
  fi
  set_context "${ctx}"
}

context_exists() {
  grep -q ^"${1}"\$ <($KUBECTL config get-contexts -o=name)
}

rename_context() {
  local old_name="${1}"
  local new_name="${2}"

  if [[ "${old_name}" == "." ]]; then
    old_name="$(current_context)"
  fi

  if ! context_exists "${old_name}"; then
    echo "error: Context \"${old_name}\" not found, can't rename it." >&2
    exit 1
  fi

  if context_exists "${new_name}"; then
    echo "Context \"${new_name}\" exists, deleting..." >&2
    $KUBECTL config delete-context "${new_name}" 1> /dev/null 2>&1
  fi

  $KUBECTL config rename-context "${old_name}" "${new_name}"
}

choose_contexts_to_delete_interactive() {
  local choices
  choices="$(_KUBECTX_FORCE_COLOR=1 \
    FZF_DEFAULT_COMMAND="${SELF_CMD}" \
    fzf --ansi --no-preview --multi --prompt="Select contexts (⇧Tab=multi) to delete: " || true)"
  if [[ -z "${choices}" ]]; then
    echo 2>&1 "error: you did not choose any contexts to delete"
    exit 1
  else
    # Convert newline-separated choices to array
    local contexts_to_delete=()
    while IFS= read -r context; do
      contexts_to_delete+=("$context")
    done <<< "$choices"

    # Confirm deletion
    echo "You selected the following contexts for deletion:"
    for ctx in "${contexts_to_delete[@]}"; do
      echo "  - $ctx"
    done
    echo -n "Are you sure you want to delete these contexts? [y/N]: "
    read -r confirmation
    case $confirmation in
      [Yy] | [Yy][Ee][Ss])
        for ctx in "${contexts_to_delete[@]}"; do
          delete_context_with_cleanup "$ctx"
        done
        ;;
      *)
        echo "Deletion cancelled."
        exit 0
        ;;
    esac
  fi
}

unset_context() {
  echo "Unsetting current context." >&2
  $KUBECTL config unset current-context
}

# Source shared library for output helpers
# shellcheck source=../lib/common.sh
if [[ -f "${0%/*}/../lib/common.sh" ]]; then
  source "${0%/*}/../lib/common.sh"
elif [[ -f "${JSH_DIR:-$HOME/.jsh}/lib/common.sh" ]]; then
  source "${JSH_DIR:-$HOME/.jsh}/lib/common.sh"
else
  # Fallback definitions if common.sh not found
  info()    { echo -e "\033[0;34m·\033[0m $*" >&2; }
  success() { echo -e "\033[0;32m✓\033[0m $*" >&2; }
  error()   { echo -e "\033[0;31m✗\033[0m $*" >&2; }
  warn()    { echo -e "\033[0;33m!\033[0m $*" >&2; }
fi

# Add context from kubeconfig file (kctx+ functionality)
add_context() {
  local KUBECONFIG_SRC="$1"
  local KUBECONFIG_DST="$HOME/.kube/config"

  # Validate source kubeconfig
  KUBECONFIG="$KUBECONFIG_SRC" $KUBECTL config view --minify -o jsonpath='{.contexts[*].name}' &> /dev/null ||
    {
      error "Invalid kubeconfig ($KUBECONFIG_SRC)"
      return 1
    }

  # Ensure destination directory exists
  mkdir -p "$(dirname "$KUBECONFIG_DST")"

  # Create destination if it doesn't exist
  [[ ! -f "$KUBECONFIG_DST" ]] && touch "$KUBECONFIG_DST"

  # Get details from source
  local context_name
  context_name=$(KUBECONFIG="$KUBECONFIG_SRC" $KUBECTL config view --minify -o jsonpath='{.contexts[0].name}')
  local cluster_name
  cluster_name=$(KUBECONFIG="$KUBECONFIG_SRC" $KUBECTL config view --minify -o jsonpath='{.contexts[0].context.cluster}')
  local user_name
  user_name=$(KUBECONFIG="$KUBECONFIG_SRC" $KUBECTL config view --minify -o jsonpath='{.contexts[0].context.user}')

  [[ -z "$context_name" ]] && {
    error "No context found in source kubeconfig"
    return 1
  }

  info "Merging context: $context_name"

  # Extract details from source
  local server
  server=$(KUBECONFIG="$KUBECONFIG_SRC" $KUBECTL config view --minify -o jsonpath='{.clusters[0].cluster.server}')
  local server_host
  server_host=$(echo "$server" | sed -E 's|https?://([^:/]+).*|\1|')

  # Use the authinfo as-is if it already contains server/user format, otherwise create it
  local authinfo="$user_name"
  local unique_authinfo
  if [[ "$authinfo" == *"/"* ]]; then
    # Already in server/user format, use as-is
    unique_authinfo="$authinfo"
  else
    # Create server/user format
    unique_authinfo="${server_host}/${user_name}"
  fi

  info "Using authinfo: $unique_authinfo"

  # Remove existing context/cluster/authinfo if they exist (update case)
  $KUBECTL config delete-context "$context_name" &> /dev/null || true
  $KUBECTL config delete-cluster "$cluster_name" &> /dev/null || true
  $KUBECTL config delete-user "$unique_authinfo" &> /dev/null || true

  # Create temp files for certificate data
  local ca_tmp
  ca_tmp=$(mktemp)
  local cert_tmp
  cert_tmp=$(mktemp)
  local key_tmp
  key_tmp=$(mktemp)

  # Extract and write CA certificate
  KUBECONFIG="$KUBECONFIG_SRC" $KUBECTL config view --raw -o jsonpath='{.clusters[0].cluster.certificate-authority-data}' | base64 -d > "$ca_tmp"

  # Add cluster with CA file
  $KUBECTL config set-cluster "$cluster_name" --server="$server" --certificate-authority="$ca_tmp" --embed-certs=true

  # Extract and write user credentials
  local user_cert
  user_cert=$(KUBECONFIG="$KUBECONFIG_SRC" $KUBECTL config view --raw -o jsonpath='{.users[0].user.client-certificate-data}')
  local user_key
  user_key=$(KUBECONFIG="$KUBECONFIG_SRC" $KUBECTL config view --raw -o jsonpath='{.users[0].user.client-key-data}')

  if [[ -n "$user_cert" && -n "$user_key" ]]; then
    echo "$user_cert" | base64 -d > "$cert_tmp"
    echo "$user_key" | base64 -d > "$key_tmp"
    $KUBECTL config set-credentials "$unique_authinfo" --client-certificate="$cert_tmp" --client-key="$key_tmp" --embed-certs=true
  else
    # Try token-based auth
    local token
    token=$(KUBECONFIG="$KUBECONFIG_SRC" $KUBECTL config view --raw -o jsonpath='{.users[0].user.token}')
    if [[ -n "$token" ]]; then
      $KUBECTL config set-credentials "$unique_authinfo" --token="$token"
    else
      error "No valid credentials found in source kubeconfig"
      rm -f "$ca_tmp" "$cert_tmp" "$key_tmp"
      return 1
    fi
  fi

  # Clean up temp files
  rm -f "$ca_tmp" "$cert_tmp" "$key_tmp"

  # Create context
  $KUBECTL config set-context "$context_name" --cluster="$cluster_name" --user="$unique_authinfo"

  # Switch to the new context
  $KUBECTL config use-context "$context_name" &> /dev/null &&
    success "Context '$context_name' merged and activated"
}

# Delete context with cleanup (kctx- functionality)
delete_context_with_cleanup() {
  local context="$1"
  local KUBECONFIG_DST="$HOME/.kube/config"

  # Get cluster and user associated with this context
  local cluster
  cluster=$($KUBECTL config view -o jsonpath="{.contexts[?(@.name==\"$context\")].context.cluster}")
  local user
  user=$($KUBECTL config view -o jsonpath="{.contexts[?(@.name==\"$context\")].context.user}")

  # Delete the context
  $KUBECTL config delete-context "$context" &> /dev/null &&
    info "Context '$context' removed"

  # Check if cluster/user are still referenced by other contexts
  local cluster_refs
  cluster_refs=$($KUBECTL config view -o jsonpath="{.contexts[*].context.cluster}" | grep -c "$cluster" || true)
  local user_refs
  user_refs=$($KUBECTL config view -o jsonpath="{.contexts[*].context.user}" | grep -c "$user" || true)

  # Clean up orphaned clusters and users
  [[ $cluster_refs -eq 0 && -n "$cluster" ]] &&
    $KUBECTL config delete-cluster "$cluster" &> /dev/null &&
    info "Cluster '$cluster' removed (no longer referenced)"

  [[ $user_refs -eq 0 && -n "$user" ]] &&
    $KUBECTL config delete-user "$user" &> /dev/null &&
    info "User '$user' removed (no longer referenced)"

  success "Cleanup complete"
}

main() {
  if [[ -z "${KUBECTL:-}" ]]; then
    if hash kubectl 2> /dev/null; then
      KUBECTL=kubectl
    elif hash kubectl.exe 2> /dev/null; then
      KUBECTL=kubectl.exe
    else
      echo >&2 "kubectl is not installed"
      exit 1
    fi
  fi

  if [[ "$#" -eq 0 ]]; then
    if [[ -t 1 && -z "${KUBECTX_IGNORE_FZF:-}" && "$(
      type fzf &> /dev/null
      echo $?
    )" -eq 0 ]]; then
      choose_context_interactive
    else
      list_contexts
    fi
  elif [[ "${1}" == "-a" || "${1}" == "--add" ]]; then
    if [[ "$#" -lt 2 ]]; then
      echo "error: missing kubeconfig file path" >&2
      echo "Usage: kubectx --add <kubeconfig>" >&2
      exit 1
    fi
    add_context "${2}"
  elif [[ "${1}" == "-d" || "${1}" == "--delete" ]]; then
    if [[ "$#" -lt 2 ]]; then
      # No specific contexts provided, use interactive selection
      if [[ -t 1 && -z "${KUBECTX_IGNORE_FZF:-}" && "$(
        type fzf &> /dev/null
        echo $?
      )" -eq 0 ]]; then
        choose_contexts_to_delete_interactive
      else
        echo "error: missing context NAME and fzf is not available for interactive selection" >&2
        usage
        exit 1
      fi
    else
      delete_context_with_cleanup "${2}"
    fi
  elif [[ "$#" -gt 1 ]]; then
    echo "error: too many arguments" >&2
    usage
    exit 1
  elif [[ "$#" -eq 1 ]]; then
    if [[ "${1}" == "-" ]]; then
      swap_context
    elif [[ "${1}" == '-c' || "${1}" == '--current' ]]; then
      # we don't call current_context here for two reasons:
      # - it does not fail when current-context property is not set
      # - it does not return a trailing newline
      kubectl config current-context
    elif [[ "${1}" == '-u' || "${1}" == '--unset' ]]; then
      unset_context
    elif [[ "${1}" == '-h' || "${1}" == '--help' ]]; then
      usage
    elif [[ "${1}" =~ ^-(.*) ]]; then
      echo "error: unrecognized flag \"${1}\"" >&2
      usage
      exit 1
    elif [[ "${1}" =~ (.+)=(.+) ]]; then
      rename_context "${BASH_REMATCH[2]}" "${BASH_REMATCH[1]}"
    else
      set_context "${1}"
    fi
  else
    usage
    exit 1
  fi
}

main "$@"
