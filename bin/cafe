#!/usr/bin/env bash
# @name cafe
# @version 1.0.0
# @desc Prevent system sleep and idle (keep your system awake)
# @usage cafe [options] [command...]
#
# @option -t,--time <DURATION>  Keep awake for duration (e.g., 1h, 30m, 3600)
# @option -d,--display          Also prevent display from sleeping
# @option -i,--idle             Only prevent idle sleep (allow user-initiated)
# @option -s,--system           Also prevent system sleep
# @option -b,--background       Run in background (daemonize)
# @option -r,--reason <TEXT>    Reason for inhibiting (shown in system UI)
# @option --status              Show if cafe is currently running
# @option --stop                Stop background cafe instance
# @option -v,--verbose          Enable verbose output
# @option -h,--help             Show this help message
# @option --version             Show version information
#
# @example cafe
# @example cafe -t 2h
# @example cafe -d make -j8
# @example cafe -b -d -t 4h
#
# shellcheck shell=bash
#
# Cross-platform utility to keep your system awake during long-running tasks.
# Works on macOS (caffeinate), Linux (systemd-inhibit, gnome-session-inhibit,
# xdg-screensaver), and falls back to keeping a process running.
#
# "Un cafe para mantener el sistema despierto"

set -euo pipefail

# =============================================================================
# Configuration
# =============================================================================

readonly SCRIPT_NAME="${0##*/}"

# Default duration (seconds) - 0 means indefinite
CAFE_DURATION="${CAFE_DURATION:-0}"

# Default inhibit reasons
CAFE_REASON="${CAFE_REASON:-User requested via cafe command}"

# PID file for background mode
readonly CAFE_PID_FILE="${XDG_RUNTIME_DIR:-/tmp}/cafe.${USER:-$(id -un)}.pid"

# =============================================================================
# Dependencies
# =============================================================================

# Source CLI framework (provides help generation and colors)
source "${0%/*}/../lib/cli.sh" 2>/dev/null || source "${JSH_DIR:-$HOME/.jsh}/lib/cli.sh"

# Override debug with script-specific env var
debug() { [[ "${CAFE_DEBUG:-0}" == "1" ]] && _debug "$@" || true; }

# =============================================================================
# Utilities
# =============================================================================

# Parse duration string to seconds
parse_duration() {
    local input="$1"
    local total=0

    # If it's just a number, assume seconds
    if [[ "${input}" =~ ^[0-9]+$ ]]; then
        printf '%s' "${input}"
        return 0
    fi

    # Parse combined format like "1h30m"
    local remaining="${input}"

    # Hours
    if [[ "${remaining}" =~ ([0-9]+)h(ours?|r)? ]]; then
        total=$((total + BASH_REMATCH[1] * 3600))
        remaining="${remaining/${BASH_REMATCH[0]}/}"
    fi

    # Minutes
    if [[ "${remaining}" =~ ([0-9]+)m(in(utes?)?)? ]]; then
        total=$((total + BASH_REMATCH[1] * 60))
        remaining="${remaining/${BASH_REMATCH[0]}/}"
    fi

    # Seconds
    if [[ "${remaining}" =~ ([0-9]+)s(ec(onds?)?)? ]]; then
        total=$((total + BASH_REMATCH[1]))
    fi

    if [[ "${total}" -eq 0 ]]; then
        die "Invalid duration format: ${input}\nExamples: 3600, 30m, 2h, 1h30m"
    fi

    printf '%s' "${total}"
}

# Format seconds to human-readable
format_duration() {
    local seconds="$1"
    local hours=$((seconds / 3600))
    local minutes=$(( (seconds % 3600) / 60 ))
    local secs=$((seconds % 60))

    if [[ "${hours}" -gt 0 ]]; then
        printf '%dh%02dm%02ds' "${hours}" "${minutes}" "${secs}"
    elif [[ "${minutes}" -gt 0 ]]; then
        printf '%dm%02ds' "${minutes}" "${secs}"
    else
        printf '%ds' "${secs}"
    fi
}

# Check if background cafe is running
is_running() {
    if [[ -f "${CAFE_PID_FILE}" ]]; then
        local pid
        pid=$(cat "${CAFE_PID_FILE}" 2>/dev/null || true)
        if [[ -n "${pid}" ]] && kill -0 "${pid}" 2>/dev/null; then
            return 0
        fi
        # Stale PID file
        rm -f "${CAFE_PID_FILE}"
    fi
    return 1
}

# Show status
show_status() {
    if is_running; then
        local pid
        pid=$(cat "${CAFE_PID_FILE}")
        success "Cafe is running (PID: ${pid})"

        # Try to show remaining time on macOS
        if [[ "$(uname -s)" == "Darwin" ]]; then
            local start elapsed
            if stat -f %m "${CAFE_PID_FILE}" &>/dev/null; then
                start=$(stat -f %m "${CAFE_PID_FILE}")
                elapsed=$(($(date +%s) - start))
                printf "%sRunning for: %s%s\n" "${C_DIM}" "$(format_duration "${elapsed}")" "${C_RESET}"
            fi
        fi
        return 0
    else
        info "Cafe is not running"
        return 1
    fi
}

# Stop background cafe
stop_cafe() {
    if [[ -f "${CAFE_PID_FILE}" ]]; then
        local pid
        pid=$(cat "${CAFE_PID_FILE}" 2>/dev/null || true)
        if [[ -n "${pid}" ]]; then
            if kill -0 "${pid}" 2>/dev/null; then
                kill "${pid}" 2>/dev/null || true
                # Wait briefly for clean shutdown
                sleep 0.5
                # Force kill if still running
                kill -9 "${pid}" 2>/dev/null || true
                success "Stopped cafe (PID: ${pid})"
            fi
        fi
        rm -f "${CAFE_PID_FILE}"
    else
        info "No background cafe found"
    fi
}

# =============================================================================
# Inhibit Implementations
# =============================================================================

# macOS caffeinate
run_caffeinate() {
    local duration="$1"
    local display="$2"
    local system="$3"
    shift 3
    local cmd=("$@")

    local args=()

    # -i: prevent idle sleep
    args+=(-i)

    # -d: prevent display sleep
    [[ "${display}" == "true" ]] && args+=(-d)

    # -s: prevent system sleep
    [[ "${system}" == "true" ]] && args+=(-s)

    # -t: timeout
    if [[ "${duration}" -gt 0 ]]; then
        args+=(-t "${duration}")
    fi

    # -w: wait for process (when wrapping a command)
    if [[ ${#cmd[@]} -gt 0 ]]; then
        debug "Running: caffeinate ${args[*]} -- ${cmd[*]}"
        caffeinate "${args[@]}" -- "${cmd[@]}"
    else
        debug "Running: caffeinate ${args[*]}"
        caffeinate "${args[@]}"
    fi
}

# Linux systemd-inhibit
# Returns 0 on success, 1 on failure (allows cascade to next method)
run_systemd_inhibit() {
    local duration="$1"
    local display="$2"
    local system="$3"
    local reason="$4"
    shift 4
    local cmd=("$@")

    # Build sleep command for when no user command is provided
    local sleep_cmd
    if [[ "${duration}" -gt 0 ]]; then
        sleep_cmd="sleep ${duration}"
    else
        sleep_cmd="sleep infinity"
    fi

    # Build list of --what values to try (most to least restrictive)
    # Different inhibit types have different permission requirements:
    #   idle  - prevent screensaver (usually allowed for regular users)
    #   sleep - prevent suspend (often requires elevated permissions)
    local what_variants=()
    local base_what="idle:sleep"
    [[ "${display}" == "true" ]] && base_what="${base_what}:handle-lid-switch"
    what_variants+=("${base_what}")
    what_variants+=("idle")  # Fallback: just idle (most permissive)

    # Try each --what variant
    local what
    for what in "${what_variants[@]}"; do
        # For each --what, try block mode then delay mode
        local mode
        for mode in block delay; do
            local args=(
                --what="${what}"
                --who="${SCRIPT_NAME}"
                --why="${reason}"
                --mode="${mode}"
            )

            if [[ ${#cmd[@]} -gt 0 ]]; then
                debug "Trying: systemd-inhibit --what=${what} --mode=${mode}"
                if systemd-inhibit "${args[@]}" -- "${cmd[@]}" 2>/dev/null; then
                    return 0
                fi
            else
                debug "Trying: systemd-inhibit --what=${what} --mode=${mode}"
                # shellcheck disable=SC2086
                if systemd-inhibit "${args[@]}" -- ${sleep_cmd} 2>/dev/null; then
                    return 0
                fi
            fi
        done
        debug "--what=${what} failed, trying simpler variant..."
    done

    # All variants failed - return failure to try next method
    debug "systemd-inhibit failed (likely no session or permissions)"
    return 1
}

# Linux gnome-session-inhibit
# Returns 0 on success, 1 on failure (allows cascade to next method)
run_gnome_inhibit() {
    local duration="$1"
    local display="$2"
    local system="$3"
    local reason="$4"
    shift 4
    local cmd=("$@")

    local what="idle:suspend"
    [[ "${display}" == "true" ]] && what="${what}:idle"

    local args=(
        --app-id="${SCRIPT_NAME}"
        --reason="${reason}"
        --inhibit="${what}"
    )

    if [[ ${#cmd[@]} -gt 0 ]]; then
        debug "Trying: gnome-session-inhibit ${args[*]} -- ${cmd[*]}"
        if gnome-session-inhibit "${args[@]}" -- "${cmd[@]}" 2>/dev/null; then
            return 0
        fi
    else
        local sleep_cmd
        if [[ "${duration}" -gt 0 ]]; then
            sleep_cmd="sleep ${duration}"
        else
            sleep_cmd="sleep infinity"
        fi
        debug "Trying: gnome-session-inhibit ${args[*]} -- ${sleep_cmd}"
        # shellcheck disable=SC2086
        if gnome-session-inhibit "${args[@]}" -- ${sleep_cmd} 2>/dev/null; then
            return 0
        fi
    fi

    debug "gnome-session-inhibit failed"
    return 1
}

# X11 xdg-screensaver fallback
# Returns 0 on success, 1 on failure (allows cascade to next method)
run_xdg_inhibit() {
    local duration="$1"
    shift 4  # Skip duration, display, system, reason
    local cmd=("$@")

    # Requires X11 display
    if [[ -z "${DISPLAY:-}" ]]; then
        debug "xdg-screensaver requires DISPLAY (no X11 session)"
        return 1
    fi

    # Get a window ID (use root window if none)
    local window_id
    if command -v xdotool &>/dev/null; then
        window_id=$(xdotool getactivewindow 2>/dev/null || echo "root")
    else
        window_id="root"
    fi

    # Test if xdg-screensaver actually works
    if ! xdg-screensaver suspend "${window_id}" 2>/dev/null; then
        debug "xdg-screensaver suspend failed"
        return 1
    fi

    debug "xdg-screensaver inhibit active"

    # Cleanup on exit
    cleanup() {
        xdg-screensaver resume "${window_id}" 2>/dev/null || true
    }
    trap cleanup EXIT

    if [[ ${#cmd[@]} -gt 0 ]]; then
        "${cmd[@]}"
    else
        if [[ "${duration}" -gt 0 ]]; then
            sleep "${duration}"
        else
            sleep infinity
        fi
    fi
    return 0
}

# Fallback: just keep running (always succeeds - last resort)
run_fallback() {
    local duration="$1"
    shift 4  # Skip duration, display, system, reason
    local cmd=("$@")

    warn "No system inhibit method available, using fallback"
    info "System may still sleep - consider installing systemd-inhibit"

    if [[ ${#cmd[@]} -gt 0 ]]; then
        "${cmd[@]}"
    else
        if [[ "${duration}" -gt 0 ]]; then
            info "Keeping awake for $(format_duration "${duration}")..."
            sleep "${duration}"
        else
            info "Keeping awake indefinitely (Ctrl+C to stop)..."
            while true; do
                sleep 60
            done
        fi
    fi
    return 0
}

# =============================================================================
# Cascading Inhibit Runner
# =============================================================================

# Try each inhibit method in sequence until one succeeds
# This handles cases where a tool exists but fails (e.g., permissions)
run_inhibit() {
    local duration="$1"
    local display="$2"
    local system="$3"
    local reason="$4"
    shift 4
    local cmd=("$@")

    local methods=()
    local method

    # Build list of available methods based on platform
    case "$(uname -s)" in
        Darwin)
            command -v caffeinate &>/dev/null && methods+=(caffeinate)
            ;;
        Linux)
            command -v systemd-inhibit &>/dev/null && methods+=(systemd-inhibit)
            command -v gnome-session-inhibit &>/dev/null && methods+=(gnome-session-inhibit)
            command -v xdg-screensaver &>/dev/null && methods+=(xdg-screensaver)
            ;;
    esac

    # Always have fallback as last resort
    methods+=(fallback)

    # Try each method until one succeeds
    for method in "${methods[@]}"; do
        debug "Trying inhibit method: ${method}"

        case "${method}" in
            caffeinate)
                if run_caffeinate "${duration}" "${display}" "${system}" "${cmd[@]}"; then
                    return 0
                fi
                ;;
            systemd-inhibit)
                if run_systemd_inhibit "${duration}" "${display}" "${system}" "${reason}" "${cmd[@]}"; then
                    return 0
                fi
                ;;
            gnome-session-inhibit)
                if run_gnome_inhibit "${duration}" "${display}" "${system}" "${reason}" "${cmd[@]}"; then
                    return 0
                fi
                ;;
            xdg-screensaver)
                if run_xdg_inhibit "${duration}" "${display}" "${system}" "${reason}" "${cmd[@]}"; then
                    return 0
                fi
                ;;
            fallback)
                # Fallback always succeeds
                run_fallback "${duration}" "${display}" "${system}" "${reason}" "${cmd[@]}"
                return 0
                ;;
        esac

        debug "${method} failed, trying next method..."
    done

    return 0
}

# Get the first available method name (for display purposes)
get_primary_method() {
    case "$(uname -s)" in
        Darwin)
            command -v caffeinate &>/dev/null && { printf 'caffeinate'; return; }
            ;;
        Linux)
            command -v systemd-inhibit &>/dev/null && { printf 'systemd-inhibit'; return; }
            command -v gnome-session-inhibit &>/dev/null && { printf 'gnome-session-inhibit'; return; }
            command -v xdg-screensaver &>/dev/null && { printf 'xdg-screensaver'; return; }
            ;;
    esac
    printf 'fallback'
}

# =============================================================================
# Main
# =============================================================================

main() {
    local duration="${CAFE_DURATION}"
    local display=false
    local system=false
    local background=false
    local reason="${CAFE_REASON}"
    local verbose=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                cli_help
                exit 0
                ;;
            --version)
                cli_version
                exit 0
                ;;
            --status)
                show_status
                exit $?
                ;;
            --stop)
                stop_cafe
                exit 0
                ;;
            -t|--time)
                [[ $# -lt 2 ]] && die "Option $1 requires an argument"
                duration=$(parse_duration "$2")
                shift 2
                ;;
            -d|--display)
                display=true
                shift
                ;;
            -i|--idle)
                # Idle-only is the default behavior, this is a no-op for compatibility
                shift
                ;;
            -s|--system)
                system=true
                shift
                ;;
            -b|--background)
                background=true
                shift
                ;;
            -r|--reason)
                [[ $# -lt 2 ]] && die "Option $1 requires an argument"
                reason="$2"
                shift 2
                ;;
            -v|--verbose)
                verbose=true
                CAFE_DEBUG=1
                export CAFE_DEBUG
                shift
                ;;
            --)
                shift
                break
                ;;
            -*)
                die "Unknown option: $1 (use --help for usage)"
                ;;
            *)
                break
                ;;
        esac
    done

    # Remaining args are the command to wrap
    local cmd=("$@")

    # Get primary method name (for display - actual method may cascade)
    local method
    method=$(get_primary_method)
    debug "Primary inhibit method: ${method} (will cascade on failure)"

    # Check for existing background process
    if [[ "${background}" == "true" ]]; then
        if is_running; then
            warn "Cafe is already running in background"
            show_status
            exit 0
        fi
    fi

    # Show what we're doing
    if [[ "${verbose}" == "true" || "${background}" != "true" ]]; then
        if [[ ${#cmd[@]} -gt 0 ]]; then
            info "Running command with sleep inhibited..."
        elif [[ "${duration}" -gt 0 ]]; then
            info "Keeping awake for $(format_duration "${duration}")..."
        else
            info "Keeping awake indefinitely (Ctrl+C to stop)..."
        fi
        printf "%sMethod: %s (auto) | Display: %s | System: %s%s\n" \
            "${C_DIM}" "${method}" "${display}" "${system}" "${C_RESET}"
    fi

    # Background mode
    if [[ "${background}" == "true" ]]; then
        (
            # Daemonize
            cd /
            exec > /dev/null 2>&1
            exec < /dev/null

            # Run inhibit with automatic cascade on failure
            run_inhibit "${duration}" "${display}" "${system}" "${reason}" "${cmd[@]}"
        ) &

        local bg_pid=$!
        printf '%s' "${bg_pid}" > "${CAFE_PID_FILE}"
        success "Started in background (PID: ${bg_pid})"
        printf "%sUse '%s --stop' to stop%s\n" "${C_DIM}" "${SCRIPT_NAME}" "${C_RESET}"
        exit 0
    fi

    # Foreground mode - use cascading inhibit
    run_inhibit "${duration}" "${display}" "${system}" "${reason}" "${cmd[@]}"
}

# Handle interrupts gracefully
trap 'printf "\n%sStopped%s\n" "${C_DIM}" "${C_RESET}"; exit 130' INT TERM

main "$@"
