#!/usr/bin/env bash

# ============================================================================
# jsh
# ============================================================================
# A comprehensive command-line interface for managing the jsh project.
# ============================================================================

set -e

# ==============================================================================
# Configuration & Variables
# ==============================================================================

# Resolve the true path of the script to find the repository root
SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SOURCE" ]; do
  DIR="$(cd -P "$(dirname "$SOURCE")" > /dev/null 2>&1 && pwd)"
  SOURCE="$(readlink "$SOURCE")"
  [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE"
done
SCRIPT_DIR="$(cd -P "$(dirname "$SOURCE")" > /dev/null 2>&1 && pwd)"

# If script is in bin, root is 1 level up
if [[ "$SCRIPT_DIR" == *"bin" ]]; then
  ROOT_DIR="$(dirname "$SCRIPT_DIR")"
else
  ROOT_DIR="$SCRIPT_DIR"
fi

OS="$(uname -s)"

# Load .env if it exists
if [[ -f "$ROOT_DIR/.env" ]]; then
  source "$ROOT_DIR/.env"
fi

# ==============================================================================
# Package Management - Load from JSON files
# ==============================================================================

# Helper function to load packages from JSON file into an array
# Compatible with Bash 3.2+ (macOS default) - avoids mapfile which requires Bash 4+
load_packages_from_json() {
  local json_file="$1"
  if [[ ! -f "$json_file" ]]; then
    return 1
  fi

  # Parse JSON array and output each item on a separate line
  if command -v jq &> /dev/null; then
    jq -r '.[]' "$json_file" 2> /dev/null
  else
    # Fallback: simple grep-based parsing for JSON arrays
    grep -o '"[^"]*"' "$json_file" | tr -d '"'
  fi
}

# Load package arrays from JSON files using a while loop (Bash 3.2 compatible)
CASKS=()
while IFS= read -r line; do
  [[ -n "$line" ]] && CASKS+=("$line")
done < <(load_packages_from_json "$ROOT_DIR/configs/macos/casks.json")

FORMULAE_MACOS=()
while IFS= read -r line; do
  [[ -n "$line" ]] && FORMULAE_MACOS+=("$line")
done < <(load_packages_from_json "$ROOT_DIR/configs/macos/formulae.json")

FORMULAE_LINUX=()
while IFS= read -r line; do
  [[ -n "$line" ]] && FORMULAE_LINUX+=("$line")
done < <(load_packages_from_json "$ROOT_DIR/configs/linux/formulae.json")

# Linux package managers (apt, dnf, pacman, etc.)
PACKAGES_APT=()
while IFS= read -r line; do
  [[ -n "$line" ]] && PACKAGES_APT+=("$line")
done < <(load_packages_from_json "$ROOT_DIR/configs/linux/apt.json")

PACKAGES_DNF=()
while IFS= read -r line; do
  [[ -n "$line" ]] && PACKAGES_DNF+=("$line")
done < <(load_packages_from_json "$ROOT_DIR/configs/linux/dnf.json")

PACKAGES_PACMAN=()
while IFS= read -r line; do
  [[ -n "$line" ]] && PACKAGES_PACMAN+=("$line")
done < <(load_packages_from_json "$ROOT_DIR/configs/linux/pacman.json")

PACKAGES_YUM=()
while IFS= read -r line; do
  [[ -n "$line" ]] && PACKAGES_YUM+=("$line")
done < <(load_packages_from_json "$ROOT_DIR/configs/linux/yum.json")

PACKAGES_APK=()
while IFS= read -r line; do
  [[ -n "$line" ]] && PACKAGES_APK+=("$line")
done < <(load_packages_from_json "$ROOT_DIR/configs/linux/apk.json")

PACKAGES_ZYPPER=()
while IFS= read -r line; do
  [[ -n "$line" ]] && PACKAGES_ZYPPER+=("$line")
done < <(load_packages_from_json "$ROOT_DIR/configs/linux/zypper.json")

# --- Brew Services ---
SERVICES=(
  syncthing
)

# --- Brew Links ---
LINKS=(
  mpv
  tlrc
)

# ==============================================================================
# Helper Functions
# ==============================================================================

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
BOLD='\033[1m'
RESET='\033[0m'

log() { echo -e "${BLUE}üîπ $1${RESET}"; }
info() { echo -e "${CYAN}‚ÑπÔ∏è  $1${RESET}"; }
warn() { echo -e "${YELLOW}‚ö†Ô∏è  $1${RESET}"; }
error() {
  echo -e "${RED}‚ùå $1${RESET}"
  exit 1
}
success() { echo -e "${GREEN}‚úÖ $1${RESET}"; }
header() { echo -e "\n${BOLD}${BLUE}‚ñ∂ $1${RESET}\n"; }

confirm() {
  local prompt="$1"
  local response
  read -n 1 -r -p "${prompt} (y/N): " response
  echo # Print newline after single character input
  case "$response" in
    y | Y) return 0 ;;
    *) return 1 ;; # Default is No (empty/Enter counts as No)
  esac
}

cmd_exists() { command -v "$1" &> /dev/null; }

is_macos() { [[ "$OS" == "Darwin" ]]; }
is_linux() { [[ "$OS" == "Linux" ]]; }
is_wsl() { grep -qi microsoft /proc/version 2> /dev/null; }

# Get the user's login shell
get_user_shell() {
  local user_shell
  if is_macos; then
    user_shell=$(dscl . -read ~/ UserShell 2> /dev/null | awk '{print $2}')
  else
    user_shell=$(getent passwd "$(whoami)" 2> /dev/null | cut -d: -f7)
  fi
  echo "$user_shell"
}

# Install packages using the appropriate package manager
install_package() {
  local package="$1"

  if is_macos; then
    if command -v brew &> /dev/null; then
      brew install "$package"
    else
      warn "No package manager available on macOS"
      return 1
    fi
  elif is_linux; then
    if command -v apt-get &> /dev/null; then
      sudo apt-get install -y "$package"
    elif command -v dnf &> /dev/null; then
      sudo dnf install -y "$package"
    elif command -v yum &> /dev/null; then
      sudo yum install -y "$package"
    elif command -v pacman &> /dev/null; then
      sudo pacman -S --noconfirm "$package"
    elif command -v apk &> /dev/null; then
      sudo apk add "$package"
    elif command -v zypper &> /dev/null; then
      sudo zypper install -y "$package"
    else
      warn "No supported package manager found"
      return 1
    fi
  else
    warn "Unsupported operating system"
    return 1
  fi
}

# Update package manager cache
update_package_cache() {
  if is_linux; then
    if command -v apt-get &> /dev/null; then
      sudo apt-get update
    elif command -v dnf &> /dev/null; then
      sudo dnf check-update || true
    elif command -v yum &> /dev/null; then
      sudo yum check-update || true
    elif command -v pacman &> /dev/null; then
      sudo pacman -Sy
    elif command -v apk &> /dev/null; then
      sudo apk update
    elif command -v zypper &> /dev/null; then
      sudo zypper refresh
    fi
  fi
}

# Upgrade all packages
upgrade_packages() {
  if is_macos; then
    if command -v brew &> /dev/null; then
      brew update && brew upgrade
    fi
  elif is_linux; then
    if command -v apt-get &> /dev/null; then
      sudo apt-get update && sudo apt-get upgrade -y
    elif command -v dnf &> /dev/null; then
      sudo dnf upgrade -y
    elif command -v yum &> /dev/null; then
      sudo yum update -y
    elif command -v pacman &> /dev/null; then
      sudo pacman -Syu --noconfirm
    elif command -v apk &> /dev/null; then
      sudo apk upgrade
    elif command -v zypper &> /dev/null; then
      sudo zypper update -y
    fi
  fi
}

check_brew() {
  if ! command -v brew &> /dev/null; then
    warn "Homebrew not found. Skipping brew-related tasks."
    return 1
  fi
  return 0
}

apply_brew_shellenv() {
  local brew_bin="$1"
  [[ -n "$brew_bin" && -x "$brew_bin" ]] || return 1

  local brew_env
  if brew_env="$("$brew_bin" shellenv)"; then
    eval "$brew_env"
    return 0
  fi

  return 1
}

ensure_brew() {
  if command -v brew &> /dev/null; then
    return 0
  fi

  log "Checking for existing Homebrew installation..."
  local brew_candidates=(
    "/opt/homebrew/bin/brew"
    "/usr/local/bin/brew"
    "/home/linuxbrew/.linuxbrew/bin/brew"
    "${HOME}/.linuxbrew/bin/brew"
    "${HOME}/linuxbrew/.linuxbrew/bin/brew"
  )

  for brew_bin in "${brew_candidates[@]}"; do
    if [[ -x "${brew_bin}" ]]; then
      log "Found Homebrew at ${brew_bin}, loading environment..."
      if apply_brew_shellenv "${brew_bin}"; then
        return 0
      fi
    fi
  done

  # Check for sudo access before attempting installation
  if ! sudo -n true 2> /dev/null; then
    echo -e "${RED}‚ùå Homebrew installation requires sudo access${RESET}" >&2
    echo -e "${CYAN}‚ÑπÔ∏è  Please ensure you have sudo permissions, or use an alternative installation method:${RESET}" >&2
    echo -e "${CYAN}‚ÑπÔ∏è  https://docs.brew.sh/Installation#alternative-installs${RESET}" >&2
    warn "Skipping Homebrew installation..." >&2
    return 1
  fi

  log "Installing Homebrew..."
  local install_script
  install_script="$(mktemp)"
  if curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh -o "${install_script}"; then
    /bin/bash "${install_script}"
    rm -f "${install_script}"

    # Load env after install
    if is_macos; then
      apply_brew_shellenv "/opt/homebrew/bin/brew" || apply_brew_shellenv "/usr/local/bin/brew"
    else
      apply_brew_shellenv "/home/linuxbrew/.linuxbrew/bin/brew" || apply_brew_shellenv "${HOME}/.linuxbrew/bin/brew"
    fi
  else
    error "Failed to download Homebrew install script."
  fi
}

# ==============================================================================
# Core Task Functions
# ==============================================================================

# @cmd bootstrap : Bootstrap the environment (core deps, dotfiles, shell prompt)
task_bootstrap() {
  local install_packages=true
  local skip_brew=false
  local dry_run=false

  while [[ $# -gt 0 ]]; do
    case $1 in
      --no-install)
        install_packages=false
        shift
        ;;
      --skip-brew)
        skip_brew=true
        shift
        ;;
      --dry-run)
        dry_run=true
        shift
        ;;
      *) shift ;;
    esac
  done

  header "Bootstrapping environment"

  # 1. Git Submodules
  if [[ -f "$ROOT_DIR/.gitmodules" ]]; then
    log "Initializing git submodules..."
    if [[ "$dry_run" == "false" ]]; then
      git -C "$ROOT_DIR" submodule update --init --recursive
    fi
  fi

  # 1a. Install fzf (only if not already installed)
  if [[ -f "$ROOT_DIR/.fzf/install" && ! -f "$ROOT_DIR/.fzf/bin/fzf" ]]; then
    log "Installing fzf..."
    if [[ "$dry_run" == "false" ]]; then
      "$ROOT_DIR/.fzf/install" --bin
      # Make fzf available in current shell
      export PATH="$ROOT_DIR/.fzf/bin:$PATH"
      # Source fzf shell integration if available
      # shellcheck source=/dev/null
      command -v fzf &> /dev/null && source <(fzf --zsh) 2> /dev/null || true
    fi
  fi

  # 2. Homebrew
  if [[ "$install_packages" == "true" && "$skip_brew" == "false" ]]; then
    if [[ "$dry_run" == "false" ]]; then
      if ! ensure_brew; then
        warn "Continuing without Homebrew..."
      fi
    fi
  else
    log "Skipping Homebrew installation..."
  fi

  # 3. Basic Tools
  if [[ "$install_packages" == "true" ]]; then
    log "Installing basic tools..."
    local basic_tools=(
      curl
      jq
      make
      python
      timeout
      vim
    )
    if command -v brew &> /dev/null; then
      for tool in "${basic_tools[@]}"; do
        if ! command -v "$tool" &> /dev/null; then
          log "Installing $tool..."
          local pkg="$tool"
          [[ "$tool" == "timeout" ]] && pkg="coreutils"
          if [[ "$dry_run" == "false" ]]; then
            brew install "$pkg"
          fi
        fi
      done
    fi
  fi

  # 4. Shell Setup
  if [[ "$install_packages" == "true" ]]; then
    log "Configuring shell..."

    # Install zsh if not present
    if ! command -v zsh &> /dev/null; then
      log "zsh not found, installing..."
      if [[ "$dry_run" == "false" ]]; then
        if is_macos; then
          warn "zsh should be pre-installed on macOS. If missing, install manually."
        else
          install_package zsh || warn "Failed to install zsh"
        fi
      fi
    fi

    # Change shell to zsh if it's not already
    if command -v zsh &> /dev/null; then
      local current_shell
      current_shell=$(get_user_shell)

      # Only change if current shell is not zsh
      if [[ "$current_shell" != *"zsh"* ]]; then
        local zsh_path
        zsh_path=$(command -v zsh)

        # Ensure zsh is in /etc/shells
        if ! grep -q "^$zsh_path$" /etc/shells 2> /dev/null; then
          log "Adding $zsh_path to /etc/shells..."
          if [[ "$dry_run" == "false" ]]; then
            echo "$zsh_path" | sudo tee -a /etc/shells > /dev/null
          fi
        fi

        log "Changing default shell to zsh..."
        if [[ "$dry_run" == "false" ]]; then
          chsh -s "$zsh_path" || warn "Failed to change shell. Try manually: chsh -s $zsh_path"
        fi
      else
        info "Shell is already zsh"
      fi
    fi
  fi

  # 5. Link dotfiles
  if [[ "$dry_run" == "false" ]]; then
    task_stow
  else
    log "DRY RUN: task_stow"
  fi

  success "Bootstrap complete!"

  if [[ "$dry_run" == "false" ]]; then
    log "Switching to jsh..."
    exec zsh
  fi
}

# @cmd clean : Clean up system
task_clean() {
  header "Cleaning up system"
  bash "$ROOT_DIR/scripts/unix/cleanup.sh" "$ROOT_DIR"
}

# @cmd stow : Deploy dotfiles
task_stow() {
  local dotfiles_dir="$ROOT_DIR/dotfiles"

  log "Checking for orphaned symlinks..."

  # Check home directory for orphaned symlinks
  local orphaned_links=()
  while IFS= read -r link; do
    orphaned_links+=("$link")
  done < <(find ~ -maxdepth 1 -type l ! -exec test -e {} \; -print 2> /dev/null)

  # Check .config directory for orphaned symlinks
  if [[ -d "$HOME/.config" ]]; then
    while IFS= read -r link; do
      orphaned_links+=("$link")
    done < <(find "$HOME/.config" -maxdepth 1 -type l ! -exec test -e {} \; -print 2> /dev/null)
  fi

  # Prompt to remove orphaned symlinks if any found
  if [[ ${#orphaned_links[@]} -gt 0 ]]; then
    warn "Found ${#orphaned_links[@]} orphaned symlink(s):"
    for link in "${orphaned_links[@]}"; do
      local target
      target=$(readlink "$link" 2> /dev/null || echo "<unreadable>")
      echo "  üìç $link -> $target"
    done
    echo ""

    if confirm "Remove all orphaned symlinks?"; then
      for link in "${orphaned_links[@]}"; do
        echo "üóëÔ∏è  Removing: $link"
        rm "$link"
      done
      success "Removed ${#orphaned_links[@]} orphaned symlink(s)"
    else
      info "Skipping orphaned symlink removal"
    fi
    echo ""
  fi

  log "Deploying dotfiles..."

  # Ensure .config directory exists in home
  mkdir -p "$HOME/.config"

  # Process each item in dotfiles directory
  for item in "$dotfiles_dir"/.* "$dotfiles_dir"/*; do
    # Skip . and ..
    [[ "$(basename "$item")" == "." || "$(basename "$item")" == ".." ]] && continue

    # Skip if item doesn't exist (glob didn't match)
    [[ ! -e "$item" ]] && continue

    local basename_item
    basename_item=$(basename "$item")
    local target="$HOME/$basename_item"

    # Special handling for .config directory
    if [[ "$basename_item" == ".config" ]]; then
      log "Processing .config directory..."

      # Iterate through items in .config
      for config_item in "$item"/*; do
        [[ ! -e "$config_item" ]] && continue

        local config_basename
        config_basename=$(basename "$config_item")
        local config_target="$HOME/.config/$config_basename"

        # Backup existing target if it exists and is not already a jsh symlink
        if [[ -e "$config_target" || -L "$config_target" ]]; then
          local link_target
          link_target=$(readlink "$config_target" 2> /dev/null || echo "")

          # Only backup if it's not already pointing to our dotfiles
          if [[ "$link_target" != "$config_item" ]]; then
            local backup_path="${config_target}-backup"

            if [[ -L "$config_target" ]]; then
              # If it's a symlink to something else, preserve it
              log "Backing up symlink $config_target -> $backup_path"
              mv "$config_target" "$backup_path"
            elif [[ -e "$config_target" ]]; then
              # If it's a file or directory, back it up
              log "Backing up $config_target -> $backup_path"
              mv "$config_target" "$backup_path"
            fi
          else
            # Already pointing to correct location, just remove and recreate
            rm "$config_target"
          fi
        fi

        # Create symlink
        ln -sf "$config_item" "$config_target"
        echo "  ‚úì Linked $config_basename"
      done
    else
      # Handle regular dotfiles

      # Backup existing target if it exists and is not already a jsh symlink
      if [[ -e "$target" || -L "$target" ]]; then
        local link_target
        link_target=$(readlink "$target" 2> /dev/null || echo "")

        # Only backup if it's not already pointing to our dotfiles
        if [[ "$link_target" != "$item" ]]; then
          local backup_path="${target}-backup"

          if [[ -L "$target" ]]; then
            # If it's a symlink to something else, preserve it
            log "Backing up symlink $target -> $backup_path"
            mv "$target" "$backup_path"
          elif [[ -e "$target" ]]; then
            # If it's a file or directory, back it up
            log "Backing up $target -> $backup_path"
            mv "$target" "$backup_path"
          fi
        else
          # Already pointing to correct location, just remove and recreate
          rm "$target"
        fi
      fi

      # Create symlink
      ln -sf "$item" "$target"
      echo "  ‚úì Linked $basename_item"
    fi
  done

  success "Dotfiles deployed successfully"
}

# @cmd unstow : Remove dotfiles
task_unstow() {
  local dotfiles_dir="$ROOT_DIR/dotfiles"

  log "Removing jsh-managed symlinks..."

  # Remove symlinks from home directory
  find ~ -maxdepth 1 -type l -print | while read -r link; do
    target=$(readlink "$link" 2> /dev/null || echo "")
    if [[ -z "$target" || ! -e "$target" ]]; then
      echo "üóëÔ∏è  Removing symlink: $link (orphaned)"
      rm "$link"
    elif [[ "$target" == *"$ROOT_DIR/dotfiles"* ]]; then
      echo "üóëÔ∏è  Removing symlink: $link"
      rm "$link"
    fi
  done

  # Remove symlinks from .config directory
  if [[ -d "$HOME/.config" ]]; then
    find "$HOME/.config" -maxdepth 1 -type l -print | while read -r link; do
      target=$(readlink "$link" 2> /dev/null || echo "")
      if [[ -z "$target" || ! -e "$target" ]]; then
        echo "üóëÔ∏è  Removing symlink: $link (orphaned)"
        rm "$link"
      elif [[ "$target" == *"$ROOT_DIR/dotfiles/.config"* ]]; then
        echo "üóëÔ∏è  Removing symlink: $link"
        rm "$link"
      fi
    done
  fi

  success "Dotfiles symlinks removed"
}

# @cmd uninstall : Completely uninstall jsh (remove symlinks and restore backups)
task_uninstall() {
  header "Uninstalling jsh"

  warn "This will remove all jsh-managed symlinks and restore original files."
  if ! confirm "Continue with uninstall?"; then
    info "Uninstall cancelled"
    return 0
  fi

  local dotfiles_dir="$ROOT_DIR/dotfiles"
  local removed_count=0
  local restored_count=0

  log "Removing jsh-managed symlinks from home directory..."

  # Process home directory symlinks
  for item in "$dotfiles_dir"/.* "$dotfiles_dir"/*; do
    [[ "$(basename "$item")" == "." || "$(basename "$item")" == ".." ]] && continue
    [[ ! -e "$item" ]] && continue

    local basename_item
    basename_item=$(basename "$item")
    local target="$HOME/$basename_item"

    # Skip .config as we handle it separately
    if [[ "$basename_item" == ".config" ]]; then
      continue
    fi

    # Remove jsh symlink if it exists
    if [[ -L "$target" ]]; then
      local link_target
      link_target=$(readlink "$target" 2> /dev/null || echo "")

      if [[ "$link_target" == "$item" ]]; then
        echo "üóëÔ∏è  Removing symlink: $target"
        rm "$target"
        ((removed_count++))

        # Restore backup if it exists
        local backup_path="${target}-backup"
        if [[ -e "$backup_path" || -L "$backup_path" ]]; then
          echo "‚ôªÔ∏è  Restoring backup: $backup_path -> $target"
          mv "$backup_path" "$target"
          ((restored_count++))
        fi
      fi
    fi
  done

  log "Removing jsh-managed symlinks from .config directory..."

  # Process .config directory symlinks
  if [[ -d "$dotfiles_dir/.config" ]]; then
    for config_item in "$dotfiles_dir/.config"/*; do
      [[ ! -e "$config_item" ]] && continue

      local config_basename
      config_basename=$(basename "$config_item")
      local config_target="$HOME/.config/$config_basename"

      # Remove jsh symlink if it exists
      if [[ -L "$config_target" ]]; then
        local link_target
        link_target=$(readlink "$config_target" 2> /dev/null || echo "")

        if [[ "$link_target" == "$config_item" ]]; then
          echo "üóëÔ∏è  Removing symlink: $config_target"
          rm "$config_target"
          ((removed_count++))

          # Restore backup if it exists
          local backup_path="${config_target}-backup"
          if [[ -e "$backup_path" || -L "$backup_path" ]]; then
            echo "‚ôªÔ∏è  Restoring backup: $backup_path -> $config_target"
            mv "$backup_path" "$config_target"
            ((restored_count++))
          fi
        fi
      fi
    done
  fi

  # Clean up any remaining orphaned symlinks
  log "Cleaning up orphaned symlinks..."

  find ~ -maxdepth 1 -type l ! -exec test -e {} \; -print 2> /dev/null | while read -r link; do
    local link_target
    link_target=$(readlink "$link" 2> /dev/null || echo "")

    if [[ "$link_target" == *"$ROOT_DIR"* ]]; then
      echo "üóëÔ∏è  Removing orphaned symlink: $link"
      rm "$link"
      ((removed_count++))
    fi
  done

  if [[ -d "$HOME/.config" ]]; then
    find "$HOME/.config" -maxdepth 1 -type l ! -exec test -e {} \; -print 2> /dev/null | while read -r link; do
      local link_target
      link_target=$(readlink "$link" 2> /dev/null || echo "")

      if [[ "$link_target" == *"$ROOT_DIR"* ]]; then
        echo "üóëÔ∏è  Removing orphaned symlink: $link"
        rm "$link"
        ((removed_count++))
      fi
    done
  fi

  # Remove jsh bin from PATH (user must manually edit shell config)
  info "Note: You may want to remove '$ROOT_DIR/bin' from your PATH"
  info "      Edit your shell configuration file (~/.zshrc, ~/.bashrc, etc.)"

  # Summary
  echo ""
  success "Uninstall complete!"
  info "  Removed symlinks: $removed_count"
  info "  Restored backups: $restored_count"

  if [[ $restored_count -gt 0 ]]; then
    info ""
    info "Your original files have been restored."
  fi

  info ""
  info "To completely remove jsh, run: rm -rf $ROOT_DIR"
}

task_install_casks() {
  check_brew || return
  log "Installing Casks..."
  brew install --force --cask "${CASKS[@]}"
}

task_install_formulae() {
  check_brew || return
  log "Installing Formulae..."
  if is_macos; then
    brew install --force "${FORMULAE_MACOS[@]}"
  else
    brew install --force "${FORMULAE_LINUX[@]}"
  fi
}

task_configure_links() {
  check_brew || return
  log "Configuring Brew Links..."
  brew link --overwrite --force "${LINKS[@]}"
}

task_start_services() {
  check_brew || return
  log "Starting Services..."
  brew services start "${SERVICES[@]}"
}

task_install_linux_packages() {
  log "Updating package cache..."
  update_package_cache
  log "Installing packages..."

  # Determine which package array to use based on available package manager
  local packages=()
  if command -v apt-get &> /dev/null; then
    packages=("${PACKAGES_APT[@]}")
  elif command -v dnf &> /dev/null; then
    packages=("${PACKAGES_DNF[@]}")
  elif command -v yum &> /dev/null; then
    packages=("${PACKAGES_YUM[@]}")
  elif command -v pacman &> /dev/null; then
    packages=("${PACKAGES_PACMAN[@]}")
  elif command -v apk &> /dev/null; then
    packages=("${PACKAGES_APK[@]}")
  elif command -v zypper &> /dev/null; then
    packages=("${PACKAGES_ZYPPER[@]}")
  else
    warn "No supported package manager found"
    return 1
  fi

  for package in "${packages[@]}"; do
    install_package "$package" || warn "Failed to install $package"
  done
}

task_configure_macos() {
  log "Configuring macOS..."

  # System Settings
  bash "$ROOT_DIR/scripts/macos/configure-settings.sh"

  # Dock
  bash "$ROOT_DIR/scripts/macos/configure-dock.sh"

  # Firefox
  local ff_dir
  ff_dir=$(find "$HOME/Library/Application Support/Firefox/Profiles" -type d -name "*.default-release" 2> /dev/null | head -n 1)
  if [[ -n "$ff_dir" && -d "/Applications/Firefox.app" ]]; then
    log "Configuring Firefox..."
    ln -sf "$ROOT_DIR/configs/firefox/user.js" "$ff_dir/user.js"
  else
    warn "Firefox not found or profile not detected."
  fi

  # VSCode
  if [[ -d "/Applications/Visual Studio Code.app" ]]; then
    log "Configuring VSCode..."
    local vscode_user="$HOME/Library/Application Support/Code/User"
    mkdir -p "$vscode_user"
    ln -sf "$ROOT_DIR/configs/vscode/keybindings.json" "$vscode_user/keybindings.json"
    ln -sf "$ROOT_DIR/configs/vscode/settings.json" "$vscode_user/settings.json"
  else
    warn "VSCode not found."
  fi
}

task_configure_linux() {
  log "Configuring Linux..."
  bash "$ROOT_DIR/scripts/linux/configure-sudoers.sh"
}

# @cmd wsl : Windows Subsystem for Linux integration
task_wsl() {
  header "Configuring and installing Windows and apps via WSL"
  bash "$ROOT_DIR/scripts/windows/configure-windows.sh" --all
}

# @cmd install : Install packages
task_install() {
  header "Installing packages"
  if is_linux; then
    task_install_linux_packages
  elif is_macos; then
    task_install_casks
  fi
  task_install_formulae
  task_start_services
}

# @cmd configure : Configure settings and apps
task_configure() {
  header "Configuring environment"
  task_stow
  task_configure_links

  if is_macos; then
    task_configure_macos
  elif is_linux; then
    task_configure_linux
  fi
}

# @cmd setup : Install and configure everything (post-bootstrap)
task_setup() {
  task_install
  task_configure
}

# @cmd upgrade : Upgrade packages
task_upgrade() {
  header "Upgrading packages"

  # Update zinit if present
  if command -v zsh &> /dev/null; then
    log "Updating zinit..."
    zsh -ic 'zinit self-update' 2> /dev/null || true
    zsh -ic 'zinit update --all' 2> /dev/null || true
  fi

  if is_macos; then
    if command -v brew &> /dev/null; then
      log "Upgrading Homebrew packages..."
      brew update && brew upgrade
    fi
    if command -v mas &> /dev/null; then
      log "Upgrading Mac App Store apps..."
      mas upgrade
    else
      warn "mas not installed - skipping App Store updates"
    fi
  elif is_linux; then
    log "Upgrading packages..."
    upgrade_packages
    if command -v brew &> /dev/null; then
      log "Upgrading Homebrew packages..."
      brew update && brew upgrade
    fi
  fi
}

# ==============================================================================
# Utility Commands (Restored & Adapted)
# ==============================================================================

# @cmd status : Show system status
cmd_status() {
  header "System Status"

  check_brew || return 1

  # Homebrew formulae
  echo -e "${BOLD}${MAGENTA}Homebrew Formulae:${RESET}"
  if cmd_exists brew; then
    local formulae_count
    formulae_count=$(brew list --formula 2> /dev/null | wc -l | tr -d ' ')
    echo -e "  Installed: ${GREEN}${formulae_count}${RESET} formulae"

    # Check for outdated
    local outdated
    outdated=$(brew outdated --formula 2> /dev/null | wc -l | tr -d ' ')
    if [[ "$outdated" -gt 0 ]]; then
      echo -e "  Outdated:  ${YELLOW}${outdated}${RESET} formulae"
    else
      echo -e "  Outdated:  ${GREEN}0${RESET} (all up to date)"
    fi
  fi
  echo

  # Homebrew casks (macOS only)
  if [[ "$(uname -s)" == "Darwin" ]]; then
    echo -e "${BOLD}${MAGENTA}Homebrew Casks:${RESET}"
    local casks_count
    casks_count=$(brew list --cask 2> /dev/null | wc -l | tr -d ' ')
    echo -e "  Installed: ${GREEN}${casks_count}${RESET} casks"

    local outdated_casks
    outdated_casks=$(brew outdated --cask 2> /dev/null | wc -l | tr -d ' ')
    if [[ "$outdated_casks" -gt 0 ]]; then
      echo -e "  Outdated:  ${YELLOW}${outdated_casks}${RESET} casks"
    else
      echo -e "  Outdated:  ${GREEN}0${RESET} (all up to date)"
    fi
    echo
  fi

  # Homebrew services
  echo -e "${BOLD}${MAGENTA}Homebrew Services:${RESET}"
  if cmd_exists brew; then
    while IFS= read -r line; do
      service=$(echo "$line" | awk '{print $1}')
      svc_status=$(echo "$line" | awk '{print $2}')

      if [[ "$svc_status" == "started" ]]; then
        echo -e "  ${GREEN}‚óè${RESET} ${service} (${GREEN}running${RESET})"
      elif [[ "$svc_status" == "stopped" ]]; then
        echo -e "  ${RED}‚óè${RESET} ${service} (${RED}stopped${RESET})"
      else
        echo -e "  ${YELLOW}‚óè${RESET} ${service} (${YELLOW}${svc_status}${RESET})"
      fi
    done < <(brew services list 2> /dev/null | tail -n +2)
  fi
  echo

  # Symlinks
  echo -e "${BOLD}${MAGENTA}Dotfile Symlinks:${RESET}"
  local symlink_count=0
  local broken_count=0

  # Count symlinks pointing to ROOT_DIR
  while IFS= read -r link; do
    ((symlink_count++))
    if [[ ! -e "$link" ]]; then
      ((broken_count++))
    fi
  done < <(find "$HOME" -maxdepth 1 -type l 2> /dev/null | while read -r link; do
    if [[ "$(readlink "$link")" == "${ROOT_DIR}"* ]]; then
      echo "$link"
    fi
  done)

  echo -e "  Total:  ${GREEN}${symlink_count}${RESET} symlinks"
  if [[ "$broken_count" -gt 0 ]]; then
    echo -e "  Broken: ${RED}${broken_count}${RESET} symlinks"
  else
    echo -e "  Broken: ${GREEN}0${RESET} (all valid)"
  fi
  echo

  # Git status
  echo -e "${BOLD}${MAGENTA}Git Repository:${RESET}"
  if [[ -d "${ROOT_DIR}/.git" ]]; then
    pushd "${ROOT_DIR}" > /dev/null
    local branch
    branch=$(git branch --show-current 2> /dev/null || echo "unknown")
    echo -e "  Branch:  ${CYAN}${branch}${RESET}"

    local git_status
    git_status=$(git status --porcelain 2> /dev/null | wc -l | tr -d ' ')
    if [[ "$git_status" -gt 0 ]]; then
      echo -e "  Changes: ${YELLOW}${git_status}${RESET} uncommitted changes"
    else
      echo -e "  Changes: ${GREEN}clean${RESET}"
    fi
    popd > /dev/null
  fi
  echo

  # System info
  echo -e "${BOLD}${MAGENTA}System Information:${RESET}"
  echo -e "  OS:     $(uname -s) $(uname -r)"
  echo -e "  Shell:  ${SHELL} (${ZSH_VERSION:-unknown})"
  echo -e "  Arch:   $(uname -m)"
  echo
}

# @cmd doctor : Run diagnostics
cmd_doctor() {
  header "Running jsh diagnostics"

  local issues=0

  # Check for required commands
  echo -e "${BOLD}Checking required commands...${RESET}"
  local required_cmds=(brew git curl jq vim)
  for cmd in "${required_cmds[@]}"; do
    if cmd_exists "$cmd"; then
      echo -e "  ${GREEN}‚úì${RESET} ${cmd}"
    else
      echo -e "  ${RED}‚úó${RESET} ${cmd} (missing)"
      ((issues++))
    fi
  done
  echo

  # Check for broken symlinks
  echo -e "${BOLD}Checking for broken symlinks...${RESET}"
  local broken_links=()
  while IFS= read -r link; do
    broken_links+=("$link")
  done < <(find "$HOME" -maxdepth 1 -type l ! -exec test -e {} \; -print 2> /dev/null)

  if [[ ${#broken_links[@]} -eq 0 ]]; then
    echo -e "  ${GREEN}‚úì${RESET} No broken symlinks found"
  else
    echo -e "  ${YELLOW}‚ö†${RESET} Found ${#broken_links[@]} broken symlink(s):"
    for link in "${broken_links[@]}"; do
      echo -e "    ${RED}‚Üí${RESET} $link"
      ((issues++))
    done
  fi
  echo

  # Check Git repository status
  echo -e "${BOLD}Checking Git repository...${RESET}"
  if [[ -d "${ROOT_DIR}/.git" ]]; then
    pushd "${ROOT_DIR}" > /dev/null
    if git rev-parse --git-dir > /dev/null 2>&1; then
      echo -e "  ${GREEN}‚úì${RESET} Git repository is valid"
    else
      echo -e "  ${RED}‚úó${RESET} Git repository is corrupted"
      ((issues++))
    fi

    # Check for submodules
    if [[ -f "${ROOT_DIR}/.gitmodules" ]]; then
      if git submodule status | grep -q '^-'; then
        echo -e "  ${YELLOW}‚ö†${RESET} Some submodules are not initialized"
        ((issues++))
      else
        echo -e "  ${GREEN}‚úì${RESET} All submodules initialized"
      fi
    fi
    popd > /dev/null
  else
    echo -e "  ${RED}‚úó${RESET} Not a Git repository"
    ((issues++))
  fi
  echo

  # Check Homebrew health
  if cmd_exists brew; then
    echo -e "${BOLD}Checking Homebrew...${RESET}"
    if brew doctor > /dev/null 2>&1; then
      echo -e "  ${GREEN}‚úì${RESET} Homebrew is healthy"
    else
      echo -e "  ${YELLOW}‚ö†${RESET} Homebrew has warnings (run 'brew doctor' for details)"
    fi
  fi
  echo

  # Summary
  if [[ $issues -eq 0 ]]; then
    success "All checks passed! No issues found."
  else
    warn "Found ${issues} issue(s). Please review the output above."
    return 1
  fi
}

# @cmd backup : Backup configuration
cmd_backup() {
  header "Backing up jsh configuration"

  local backup_dir="${HOME}/.jsh-backups"
  local timestamp
  timestamp=$(date +%Y%m%d_%H%M%S)
  local backup_path="${backup_dir}/jsh_${timestamp}"

  mkdir -p "$backup_dir"

  info "Creating backup at: ${backup_path}"

  # Backup key files
  mkdir -p "${backup_path}"

  # Copy important config files
  local configs=(.jshrc .gitconfig .vimrc .tmux.conf)
  for config in "${configs[@]}"; do
    if [[ -f "${HOME}/${config}" ]]; then
      cp "${HOME}/${config}" "${backup_path}/"
      echo -e "  ${GREEN}‚úì${RESET} Backed up ${config}"
    fi
  done

  # Backup brew packages list
  if cmd_exists brew; then
    brew bundle dump --file="${backup_path}/Brewfile" --force 2> /dev/null
    echo -e "  ${GREEN}‚úì${RESET} Backed up Brewfile"
  fi

  success "Backup created at: ${backup_path}"
}

# @cmd restore : Restore configuration
cmd_restore() {
  header "Restoring jsh configuration"

  local backup_dir="${HOME}/.jsh-backups"

  if [[ ! -d "$backup_dir" ]]; then
    error "No backups found at ${backup_dir}"
    return 1
  fi

  # List available backups
  echo -e "${BOLD}Available backups:${RESET}"
  local backups=()
  while IFS= read -r backup; do
    backups+=("$backup")
    echo -e "  ${CYAN}$(basename "$backup")${RESET}"
  done < <(find "$backup_dir" -maxdepth 1 -type d -name "jsh_*" | sort -r)

  if [[ ${#backups[@]} -eq 0 ]]; then
    error "No backups found"
    return 1
  fi

  echo
  read -r -p "Enter backup name to restore (or 'latest'): " backup_name

  local restore_path
  if [[ "$backup_name" == "latest" ]]; then
    restore_path="${backups[0]}"
  else
    restore_path="${backup_dir}/${backup_name}"
  fi

  if [[ ! -d "$restore_path" ]]; then
    error "Backup not found: ${restore_path}"
    return 1
  fi

  warn "This will overwrite your current configuration!"
  if ! confirm "Continue with restore?"; then
    info "Restore cancelled"
    return 0
  fi

  # Restore files
  for file in "${restore_path}"/*; do
    local filename
    filename=$(basename "$file")
    if [[ "$filename" != "Brewfile" ]]; then
      cp "$file" "${HOME}/${filename}"
      echo -e "  ${GREEN}‚úì${RESET} Restored ${filename}"
    fi
  done

  success "Restore complete from: $(basename "$restore_path")"
}

# @cmd list : List managed packages
cmd_list() {
  header "Managed Packages and Configurations"

  echo -e "${BOLD}${MAGENTA}Managed Formulae (macOS):${RESET}"
  printf '%s\n' "${FORMULAE_MACOS[@]}" | column
  echo
  echo -e "${BOLD}${MAGENTA}Managed Formulae (Linux):${RESET}"
  printf '%s\n' "${FORMULAE_LINUX[@]}" | column
  echo
  echo -e "${BOLD}${MAGENTA}Managed Casks:${RESET}"
  printf '%s\n' "${CASKS[@]}" | column
  echo

  if cmd_exists brew; then
    echo -e "${BOLD}${MAGENTA}Installed Formulae:${RESET}"
    brew list --formula -1 | head -20
    local total
    total=$(brew list --formula 2> /dev/null | wc -l | tr -d ' ')
    if [[ $total -gt 20 ]]; then
      echo -e "  ${YELLOW}... and $((total - 20)) more${RESET}"
    fi
    echo

    if [[ "$(uname -s)" == "Darwin" ]]; then
      echo -e "${BOLD}${MAGENTA}Installed Casks:${RESET}"
      brew list --cask -1 | head -20
      local cask_total
      cask_total=$(brew list --cask 2> /dev/null | wc -l | tr -d ' ')
      if [[ $cask_total -gt 20 ]]; then
        echo -e "  ${YELLOW}... and $((cask_total - 20)) more${RESET}"
      fi
      echo
    fi
  fi

  echo -e "${BOLD}${MAGENTA}Managed Configurations:${RESET}"
  if [[ -d "${ROOT_DIR}/configs" ]]; then
    find "${ROOT_DIR}/configs" -type f ! -path "*/.*" | while IFS= read -r config; do
      echo -e "  ${CYAN}‚Üí${RESET} ${config#${ROOT_DIR}/}"
    done
  fi
}

# @cmd brew : Manage Homebrew
cmd_brew() {
  local subcmd="${1:-help}"
  shift || true

  case "$subcmd" in
    setup)
      "${ROOT_DIR}/scripts/unix/brew.sh" setup
      ;;
    check)
      "${ROOT_DIR}/scripts/unix/brew.sh" check "$@"
      ;;
    help | --help | -h)
      echo -e "${BOLD}${CYAN}jsh brew${RESET} - Homebrew package management"
      echo
      "${ROOT_DIR}/scripts/unix/brew.sh"
      ;;
    *)
      # Pass through to brew
      if ! check_brew; then
        return 1
      fi
      "${ROOT_DIR}/scripts/unix/brew.sh" "$subcmd" "$@"
      ;;
  esac
}

# @cmd completion : Generate completion script
cmd_completion() {
  local src="${SOURCE:-$0}"

  cat << EOF
#compdef jsh

_jsh() {
    local context state state_descr line
    typeset -A opt_args

    _arguments -C \\
        '1: :_jsh_commands' \\
        '*:: :->args'

    case \$state in
        args)
            case \$line[1] in
EOF

  # Generate cases for subcommands
  local prev_parent=""
  grep '^# @cmd' "$src" | sed 's/^# @cmd //' | while read -r line; do
    cmd_part="${line%% :*}"
    if [[ "$cmd_part" == *" "* ]]; then
      parent="${cmd_part%% *}"
      if [[ "$parent" != "$prev_parent" ]]; then
        echo "                $parent)"
        echo "                    _arguments '1: :_jsh_${parent}_commands'"
        echo "                    ;;"
        prev_parent="$parent"
      fi
    fi
  done

  cat << EOF
              *)
                ;;
          esac
          ;;
  esac
}

_jsh_commands() {
    local -a commands
    commands=(
EOF

  # Top level commands
  grep '^# @cmd' "$src" | sed 's/^# @cmd //' | while read -r line; do
    cmd_part="${line%% :*}"
    desc="${line#* : }"
    if [[ "$cmd_part" != *" "* ]]; then
      echo "        '$cmd_part:$desc'"
    fi
  done

  cat << EOF
    )
    _describe -t commands 'jsh command' commands
}
EOF

  # Subcommand functions
  local parents
  parents=$(grep '^# @cmd' "$src" | sed 's/^# @cmd //' | while read -r line; do
    cmd_part="${line%% :*}"
    if [[ "$cmd_part" == *" "* ]]; then
      echo "${cmd_part%% *}"
    fi
  done | sort -u)

  for parent in $parents; do
    echo ""
    echo "_jsh_${parent}_commands() {"
    echo "    local -a commands"
    echo "    commands=("
    grep "^# @cmd $parent " "$src" | sed "s/^# @cmd $parent //" | while read -r line; do
      # Trim leading space if any
      line="${line## }"
      subcmd="${line%% :*}"
      if [[ -z "$subcmd" || "$subcmd" == :* ]]; then continue; fi
      desc="${line#* : }"
      echo "        '$subcmd:$desc'"
    done
    echo "    )"
    echo "    _describe -t commands '$parent command' commands"
    echo "}"
  done

  echo ""
  echo "_jsh"
}

# ==============================================================================
# Main Dispatcher
# ==============================================================================

# @cmd help : Show this help message
show_help() {
  local src="${SOURCE:-$0}"

  echo -e "${BOLD}${CYAN}jsh${RESET} - Dotfiles Management Utility"
  echo ""
  echo -e "${BOLD}USAGE:${RESET}"
  echo "  jsh <command> [options]"
  echo ""
  echo -e "${BOLD}COMMANDS:${RESET}"

  # Parse @cmd comments to generate help dynamically
  local -a parent_cmds

  # Collect and display top-level commands
  while IFS= read -r line; do
    local cmd_part="${line%% :*}"
    local desc="${line#* : }"

    if [[ "$cmd_part" != *" "* ]]; then
      # Top-level command
      printf "  ${GREEN}%-22s${RESET} %s\n" "$cmd_part" "$desc"
    else
      # Track parent for subcommands
      local parent="${cmd_part%% *}"
      if [[ ! " ${parent_cmds[*]} " =~ ${parent} ]]; then
        parent_cmds+=("$parent")
      fi
    fi
  done < <(grep '^# @cmd' "$src" | sed 's/^# @cmd //')

  # Display parent commands with note about subcommands
  for parent in "${parent_cmds[@]}"; do
    local subs=""
    local parent_desc=""

    # Get parent description if it exists
    while IFS= read -r line; do
      local cmd_part="${line%% :*}"
      local desc="${line#* : }"

      if [[ "$cmd_part" == "$parent" ]]; then
        parent_desc="$desc"
      elif [[ "$cmd_part" == "$parent "* ]]; then
        local sub="${cmd_part#* }"
        if [[ -z "$subs" ]]; then
          subs="$sub"
        else
          subs="$subs, $sub"
        fi
      fi
    done < <(grep "^# @cmd $parent" "$src" | sed 's/^# @cmd //')

    if [[ -n "$subs" ]]; then
      printf "  ${GREEN}%-22s${RESET} %s (subcommands: %s)\n" "$parent" "$parent_desc" "$subs"
    fi
  done

  echo ""
}

if [[ $# -eq 0 ]]; then
  show_help
  exit 0
fi

COMMAND="$1"
shift

case "$COMMAND" in
  bootstrap | init) task_bootstrap "$@" ;;
  setup) task_setup "$@" ;;
  install) task_install "$@" ;;
  configure) task_configure "$@" ;;
  clean | cleanup) task_clean "$@" ;;
  stow | link) task_stow "$@" ;;
  unstow | unlink) task_unstow "$@" ;;
  uninstall) task_uninstall "$@" ;;
  upgrade | update) task_upgrade "$@" ;;
  status) cmd_status "$@" ;;
  doctor | check) cmd_doctor "$@" ;;
  backup) cmd_backup "$@" ;;
  restore) cmd_restore "$@" ;;
  list | ls) cmd_list "$@" ;;
  brew) cmd_brew "$@" ;;
  wsl) task_wsl "$@" ;;
  completion) cmd_completion ;;
  help | --help | -h) show_help ;;
  *) error "Unknown command: $COMMAND" ;;
esac
