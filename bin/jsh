#!/usr/bin/env bash

# ============================================================================
# jsh
# ============================================================================
# A comprehensive command-line interface for managing the jsh project.
# ============================================================================

set -e

# ==============================================================================
# Configuration & Variables
# ==============================================================================

# Resolve the true path of the script to find the repository root
SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SOURCE" ]; do
  DIR="$(cd -P "$(dirname "$SOURCE")" > /dev/null 2>&1 && pwd)"
  SOURCE="$(readlink "$SOURCE")"
  [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE"
done
SCRIPT_DIR="$(cd -P "$(dirname "$SOURCE")" > /dev/null 2>&1 && pwd)"

# If script is in bin, root is 1 level up
if [[ "$SCRIPT_DIR" == *"bin" ]]; then
  ROOT_DIR="$(dirname "$SCRIPT_DIR")"
else
  ROOT_DIR="$SCRIPT_DIR"
fi

OS="$(uname -s)"

# Load .env if it exists
if [[ -f "$ROOT_DIR/.env" ]]; then
  source "$ROOT_DIR/.env"
fi

# ==============================================================================
# Package Management - Load from JSON files
# ==============================================================================

# Helper function to load packages from JSON file into an array
# Compatible with Bash 3.2+ (macOS default) - avoids mapfile which requires Bash 4+
load_packages_from_json() {
  local json_file="$1"
  if [[ ! -f "$json_file" ]]; then
    return 1
  fi

  # Parse JSON array and output each item on a separate line
  if command -v jq &> /dev/null; then
    jq -r '.[]' "$json_file" 2> /dev/null
  else
    # Fallback: simple grep-based parsing for JSON arrays
    grep -o '"[^"]*"' "$json_file" | tr -d '"'
  fi
}

# Load package arrays from JSON files using a while loop (Bash 3.2 compatible)
CASKS=()
while IFS= read -r line; do
  [[ -n "$line" ]] && CASKS+=("$line")
done < <(load_packages_from_json "$ROOT_DIR/configs/macos/casks.json")

FORMULAE_MACOS=()
while IFS= read -r line; do
  [[ -n "$line" ]] && FORMULAE_MACOS+=("$line")
done < <(load_packages_from_json "$ROOT_DIR/configs/macos/formulae.json")

FORMULAE_LINUX=()
while IFS= read -r line; do
  [[ -n "$line" ]] && FORMULAE_LINUX+=("$line")
done < <(load_packages_from_json "$ROOT_DIR/configs/linux/formulae.json")

# Linux package managers (apt, dnf, pacman, etc.)
PACKAGES_APT=()
while IFS= read -r line; do
  [[ -n "$line" ]] && PACKAGES_APT+=("$line")
done < <(load_packages_from_json "$ROOT_DIR/configs/linux/apt.json")

PACKAGES_DNF=()
while IFS= read -r line; do
  [[ -n "$line" ]] && PACKAGES_DNF+=("$line")
done < <(load_packages_from_json "$ROOT_DIR/configs/linux/dnf.json")

PACKAGES_PACMAN=()
while IFS= read -r line; do
  [[ -n "$line" ]] && PACKAGES_PACMAN+=("$line")
done < <(load_packages_from_json "$ROOT_DIR/configs/linux/pacman.json")

PACKAGES_YUM=()
while IFS= read -r line; do
  [[ -n "$line" ]] && PACKAGES_YUM+=("$line")
done < <(load_packages_from_json "$ROOT_DIR/configs/linux/yum.json")

PACKAGES_APK=()
while IFS= read -r line; do
  [[ -n "$line" ]] && PACKAGES_APK+=("$line")
done < <(load_packages_from_json "$ROOT_DIR/configs/linux/apk.json")

PACKAGES_ZYPPER=()
while IFS= read -r line; do
  [[ -n "$line" ]] && PACKAGES_ZYPPER+=("$line")
done < <(load_packages_from_json "$ROOT_DIR/configs/linux/zypper.json")

# --- Brew Services ---
SERVICES=(
  syncthing
)

# --- Brew Links ---
LINKS=(
  mpv
  tlrc
)

# ==============================================================================
# Helper Functions
# ==============================================================================

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
BOLD='\033[1m'
RESET='\033[0m'

log() { echo -e "${BLUE}üîπ $1${RESET}"; }
info() { echo -e "${CYAN}‚ÑπÔ∏è  $1${RESET}"; }
warn() { echo -e "${YELLOW}‚ö†Ô∏è  $1${RESET}"; }
error() {
  echo -e "${RED}‚ùå $1${RESET}"
  exit 1
}
success() { echo -e "${GREEN}‚úÖ $1${RESET}"; }
header() { echo -e "\n${BOLD}${BLUE}‚ñ∂ $1${RESET}\n"; }

confirm() {
  local prompt="$1"
  local response
  read -n 1 -r -p "${prompt} (y/N): " response
  echo # Print newline after single character input
  case "$response" in
    y | Y) return 0 ;;
    *) return 1 ;; # Default is No (empty/Enter counts as No)
  esac
}

cmd_exists() { command -v "$1" &> /dev/null; }

is_macos() { [[ "$OS" == "Darwin" ]]; }
is_linux() { [[ "$OS" == "Linux" ]]; }
is_wsl() { grep -qi microsoft /proc/version 2> /dev/null; }
is_root() { [[ "${EUID:-$(id -u)}" -eq 0 ]]; }

# ==============================================================================
# Brew User Delegation (for running as root)
# ==============================================================================

# Default brew user if not configured
BREW_USER="${BREW_USER:-}"

# Check if a user exists on the system
user_exists() {
  local username="$1"
  if is_macos; then
    dscl . -read "/Users/$username" &> /dev/null
  else
    id "$username" &> /dev/null
  fi
}

# Check if user is in admin/sudo group (idempotent check)
user_in_admin_group() {
  local username="$1"
  if is_macos; then
    dseditgroup -o checkmember -m "$username" admin &> /dev/null
  else
    # Check sudo or wheel group
    if getent group sudo &> /dev/null; then
      id -nG "$username" 2>/dev/null | grep -qw sudo
    elif getent group wheel &> /dev/null; then
      id -nG "$username" 2>/dev/null | grep -qw wheel
    else
      return 1
    fi
  fi
}

# Prompt for and create a standard user for brew delegation
# Args: default_user, non_interactive (true/false)
# Note: This function outputs the username to stdout for capture.
#       All info/status messages go to stderr to avoid corrupting the output.
create_brew_user() {
  local default_user="${1:-jay}"
  local non_interactive="${2:-false}"
  local username

  # In non-interactive mode, use default user directly
  if [[ "$non_interactive" == "true" ]]; then
    username="$default_user"
    info "Non-interactive mode: using user '$username' for brew operations." >&2
  else
    echo "" >&2
    warn "Homebrew cannot be run as root." >&2
    info "A standard (non-root) user is required to install and manage Homebrew." >&2
    echo "" >&2

    # Prompt for username
    read -r -p "Enter username for brew operations [$default_user]: " username
    username="${username:-$default_user}"
  fi

  # Validate username
  if [[ ! "$username" =~ ^[a-z_][a-z0-9_-]*$ ]]; then
    error "Invalid username. Use lowercase letters, numbers, underscores, and hyphens."
  fi

  # Check if user already exists
  if user_exists "$username"; then
    info "User '$username' already exists." >&2

    # Ensure user is in admin/sudo group
    if ! user_in_admin_group "$username"; then
      info "Adding '$username' to admin/sudo group..." >&2
      if is_macos; then
        sudo dseditgroup -o edit -a "$username" -t user admin 2>/dev/null || true
      else
        if getent group sudo &> /dev/null; then
          sudo usermod -aG sudo "$username" 2>/dev/null || true
        elif getent group wheel &> /dev/null; then
          sudo usermod -aG wheel "$username" 2>/dev/null || true
        fi
      fi
    fi

    if [[ "$non_interactive" == "true" ]]; then
      echo "$username"
      return 0
    fi

    if confirm "Use '$username' for brew operations?"; then
      echo "$username"
      return 0
    else
      return 1
    fi
  fi

  # Create the user
  info "Creating user '$username'..." >&2

  if is_macos; then
    # macOS user creation
    local max_id
    max_id=$(dscl . -list /Users UniqueID | awk '{print $2}' | sort -n | tail -1)
    local new_id=$((max_id + 1))

    # Create user with dscl
    sudo dscl . -create "/Users/$username"
    sudo dscl . -create "/Users/$username" UserShell /bin/zsh
    sudo dscl . -create "/Users/$username" RealName "$username"
    sudo dscl . -create "/Users/$username" UniqueID "$new_id"
    sudo dscl . -create "/Users/$username" PrimaryGroupID 20  # staff group
    sudo dscl . -create "/Users/$username" NFSHomeDirectory "/Users/$username"

    # Create home directory
    sudo mkdir -p "/Users/$username"
    sudo chown "$username:staff" "/Users/$username"

    # Set password (skip in non-interactive mode - user can set later)
    if [[ "$non_interactive" != "true" ]]; then
      info "Setting password for $username..." >&2
      sudo dscl . -passwd "/Users/$username"
    else
      info "Skipping password setup in non-interactive mode." >&2
      info "Set password later with: sudo dscl . -passwd /Users/$username" >&2
    fi

    # Add to admin group for sudo access (needed for brew) - idempotent
    sudo dseditgroup -o edit -a "$username" -t user admin 2>/dev/null || true

  else
    # Linux user creation
    if command -v useradd &> /dev/null; then
      sudo useradd -m -s /bin/bash "$username"
    elif command -v adduser &> /dev/null; then
      sudo adduser --disabled-password --gecos "" "$username"
    else
      error "No supported user creation tool found (useradd or adduser)"
    fi

    # Set password (skip in non-interactive mode)
    if [[ "$non_interactive" != "true" ]]; then
      info "Setting password for $username..." >&2
      sudo passwd "$username"
    else
      info "Skipping password setup in non-interactive mode." >&2
      info "Set password later with: sudo passwd $username" >&2
    fi

    # Add to sudo/wheel group
    if getent group sudo &> /dev/null; then
      sudo usermod -aG sudo "$username" 2>/dev/null || true
    elif getent group wheel &> /dev/null; then
      sudo usermod -aG wheel "$username" 2>/dev/null || true
    fi
  fi

  if user_exists "$username"; then
    success "User '$username' created successfully." >&2
    echo "$username"
    return 0
  else
    error "Failed to create user '$username'"
  fi
}

# Configure root to delegate brew operations to the specified user
configure_brew_delegation() {
  local brew_user="$1"

  if [[ -z "$brew_user" ]]; then
    error "No brew user specified for delegation"
  fi

  # Save to .env file for persistence
  local env_file="$ROOT_DIR/.env"

  if [[ -f "$env_file" ]]; then
    # Update existing BREW_USER or append
    if grep -q "^BREW_USER=" "$env_file"; then
      if is_macos; then
        sed -i '' "s/^BREW_USER=.*/BREW_USER=$brew_user/" "$env_file"
      else
        sed -i "s/^BREW_USER=.*/BREW_USER=$brew_user/" "$env_file"
      fi
    else
      echo "BREW_USER=$brew_user" >> "$env_file"
    fi
  else
    echo "BREW_USER=$brew_user" > "$env_file"
  fi

  # Export for current session
  export BREW_USER="$brew_user"

  success "Brew delegation configured for user: $brew_user"
  info "This setting is saved in $env_file"
}

# Run a command as the brew user (for root delegation)
run_as_brew_user() {
  local brew_user="${BREW_USER:-}"

  if [[ -z "$brew_user" ]]; then
    error "BREW_USER is not configured. Run 'jsh bootstrap' to set up brew delegation."
  fi

  if ! user_exists "$brew_user"; then
    error "Brew user '$brew_user' does not exist."
  fi

  # Run the command as the brew user
  sudo -u "$brew_user" "$@"
}

# Wrapper for brew command that handles root delegation
brew_cmd() {
  if is_root; then
    if [[ -z "${BREW_USER:-}" ]]; then
      warn "Running as root without configured brew user."
      warn "Please run 'jsh bootstrap' to configure brew delegation."
      return 1
    fi
    run_as_brew_user brew "$@"
  else
    brew "$@"
  fi
}

# Check if brew user is configured and valid when running as root
# Args: non_interactive (true/false)
ensure_brew_user() {
  local non_interactive="${1:-false}"

  if ! is_root; then
    return 0  # Not root, no delegation needed
  fi

  # Check if BREW_USER is already configured and valid
  if [[ -n "${BREW_USER:-}" ]] && user_exists "$BREW_USER"; then
    info "Using configured brew user: $BREW_USER"
    # Ensure user is in admin group
    if ! user_in_admin_group "$BREW_USER"; then
      info "Ensuring '$BREW_USER' has admin/sudo access..."
      if is_macos; then
        sudo dseditgroup -o edit -a "$BREW_USER" -t user admin 2>/dev/null || true
      else
        if getent group sudo &> /dev/null; then
          sudo usermod -aG sudo "$BREW_USER" 2>/dev/null || true
        elif getent group wheel &> /dev/null; then
          sudo usermod -aG wheel "$BREW_USER" 2>/dev/null || true
        fi
      fi
    fi
    return 0
  fi

  # BREW_USER is set but user doesn't exist - create it
  if [[ -n "${BREW_USER:-}" ]]; then
    info "BREW_USER='$BREW_USER' is configured but user does not exist."
    local brew_user
    brew_user=$(create_brew_user "$BREW_USER" "$non_interactive")
    if [[ -n "$brew_user" ]]; then
      configure_brew_delegation "$brew_user"
      return 0
    else
      warn "Failed to create configured brew user."
      return 1
    fi
  fi

  # Need to set up brew user delegation
  header "Root User Detected - Brew Delegation Setup"

  warn "You are running as root."
  info "Homebrew must be installed and run as a non-root user."
  info "We'll set up a standard user to handle brew operations."
  echo ""

  # In non-interactive mode, use default user without prompting
  if [[ "$non_interactive" == "true" ]]; then
    local brew_user
    brew_user=$(create_brew_user "jay" "true")
    if [[ -n "$brew_user" ]]; then
      configure_brew_delegation "$brew_user"
      return 0
    else
      warn "Failed to create brew user in non-interactive mode."
      return 1
    fi
  fi

  if ! confirm "Would you like to configure a user for brew operations?"; then
    warn "Skipping brew user setup. Homebrew features will be unavailable."
    return 1
  fi

  local brew_user
  brew_user=$(create_brew_user "jay" "false")

  if [[ -n "$brew_user" ]]; then
    configure_brew_delegation "$brew_user"
    return 0
  else
    warn "Brew user setup cancelled."
    return 1
  fi
}

# Get the user's login shell
get_user_shell() {
  local user_shell
  if is_macos; then
    user_shell=$(dscl . -read ~/ UserShell 2> /dev/null | awk '{print $2}')
  else
    user_shell=$(getent passwd "$(whoami)" 2> /dev/null | cut -d: -f7)
  fi
  echo "$user_shell"
}

# Install packages using the appropriate package manager
install_package() {
  local package="$1"

  if is_macos; then
    if command -v brew &> /dev/null; then
      brew install "$package"
    else
      warn "No package manager available on macOS"
      return 1
    fi
  elif is_linux; then
    if command -v apt-get &> /dev/null; then
      sudo apt-get install -y "$package"
    elif command -v dnf &> /dev/null; then
      sudo dnf install -y "$package"
    elif command -v yum &> /dev/null; then
      sudo yum install -y "$package"
    elif command -v pacman &> /dev/null; then
      sudo pacman -S --noconfirm "$package"
    elif command -v apk &> /dev/null; then
      sudo apk add "$package"
    elif command -v zypper &> /dev/null; then
      sudo zypper install -y "$package"
    else
      warn "No supported package manager found"
      return 1
    fi
  else
    warn "Unsupported operating system"
    return 1
  fi
}

# Update package manager cache
update_package_cache() {
  if is_linux; then
    if command -v apt-get &> /dev/null; then
      sudo apt-get update
    elif command -v dnf &> /dev/null; then
      sudo dnf check-update || true
    elif command -v yum &> /dev/null; then
      sudo yum check-update || true
    elif command -v pacman &> /dev/null; then
      sudo pacman -Sy
    elif command -v apk &> /dev/null; then
      sudo apk update
    elif command -v zypper &> /dev/null; then
      sudo zypper refresh
    fi
  fi
}

# Upgrade all packages
upgrade_packages() {
  if is_macos; then
    if command -v brew &> /dev/null; then
      brew update && brew upgrade
    fi
  elif is_linux; then
    if command -v apt-get &> /dev/null; then
      sudo apt-get update && sudo apt-get upgrade -y
    elif command -v dnf &> /dev/null; then
      sudo dnf upgrade -y
    elif command -v yum &> /dev/null; then
      sudo yum update -y
    elif command -v pacman &> /dev/null; then
      sudo pacman -Syu --noconfirm
    elif command -v apk &> /dev/null; then
      sudo apk upgrade
    elif command -v zypper &> /dev/null; then
      sudo zypper update -y
    fi
  fi
}

check_brew() {
  if ! command -v brew &> /dev/null; then
    warn "Homebrew not found. Skipping brew-related tasks."
    return 1
  fi
  return 0
}

apply_brew_shellenv() {
  local brew_bin="$1"
  [[ -n "$brew_bin" && -x "$brew_bin" ]] || return 1

  local brew_env
  if brew_env="$("$brew_bin" shellenv)"; then
    eval "$brew_env"
    return 0
  fi

  return 1
}

ensure_brew() {
  local non_interactive="${1:-false}"

  # Handle root user - need to delegate to a standard user
  if is_root; then
    if ! ensure_brew_user "$non_interactive"; then
      warn "Cannot install Homebrew as root without a delegated user."
      return 1
    fi

    # Check if brew is already installed (check as brew user)
    if run_as_brew_user command -v brew &> /dev/null; then
      info "Homebrew is available via user: $BREW_USER"
      return 0
    fi

    # Check common brew locations
    local brew_candidates=(
      "/opt/homebrew/bin/brew"
      "/usr/local/bin/brew"
      "/home/linuxbrew/.linuxbrew/bin/brew"
    )

    for brew_bin in "${brew_candidates[@]}"; do
      if [[ -x "${brew_bin}" ]]; then
        info "Found Homebrew at ${brew_bin} (accessible via user: $BREW_USER)"
        return 0
      fi
    done

    # Install Homebrew as the brew user
    log "Installing Homebrew as user: $BREW_USER"

    # Prepare the linuxbrew directory with proper ownership
    # This allows the brew user to install without needing sudo during install
    if is_linux; then
      if [[ ! -d "/home/linuxbrew" ]]; then
        log "Creating /home/linuxbrew directory..."
        mkdir -p /home/linuxbrew/.linuxbrew
        chown -R "$BREW_USER:$BREW_USER" /home/linuxbrew
      elif [[ ! -w "/home/linuxbrew/.linuxbrew" ]] || [[ "$(stat -c '%U' /home/linuxbrew 2>/dev/null)" != "$BREW_USER" ]]; then
        log "Fixing ownership of /home/linuxbrew..."
        chown -R "$BREW_USER:$BREW_USER" /home/linuxbrew
      fi
    fi

    local install_script
    install_script="$(mktemp)"
    chmod 644 "$install_script"

    if curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh -o "${install_script}"; then
      # Run install as the brew user with NONINTERACTIVE flag
      if sudo -u "$BREW_USER" NONINTERACTIVE=1 /bin/bash "${install_script}"; then
        rm -f "${install_script}"
        success "Homebrew installed successfully for user: $BREW_USER"

        # Display post-install instructions
        info ""
        info "To use brew commands as root, use: jsh brew <command>"
        info "The BREW_USER setting is saved in $ROOT_DIR/.env"
        return 0
      else
        rm -f "${install_script}"
        error "Failed to install Homebrew as user: $BREW_USER"
      fi
    else
      error "Failed to download Homebrew install script."
    fi
  fi

  # Non-root path - original behavior
  if command -v brew &> /dev/null; then
    return 0
  fi

  log "Checking for existing Homebrew installation..."
  local brew_candidates=(
    "/opt/homebrew/bin/brew"
    "/usr/local/bin/brew"
    "/home/linuxbrew/.linuxbrew/bin/brew"
    "${HOME}/.linuxbrew/bin/brew"
    "${HOME}/linuxbrew/.linuxbrew/bin/brew"
  )

  for brew_bin in "${brew_candidates[@]}"; do
    if [[ -x "${brew_bin}" ]]; then
      log "Found Homebrew at ${brew_bin}, loading environment..."
      if apply_brew_shellenv "${brew_bin}"; then
        return 0
      fi
    fi
  done

  # Check for sudo access before attempting installation
  if ! sudo -n true 2> /dev/null; then
    echo -e "${RED}‚ùå Homebrew installation requires sudo access${RESET}" >&2
    echo -e "${CYAN}‚ÑπÔ∏è  Please ensure you have sudo permissions, or use an alternative installation method:${RESET}" >&2
    echo -e "${CYAN}‚ÑπÔ∏è  https://docs.brew.sh/Installation#alternative-installs${RESET}" >&2
    warn "Skipping Homebrew installation..." >&2
    return 1
  fi

  log "Installing Homebrew..."
  local install_script
  install_script="$(mktemp)"
  if curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh -o "${install_script}"; then
    /bin/bash "${install_script}"
    rm -f "${install_script}"

    # Load env after install
    if is_macos; then
      apply_brew_shellenv "/opt/homebrew/bin/brew" || apply_brew_shellenv "/usr/local/bin/brew"
    else
      apply_brew_shellenv "/home/linuxbrew/.linuxbrew/bin/brew" || apply_brew_shellenv "${HOME}/.linuxbrew/bin/brew"
    fi
  else
    error "Failed to download Homebrew install script."
  fi
}

# ==============================================================================
# Core Task Functions
# ==============================================================================

# @cmd bootstrap : Bootstrap the environment (interactive setup with customization options)
task_bootstrap() {
  # Show detailed help if requested
  if [[ "$1" == "--help" || "$1" == "-h" ]]; then
    echo -e "${BOLD}${CYAN}jsh bootstrap${RESET} - Interactive environment setup"
    echo ""
    echo -e "${BOLD}USAGE:${RESET}"
    echo "  jsh bootstrap [OPTIONS]"
    echo ""
    echo -e "${BOLD}DESCRIPTION:${RESET}"
    echo "  Sets up your shell environment with interactive prompts to customize:"
    echo "    ‚Ä¢ Shell selection (zsh, bash, or keep current)"
    echo "    ‚Ä¢ Setup type (minimal or full-featured)"
    echo "    ‚Ä¢ Package installation preferences"
    echo "    ‚Ä¢ Plugin manager installation (zinit for zsh)"
    echo ""
    echo -e "${BOLD}OPTIONS:${RESET}"
    echo "  -y, --non-interactive    Skip prompts, use defaults (zsh + full setup)"
    echo "  --shell SHELL            Pre-select shell: zsh, bash, or skip"
    echo "  --minimal                Use minimal setup (lightweight, no plugins)"
    echo "  --full                   Use full setup (themes, plugins, completions)"
    echo "  --no-install             Skip package installation"
    echo "  --skip-brew              Skip Homebrew installation"
    echo "  --dry-run                Show what would be done without doing it"
    echo ""
    echo -e "${BOLD}EXAMPLES:${RESET}"
    echo "  jsh bootstrap                    # Interactive setup with prompts"
    echo "  jsh bootstrap -y                 # Non-interactive with defaults"
    echo "  jsh bootstrap --shell bash       # Pre-select bash shell"
    echo "  jsh bootstrap --minimal          # Lightweight setup"
    echo "  jsh bootstrap --dry-run          # Preview changes"
    echo ""
    return 0
  fi

  local install_packages=true
  local skip_brew=false
  local dry_run=false
  local interactive=true
  local target_shell=""
  local setup_type=""

  # Parse command-line arguments
  while [[ $# -gt 0 ]]; do
    case $1 in
      --no-install)
        install_packages=false
        shift
        ;;
      --skip-brew)
        skip_brew=true
        shift
        ;;
      --dry-run)
        dry_run=true
        shift
        ;;
      --non-interactive | -y)
        interactive=false
        shift
        ;;
      --shell)
        target_shell="$2"
        shift 2
        ;;
      --minimal)
        setup_type="minimal"
        shift
        ;;
      --full)
        setup_type="full"
        shift
        ;;
      *) shift ;;
    esac
  done

  header "Bootstrapping jsh environment"

  # Interactive prompts
  if [[ "$interactive" == "true" ]]; then
    echo ""
    info "Welcome to jsh! Let's configure your shell environment."
    echo ""

    # Shell selection
    if [[ -z "$target_shell" ]]; then
      echo -e "${BOLD}Shell Selection:${RESET}"
      echo "  1) zsh   (recommended - modern, feature-rich)"
      echo "  2) bash  (traditional, widely compatible)"
      echo "  3) skip  (keep current shell: $(basename "$SHELL"))"
      echo ""
      read -n 1 -r -p "Choose your shell (1-3): " shell_choice
      echo ""
      echo ""

      case "$shell_choice" in
        1) target_shell="zsh" ;;
        2) target_shell="bash" ;;
        3) target_shell="skip" ;;
        *)
          warn "Invalid choice, defaulting to zsh"
          target_shell="zsh"
          ;;
      esac
    fi

    # Setup type selection
    if [[ -z "$setup_type" ]]; then
      echo -e "${BOLD}Setup Type:${RESET}"
      echo "  1) Minimal  - Core tools only, lightweight shell"
      echo "  2) Full     - All features: themes, plugins, completions"
      echo ""
      read -n 1 -r -p "Choose setup type (1-2): " setup_choice
      echo ""
      echo ""

      case "$setup_choice" in
        1) setup_type="minimal" ;;
        2) setup_type="full" ;;
        *)
          warn "Invalid choice, defaulting to full"
          setup_type="full"
          ;;
      esac
    fi

    # Package installation confirmation
    if [[ "$install_packages" == "true" ]]; then
      echo -e "${BOLD}Package Installation:${RESET}"
      info "This will install/update:"
      echo "  ‚Ä¢ Homebrew (package manager)"
      echo "  ‚Ä¢ Essential tools (curl, jq, vim, etc.)"
      if [[ "$target_shell" == "zsh" ]]; then
        echo "  ‚Ä¢ Zsh shell"
      elif [[ "$target_shell" == "bash" ]]; then
        echo "  ‚Ä¢ Bash shell (if not present)"
      fi
      echo ""

      if ! confirm "Proceed with package installation?"; then
        install_packages=false
        skip_brew=true
        info "Skipping package installation"
        echo ""
      fi
    fi
  else
    # Non-interactive defaults
    [[ -z "$target_shell" ]] && target_shell="zsh"
    [[ -z "$setup_type" ]] && setup_type="full"
  fi

  # Apply setup type
  if [[ "$setup_type" == "minimal" ]]; then
    export ZSH_MINIMAL=1
    info "Minimal setup selected - lightweight configuration will be used"
    echo ""
  fi

  header "Starting bootstrap process"

  # 1. Git Submodules
  if [[ -f "$ROOT_DIR/.gitmodules" ]]; then
    log "Initializing git submodules..."
    if [[ "$dry_run" == "false" ]]; then
      git -C "$ROOT_DIR" submodule update --init --recursive
    fi
  fi

  # 1a. Install fzf (only if not already installed)
  if [[ -f "$ROOT_DIR/.fzf/install" && ! -f "$ROOT_DIR/.fzf/bin/fzf" ]]; then
    log "Installing fzf..."
    if [[ "$dry_run" == "false" ]]; then
      "$ROOT_DIR/.fzf/install" --bin
      # Make fzf available in current shell
      export PATH="$ROOT_DIR/.fzf/bin:$PATH"
      # Source fzf shell integration if available
      # shellcheck source=/dev/null
      command -v fzf &> /dev/null && source <(fzf --zsh) 2> /dev/null || true
    fi
  fi

  # 2. Homebrew
  if [[ "$install_packages" == "true" && "$skip_brew" == "false" ]]; then
    if [[ "$dry_run" == "false" ]]; then
      local non_interactive_flag="false"
      [[ "$interactive" == "false" ]] && non_interactive_flag="true"
      if ! ensure_brew "$non_interactive_flag"; then
        warn "Continuing without Homebrew..."
      fi
    fi
  else
    log "Skipping Homebrew installation..."
  fi

  # 3. Basic Tools
  if [[ "$install_packages" == "true" ]]; then
    log "Installing basic tools..."
    local basic_tools=(
      curl
      jq
      make
      python
      timeout
      vim
    )
    if command -v brew &> /dev/null; then
      for tool in "${basic_tools[@]}"; do
        if ! command -v "$tool" &> /dev/null; then
          log "Installing $tool..."
          local pkg="$tool"
          [[ "$tool" == "timeout" ]] && pkg="coreutils"
          if [[ "$dry_run" == "false" ]]; then
            brew install "$pkg"
          fi
        fi
      done
    fi
  fi

  # 4. Shell Setup
  if [[ "$install_packages" == "true" && "$target_shell" != "skip" ]]; then
    log "Configuring shell: $target_shell"

    # Install target shell if not present
    if ! command -v "$target_shell" &> /dev/null; then
      log "$target_shell not found, installing..."
      if [[ "$dry_run" == "false" ]]; then
        if is_macos && [[ "$target_shell" == "zsh" ]]; then
          warn "zsh should be pre-installed on macOS. If missing, install manually."
        else
          install_package "$target_shell" || warn "Failed to install $target_shell"
        fi
      fi
    fi

    # Change shell if requested and available
    if command -v "$target_shell" &> /dev/null; then
      local current_shell
      current_shell=$(get_user_shell)

      # Only change if current shell is different
      if [[ "$current_shell" != *"$target_shell"* ]]; then
        local shell_path
        shell_path=$(command -v "$target_shell")

        # Ensure shell is in /etc/shells
        if ! grep -q "^$shell_path$" /etc/shells 2> /dev/null; then
          log "Adding $shell_path to /etc/shells..."
          if [[ "$dry_run" == "false" ]]; then
            echo "$shell_path" | sudo tee -a /etc/shells > /dev/null
          fi
        fi

        log "Changing default shell to $target_shell..."
        if [[ "$dry_run" == "false" ]]; then
          chsh -s "$shell_path" || warn "Failed to change shell. Try manually: chsh -s $shell_path"
        fi
      else
        info "Shell is already $target_shell"
      fi
    fi
  elif [[ "$target_shell" == "skip" ]]; then
    info "Keeping current shell: $(basename "$SHELL")"
  fi

  # 5. Link dotfiles
  if [[ "$dry_run" == "false" ]]; then
    task_stow
  else
    log "DRY RUN: task_stow"
  fi

  # 6. Optional Zinit installation for enhanced shell experience
  if [[ "$install_packages" == "true" && "$dry_run" == "false" && "$target_shell" == "zsh" ]]; then
    local zinit_home="${XDG_DATA_HOME:-${HOME}/.local/share}/zinit/zinit.git"

    # Only prompt if full setup and zinit not already installed
    if [[ "$setup_type" == "full" && ! -d "${zinit_home}" ]]; then
      echo ""
      if [[ "$interactive" == "true" ]]; then
        info "Zinit is a plugin manager that enables advanced shell features:"
        info "  ‚Ä¢ Powerlevel10k theme (customizable prompt)"
        info "  ‚Ä¢ Syntax highlighting and auto-suggestions"
        info "  ‚Ä¢ Enhanced completions and fuzzy search"
        echo ""

        if confirm "Install zinit and plugins?"; then
          log "Installing zinit..."
          mkdir -p "${zinit_home%/*}"
          if git clone https://github.com/zdharma-continuum/zinit.git "${zinit_home}"; then
            success "Zinit installed successfully"
          else
            warn "Failed to install zinit. You can install it later with:"
            warn "  git clone https://github.com/zdharma-continuum/zinit.git ${zinit_home}"
          fi
        else
          info "Skipping zinit. You can install it later by running bootstrap again."
        fi
      else
        # Non-interactive full setup: install zinit automatically
        log "Installing zinit for full setup..."
        mkdir -p "${zinit_home%/*}"
        if git clone https://github.com/zdharma-continuum/zinit.git "${zinit_home}"; then
          success "Zinit installed successfully"
        else
          warn "Failed to install zinit"
        fi
      fi
    elif [[ "$setup_type" == "minimal" ]]; then
      info "Skipping zinit (minimal setup). Set ZSH_MINIMAL=0 to enable plugins later."
    fi
  fi

  success "Bootstrap complete!"

  echo ""
  info "Summary:"
  info "  Shell:      $target_shell"
  info "  Setup type: $setup_type"
  info "  Packages:   $(if [[ "$install_packages" == "true" ]]; then echo "installed"; else echo "skipped"; fi)"
  echo ""

  if [[ "$dry_run" == "false" && "$target_shell" != "skip" ]]; then
    if [[ "$interactive" == "false" ]]; then
      # Non-interactive mode: start shell automatically
      log "Starting $target_shell session..."
      exec "$target_shell"
    else
      info "To activate your new shell environment, either:"
      info "  1) Log out and log back in"
      info "  2) Run: exec $target_shell"
      echo ""
      if confirm "Start new $target_shell session now?"; then
        log "Starting $target_shell..."
        exec "$target_shell"
      fi
    fi
  fi
}

# @cmd clean : Clean up system
task_clean() {
  header "Cleaning up system"
  bash "$ROOT_DIR/scripts/unix/cleanup.sh" "$ROOT_DIR"
}

# @cmd stow : Deploy dotfiles
task_stow() {
  local dotfiles_dir="$ROOT_DIR/dotfiles"

  log "Checking for orphaned symlinks..."

  # Check home directory for orphaned symlinks
  local orphaned_links=()
  while IFS= read -r link; do
    orphaned_links+=("$link")
  done < <(find ~ -maxdepth 1 -type l ! -exec test -e {} \; -print 2> /dev/null)

  # Check .config directory for orphaned symlinks
  if [[ -d "$HOME/.config" ]]; then
    while IFS= read -r link; do
      orphaned_links+=("$link")
    done < <(find "$HOME/.config" -maxdepth 1 -type l ! -exec test -e {} \; -print 2> /dev/null)
  fi

  # Prompt to remove orphaned symlinks if any found
  if [[ ${#orphaned_links[@]} -gt 0 ]]; then
    warn "Found ${#orphaned_links[@]} orphaned symlink(s):"
    for link in "${orphaned_links[@]}"; do
      local target
      target=$(readlink "$link" 2> /dev/null || echo "<unreadable>")
      echo "  üìç $link -> $target"
    done
    echo ""

    if confirm "Remove all orphaned symlinks?"; then
      for link in "${orphaned_links[@]}"; do
        echo "üóëÔ∏è  Removing: $link"
        rm "$link"
      done
      success "Removed ${#orphaned_links[@]} orphaned symlink(s)"
    else
      info "Skipping orphaned symlink removal"
    fi
    echo ""
  fi

  log "Deploying dotfiles..."

  # Ensure .config directory exists in home
  mkdir -p "$HOME/.config"

  # Process each item in dotfiles directory
  for item in "$dotfiles_dir"/.* "$dotfiles_dir"/*; do
    # Skip . and ..
    [[ "$(basename "$item")" == "." || "$(basename "$item")" == ".." ]] && continue

    # Skip if item doesn't exist (glob didn't match)
    [[ ! -e "$item" ]] && continue

    local basename_item
    basename_item=$(basename "$item")
    local target="$HOME/$basename_item"

    # Special handling for .config directory
    if [[ "$basename_item" == ".config" ]]; then
      log "Processing .config directory..."

      # Iterate through items in .config
      for config_item in "$item"/*; do
        [[ ! -e "$config_item" ]] && continue

        local config_basename
        config_basename=$(basename "$config_item")
        local config_target="$HOME/.config/$config_basename"

        # Backup existing target if it exists and is not already a jsh symlink
        if [[ -e "$config_target" || -L "$config_target" ]]; then
          local link_target
          link_target=$(readlink "$config_target" 2> /dev/null || echo "")

          # Only backup if it's not already pointing to our dotfiles
          if [[ "$link_target" != "$config_item" ]]; then
            local backup_path="${config_target}-backup"

            if [[ -L "$config_target" ]]; then
              # If it's a symlink to something else, preserve it
              log "Backing up symlink $config_target -> $backup_path"
              mv "$config_target" "$backup_path"
            elif [[ -e "$config_target" ]]; then
              # If it's a file or directory, back it up
              log "Backing up $config_target -> $backup_path"
              mv "$config_target" "$backup_path"
            fi
          else
            # Already pointing to correct location, just remove and recreate
            rm "$config_target"
          fi
        fi

        # Create symlink
        ln -sf "$config_item" "$config_target"
        echo "  ‚úì Linked $config_basename"
      done
    else
      # Handle regular dotfiles

      # Backup existing target if it exists and is not already a jsh symlink
      if [[ -e "$target" || -L "$target" ]]; then
        local link_target
        link_target=$(readlink "$target" 2> /dev/null || echo "")

        # Only backup if it's not already pointing to our dotfiles
        if [[ "$link_target" != "$item" ]]; then
          local backup_path="${target}-backup"

          if [[ -L "$target" ]]; then
            # If it's a symlink to something else, preserve it
            log "Backing up symlink $target -> $backup_path"
            mv "$target" "$backup_path"
          elif [[ -e "$target" ]]; then
            # If it's a file or directory, back it up
            log "Backing up $target -> $backup_path"
            mv "$target" "$backup_path"
          fi
        else
          # Already pointing to correct location, just remove and recreate
          rm "$target"
        fi
      fi

      # Create symlink
      ln -sf "$item" "$target"
      echo "  ‚úì Linked $basename_item"
    fi
  done

  success "Dotfiles deployed successfully"
}

# @cmd unstow : Remove dotfiles
task_unstow() {
  local dotfiles_dir="$ROOT_DIR/dotfiles"

  log "Removing jsh-managed symlinks..."

  # Remove symlinks from home directory
  find ~ -maxdepth 1 -type l -print | while read -r link; do
    target=$(readlink "$link" 2> /dev/null || echo "")
    if [[ -z "$target" || ! -e "$target" ]]; then
      echo "üóëÔ∏è  Removing symlink: $link (orphaned)"
      rm "$link"
    elif [[ "$target" == *"$ROOT_DIR/dotfiles"* ]]; then
      echo "üóëÔ∏è  Removing symlink: $link"
      rm "$link"
    fi
  done

  # Remove symlinks from .config directory
  if [[ -d "$HOME/.config" ]]; then
    find "$HOME/.config" -maxdepth 1 -type l -print | while read -r link; do
      target=$(readlink "$link" 2> /dev/null || echo "")
      if [[ -z "$target" || ! -e "$target" ]]; then
        echo "üóëÔ∏è  Removing symlink: $link (orphaned)"
        rm "$link"
      elif [[ "$target" == *"$ROOT_DIR/dotfiles/.config"* ]]; then
        echo "üóëÔ∏è  Removing symlink: $link"
        rm "$link"
      fi
    done
  fi

  success "Dotfiles symlinks removed"
}

# @cmd uninstall : Completely uninstall jsh (remove symlinks and restore backups)
task_uninstall() {
  header "Uninstalling jsh"

  warn "This will remove all jsh-managed symlinks and restore original files."
  if ! confirm "Continue with uninstall?"; then
    info "Uninstall cancelled"
    return 0
  fi

  local dotfiles_dir="$ROOT_DIR/dotfiles"
  local removed_count=0
  local restored_count=0

  log "Removing jsh-managed symlinks from home directory..."

  # Process home directory symlinks
  for item in "$dotfiles_dir"/.* "$dotfiles_dir"/*; do
    [[ "$(basename "$item")" == "." || "$(basename "$item")" == ".." ]] && continue
    [[ ! -e "$item" ]] && continue

    local basename_item
    basename_item=$(basename "$item")
    local target="$HOME/$basename_item"

    # Skip .config as we handle it separately
    if [[ "$basename_item" == ".config" ]]; then
      continue
    fi

    # Remove jsh symlink if it exists
    if [[ -L "$target" ]]; then
      local link_target
      link_target=$(readlink "$target" 2> /dev/null || echo "")

      if [[ "$link_target" == "$item" ]]; then
        echo "üóëÔ∏è  Removing symlink: $target"
        rm "$target"
        ((removed_count++))

        # Restore backup if it exists
        local backup_path="${target}-backup"
        if [[ -e "$backup_path" || -L "$backup_path" ]]; then
          echo "‚ôªÔ∏è  Restoring backup: $backup_path -> $target"
          mv "$backup_path" "$target"
          ((restored_count++))
        fi
      fi
    fi
  done

  log "Removing jsh-managed symlinks from .config directory..."

  # Process .config directory symlinks
  if [[ -d "$dotfiles_dir/.config" ]]; then
    for config_item in "$dotfiles_dir/.config"/*; do
      [[ ! -e "$config_item" ]] && continue

      local config_basename
      config_basename=$(basename "$config_item")
      local config_target="$HOME/.config/$config_basename"

      # Remove jsh symlink if it exists
      if [[ -L "$config_target" ]]; then
        local link_target
        link_target=$(readlink "$config_target" 2> /dev/null || echo "")

        if [[ "$link_target" == "$config_item" ]]; then
          echo "üóëÔ∏è  Removing symlink: $config_target"
          rm "$config_target"
          ((removed_count++))

          # Restore backup if it exists
          local backup_path="${config_target}-backup"
          if [[ -e "$backup_path" || -L "$backup_path" ]]; then
            echo "‚ôªÔ∏è  Restoring backup: $backup_path -> $config_target"
            mv "$backup_path" "$config_target"
            ((restored_count++))
          fi
        fi
      fi
    done
  fi

  # Clean up any remaining orphaned symlinks
  log "Cleaning up orphaned symlinks..."

  find ~ -maxdepth 1 -type l ! -exec test -e {} \; -print 2> /dev/null | while read -r link; do
    local link_target
    link_target=$(readlink "$link" 2> /dev/null || echo "")

    if [[ "$link_target" == *"$ROOT_DIR"* ]]; then
      echo "üóëÔ∏è  Removing orphaned symlink: $link"
      rm "$link"
      ((removed_count++))
    fi
  done

  if [[ -d "$HOME/.config" ]]; then
    find "$HOME/.config" -maxdepth 1 -type l ! -exec test -e {} \; -print 2> /dev/null | while read -r link; do
      local link_target
      link_target=$(readlink "$link" 2> /dev/null || echo "")

      if [[ "$link_target" == *"$ROOT_DIR"* ]]; then
        echo "üóëÔ∏è  Removing orphaned symlink: $link"
        rm "$link"
        ((removed_count++))
      fi
    done
  fi

  # Remove jsh bin from PATH (user must manually edit shell config)
  info "Note: You may want to remove '$ROOT_DIR/bin' from your PATH"
  info "      Edit your shell configuration file (~/.zshrc, ~/.bashrc, etc.)"

  # Summary
  echo ""
  success "Uninstall complete!"
  info "  Removed symlinks: $removed_count"
  info "  Restored backups: $restored_count"

  if [[ $restored_count -gt 0 ]]; then
    info ""
    info "Your original files have been restored."
  fi

  info ""
  info "To completely remove jsh, run: rm -rf $ROOT_DIR"
}

task_install_casks() {
  check_brew || return
  log "Installing Casks..."
  brew install --force --cask "${CASKS[@]}"
}

task_install_formulae() {
  check_brew || return
  log "Installing Formulae..."
  if is_macos; then
    brew install --force "${FORMULAE_MACOS[@]}"
  else
    brew install --force "${FORMULAE_LINUX[@]}"
  fi
}

task_configure_links() {
  check_brew || return
  log "Configuring Brew Links..."
  brew link --overwrite --force "${LINKS[@]}"
}

task_start_services() {
  check_brew || return
  log "Starting Services..."
  brew services start "${SERVICES[@]}"
}

task_install_linux_packages() {
  log "Updating package cache..."
  update_package_cache
  log "Installing packages..."

  # Determine which package array to use based on available package manager
  local packages=()
  if command -v apt-get &> /dev/null; then
    packages=("${PACKAGES_APT[@]}")
  elif command -v dnf &> /dev/null; then
    packages=("${PACKAGES_DNF[@]}")
  elif command -v yum &> /dev/null; then
    packages=("${PACKAGES_YUM[@]}")
  elif command -v pacman &> /dev/null; then
    packages=("${PACKAGES_PACMAN[@]}")
  elif command -v apk &> /dev/null; then
    packages=("${PACKAGES_APK[@]}")
  elif command -v zypper &> /dev/null; then
    packages=("${PACKAGES_ZYPPER[@]}")
  else
    warn "No supported package manager found"
    return 1
  fi

  for package in "${packages[@]}"; do
    install_package "$package" || warn "Failed to install $package"
  done
}

task_configure_macos() {
  log "Configuring macOS..."

  # System Settings
  bash "$ROOT_DIR/scripts/macos/configure-settings.sh"

  # Dock
  bash "$ROOT_DIR/scripts/macos/configure-dock.sh"

  # VSCode
  if [[ -d "/Applications/Visual Studio Code.app" ]]; then
    log "Configuring VSCode..."
    local vscode_user="$HOME/Library/Application Support/Code/User"
    mkdir -p "$vscode_user"
    ln -sf "$ROOT_DIR/configs/vscode/keybindings.json" "$vscode_user/keybindings.json"
    ln -sf "$ROOT_DIR/configs/vscode/settings.json" "$vscode_user/settings.json"
  else
    warn "VSCode not found."
  fi
}

task_configure_linux() {
  log "Configuring Linux..."
  bash "$ROOT_DIR/scripts/linux/configure-sudoers.sh"
}

# @cmd wsl : Windows Subsystem for Linux integration
task_wsl() {
  header "Configuring and installing Windows and apps via WSL"
  bash "$ROOT_DIR/scripts/windows/configure-windows.sh" --all
}

# @cmd install : Install packages
task_install() {
  header "Installing packages"
  if is_linux; then
    task_install_linux_packages
  elif is_macos; then
    task_install_casks
  fi
  task_install_formulae
  task_start_services
}

# @cmd configure : Configure settings and apps
task_configure() {
  header "Configuring environment"
  task_stow
  task_configure_links

  if is_macos; then
    task_configure_macos
  elif is_linux; then
    task_configure_linux
    if is_wsl; then
      task_wsl
    fi
  fi
}

# @cmd setup : Install and configure everything (post-bootstrap)
task_setup() {
  task_install
  task_configure
}

# @cmd upgrade : Upgrade packages
task_upgrade() {
  header "Upgrading packages"

  # Update zinit if present
  if command -v zsh &> /dev/null; then
    log "Updating zinit..."
    zsh -ic 'zinit self-update' 2> /dev/null || true
    zsh -ic 'zinit update --all' 2> /dev/null || true
  fi

  if is_macos; then
    if command -v brew &> /dev/null; then
      log "Upgrading Homebrew packages..."
      brew update && brew upgrade
    fi
    if command -v mas &> /dev/null; then
      log "Upgrading Mac App Store apps..."
      mas upgrade
    else
      warn "mas not installed - skipping App Store updates"
    fi
  elif is_linux; then
    log "Upgrading packages..."
    upgrade_packages
    if command -v brew &> /dev/null; then
      log "Upgrading Homebrew packages..."
      brew update && brew upgrade
    fi
  fi
}

# ==============================================================================
# Utility Commands (Restored & Adapted)
# ==============================================================================

# @cmd status : Show system status
cmd_status() {
  header "System Status"

  check_brew || return 1

  # Homebrew formulae
  echo -e "${BOLD}${MAGENTA}Homebrew Formulae:${RESET}"
  if cmd_exists brew; then
    local formulae_count
    formulae_count=$(brew list --formula 2> /dev/null | wc -l | tr -d ' ')
    echo -e "  Installed: ${GREEN}${formulae_count}${RESET} formulae"

    # Check for outdated
    local outdated
    outdated=$(brew outdated --formula 2> /dev/null | wc -l | tr -d ' ')
    if [[ "$outdated" -gt 0 ]]; then
      echo -e "  Outdated:  ${YELLOW}${outdated}${RESET} formulae"
    else
      echo -e "  Outdated:  ${GREEN}0${RESET} (all up to date)"
    fi
  fi
  echo

  # Homebrew casks (macOS only)
  if [[ "$(uname -s)" == "Darwin" ]]; then
    echo -e "${BOLD}${MAGENTA}Homebrew Casks:${RESET}"
    local casks_count
    casks_count=$(brew list --cask 2> /dev/null | wc -l | tr -d ' ')
    echo -e "  Installed: ${GREEN}${casks_count}${RESET} casks"

    local outdated_casks
    outdated_casks=$(brew outdated --cask 2> /dev/null | wc -l | tr -d ' ')
    if [[ "$outdated_casks" -gt 0 ]]; then
      echo -e "  Outdated:  ${YELLOW}${outdated_casks}${RESET} casks"
    else
      echo -e "  Outdated:  ${GREEN}0${RESET} (all up to date)"
    fi
    echo
  fi

  # Homebrew services
  echo -e "${BOLD}${MAGENTA}Homebrew Services:${RESET}"
  if cmd_exists brew; then
    while IFS= read -r line; do
      service=$(echo "$line" | awk '{print $1}')
      svc_status=$(echo "$line" | awk '{print $2}')

      if [[ "$svc_status" == "started" ]]; then
        echo -e "  ${GREEN}‚óè${RESET} ${service} (${GREEN}running${RESET})"
      elif [[ "$svc_status" == "stopped" ]]; then
        echo -e "  ${RED}‚óè${RESET} ${service} (${RED}stopped${RESET})"
      else
        echo -e "  ${YELLOW}‚óè${RESET} ${service} (${YELLOW}${svc_status}${RESET})"
      fi
    done < <(brew services list 2> /dev/null | tail -n +2)
  fi
  echo

  # Symlinks
  echo -e "${BOLD}${MAGENTA}Dotfile Symlinks:${RESET}"
  local symlink_count=0
  local broken_count=0
  local target

  # Count symlinks pointing to ROOT_DIR - simpler approach without nested subshells
  for link in "$HOME"/.* "$HOME"/*; do
    # Skip if not a symlink
    [[ ! -L "$link" ]] && continue

    # Check if it points to ROOT_DIR
    target=$(readlink "$link" 2>/dev/null || true)
    if [[ -z "$target" ]]; then
      continue
    fi

    # Use case statement for glob matching
    case "$target" in
      "$ROOT_DIR"*) ;;
      *) continue ;;
    esac

    ((++symlink_count))
    if [[ ! -e "$link" ]]; then
      ((++broken_count))
    fi
  done

  echo -e "  Total:  ${GREEN}${symlink_count}${RESET} symlinks"
  if [[ "$broken_count" -gt 0 ]]; then
    echo -e "  Broken: ${RED}${broken_count}${RESET} symlinks"
  else
    echo -e "  Broken: ${GREEN}0${RESET} (all valid)"
  fi
  echo

  # Git status
  echo -e "${BOLD}${MAGENTA}Git Repository:${RESET}"
  if [[ -d "${ROOT_DIR}/.git" ]]; then
    pushd "${ROOT_DIR}" > /dev/null
    local branch
    branch=$(git branch --show-current 2> /dev/null || echo "unknown")
    echo -e "  Branch:  ${CYAN}${branch}${RESET}"

    local git_status
    git_status=$(git status --porcelain 2> /dev/null | wc -l | tr -d ' ')
    if [[ "$git_status" -gt 0 ]]; then
      echo -e "  Changes: ${YELLOW}${git_status}${RESET} uncommitted changes"
    else
      echo -e "  Changes: ${GREEN}clean${RESET}"
    fi
    popd > /dev/null
  fi
  echo

  # System info
  echo -e "${BOLD}${MAGENTA}System Information:${RESET}"
  echo -e "  OS:     $(uname -s) $(uname -r)"
  echo -e "  Shell:  ${SHELL} (${ZSH_VERSION:-unknown})"
  echo -e "  Arch:   $(uname -m)"
  echo
}

# @cmd doctor : Run diagnostics
cmd_doctor() {
  header "Running jsh diagnostics"

  local issues=0

  # Check for required commands
  echo -e "${BOLD}Checking required commands...${RESET}"
  local required_cmds=(brew git curl jq vim)
  for cmd in "${required_cmds[@]}"; do
    if cmd_exists "$cmd"; then
      echo -e "  ${GREEN}‚úì${RESET} ${cmd}"
    else
      echo -e "  ${RED}‚úó${RESET} ${cmd} (missing)"
      ((issues++))
    fi
  done
  echo

  # Check for broken symlinks
  echo -e "${BOLD}Checking for broken symlinks...${RESET}"
  local broken_links=()
  while IFS= read -r link; do
    broken_links+=("$link")
  done < <(find "$HOME" -maxdepth 1 -type l ! -exec test -e {} \; -print 2> /dev/null)

  if [[ ${#broken_links[@]} -eq 0 ]]; then
    echo -e "  ${GREEN}‚úì${RESET} No broken symlinks found"
  else
    echo -e "  ${YELLOW}‚ö†${RESET} Found ${#broken_links[@]} broken symlink(s):"
    for link in "${broken_links[@]}"; do
      echo -e "    ${RED}‚Üí${RESET} $link"
      ((issues++))
    done
  fi
  echo

  # Check Git repository status
  echo -e "${BOLD}Checking Git repository...${RESET}"
  if [[ -d "${ROOT_DIR}/.git" ]]; then
    pushd "${ROOT_DIR}" > /dev/null
    if git rev-parse --git-dir > /dev/null 2>&1; then
      echo -e "  ${GREEN}‚úì${RESET} Git repository is valid"
    else
      echo -e "  ${RED}‚úó${RESET} Git repository is corrupted"
      ((issues++))
    fi

    # Check for submodules
    if [[ -f "${ROOT_DIR}/.gitmodules" ]]; then
      if git submodule status | grep -q '^-'; then
        echo -e "  ${YELLOW}‚ö†${RESET} Some submodules are not initialized"
        ((issues++))
      else
        echo -e "  ${GREEN}‚úì${RESET} All submodules initialized"
      fi
    fi
    popd > /dev/null
  else
    echo -e "  ${RED}‚úó${RESET} Not a Git repository"
    ((issues++))
  fi
  echo

  # Check Homebrew health
  if cmd_exists brew; then
    echo -e "${BOLD}Checking Homebrew...${RESET}"
    if brew doctor > /dev/null 2>&1; then
      echo -e "  ${GREEN}‚úì${RESET} Homebrew is healthy"
    else
      echo -e "  ${YELLOW}‚ö†${RESET} Homebrew has warnings (run 'brew doctor' for details)"
    fi
  fi
  echo

  # Summary
  if [[ $issues -eq 0 ]]; then
    success "All checks passed! No issues found."
  else
    warn "Found ${issues} issue(s). Please review the output above."
    return 1
  fi
}

# @cmd backup : Backup configuration
cmd_backup() {
  header "Backing up jsh configuration"

  local backup_dir="${HOME}/.jsh-backups"
  local timestamp
  timestamp=$(date +%Y%m%d_%H%M%S)
  local backup_path="${backup_dir}/jsh_${timestamp}"

  mkdir -p "$backup_dir"

  info "Creating backup at: ${backup_path}"

  # Backup key files
  mkdir -p "${backup_path}"

  # Copy important config files
  local configs=(.jshrc .gitconfig .vimrc .tmux.conf)
  for config in "${configs[@]}"; do
    if [[ -f "${HOME}/${config}" ]]; then
      cp "${HOME}/${config}" "${backup_path}/"
      echo -e "  ${GREEN}‚úì${RESET} Backed up ${config}"
    fi
  done

  # Backup brew packages list
  if cmd_exists brew; then
    brew bundle dump --file="${backup_path}/Brewfile" --force 2> /dev/null
    echo -e "  ${GREEN}‚úì${RESET} Backed up Brewfile"
  fi

  success "Backup created at: ${backup_path}"
}

# @cmd restore : Restore configuration
cmd_restore() {
  header "Restoring jsh configuration"

  local backup_dir="${HOME}/.jsh-backups"

  if [[ ! -d "$backup_dir" ]]; then
    error "No backups found at ${backup_dir}"
    return 1
  fi

  # List available backups
  echo -e "${BOLD}Available backups:${RESET}"
  local backups=()
  while IFS= read -r backup; do
    backups+=("$backup")
    echo -e "  ${CYAN}$(basename "$backup")${RESET}"
  done < <(find "$backup_dir" -maxdepth 1 -type d -name "jsh_*" | sort -r)

  if [[ ${#backups[@]} -eq 0 ]]; then
    error "No backups found"
    return 1
  fi

  echo
  read -r -p "Enter backup name to restore (or 'latest'): " backup_name

  local restore_path
  if [[ "$backup_name" == "latest" ]]; then
    restore_path="${backups[0]}"
  else
    restore_path="${backup_dir}/${backup_name}"
  fi

  if [[ ! -d "$restore_path" ]]; then
    error "Backup not found: ${restore_path}"
    return 1
  fi

  warn "This will overwrite your current configuration!"
  if ! confirm "Continue with restore?"; then
    info "Restore cancelled"
    return 0
  fi

  # Restore files
  for file in "${restore_path}"/*; do
    local filename
    filename=$(basename "$file")
    if [[ "$filename" != "Brewfile" ]]; then
      cp "$file" "${HOME}/${filename}"
      echo -e "  ${GREEN}‚úì${RESET} Restored ${filename}"
    fi
  done

  success "Restore complete from: $(basename "$restore_path")"
}

# @cmd list : List managed packages
cmd_list() {
  header "Managed Packages and Configurations"

  echo -e "${BOLD}${MAGENTA}Managed Formulae (macOS):${RESET}"
  printf '%s\n' "${FORMULAE_MACOS[@]}" | column
  echo
  echo -e "${BOLD}${MAGENTA}Managed Formulae (Linux):${RESET}"
  printf '%s\n' "${FORMULAE_LINUX[@]}" | column
  echo
  echo -e "${BOLD}${MAGENTA}Managed Casks:${RESET}"
  printf '%s\n' "${CASKS[@]}" | column
  echo

  if cmd_exists brew; then
    echo -e "${BOLD}${MAGENTA}Installed Formulae:${RESET}"
    brew list --formula -1 | head -20
    local total
    total=$(brew list --formula 2> /dev/null | wc -l | tr -d ' ')
    if [[ $total -gt 20 ]]; then
      echo -e "  ${YELLOW}... and $((total - 20)) more${RESET}"
    fi
    echo

    if [[ "$(uname -s)" == "Darwin" ]]; then
      echo -e "${BOLD}${MAGENTA}Installed Casks:${RESET}"
      brew list --cask -1 | head -20
      local cask_total
      cask_total=$(brew list --cask 2> /dev/null | wc -l | tr -d ' ')
      if [[ $cask_total -gt 20 ]]; then
        echo -e "  ${YELLOW}... and $((cask_total - 20)) more${RESET}"
      fi
      echo
    fi
  fi

  echo -e "${BOLD}${MAGENTA}Managed Configurations:${RESET}"
  if [[ -d "${ROOT_DIR}/configs" ]]; then
    find "${ROOT_DIR}/configs" -type f ! -path "*/.*" | while IFS= read -r config; do
      echo -e "  ${CYAN}‚Üí${RESET} ${config#${ROOT_DIR}/}"
    done
  fi
}

# @cmd brew : Manage Homebrew
cmd_brew() {
  local subcmd="${1:-help}"
  shift || true

  case "$subcmd" in
    setup)
      "${ROOT_DIR}/scripts/unix/brew.sh" setup
      ;;
    check)
      "${ROOT_DIR}/scripts/unix/brew.sh" check "$@"
      ;;
    help | --help | -h)
      echo -e "${BOLD}${CYAN}jsh brew${RESET} - Homebrew package management"
      echo
      "${ROOT_DIR}/scripts/unix/brew.sh"
      ;;
    *)
      # Pass through to brew
      if ! check_brew; then
        return 1
      fi
      "${ROOT_DIR}/scripts/unix/brew.sh" "$subcmd" "$@"
      ;;
  esac
}

# @cmd completion : Generate completion script
cmd_completion() {
  local src="${SOURCE:-$0}"

  cat << EOF
#compdef jsh

_jsh() {
    local context state state_descr line
    typeset -A opt_args

    _arguments -C \\
        '1: :_jsh_commands' \\
        '*:: :->args'

    case \$state in
        args)
            case \$line[1] in
EOF

  # Generate cases for subcommands
  local prev_parent=""
  grep '^# @cmd' "$src" | sed 's/^# @cmd //' | while read -r line; do
    cmd_part="${line%% :*}"
    if [[ "$cmd_part" == *" "* ]]; then
      parent="${cmd_part%% *}"
      if [[ "$parent" != "$prev_parent" ]]; then
        echo "                $parent)"
        echo "                    _arguments '1: :_jsh_${parent}_commands'"
        echo "                    ;;"
        prev_parent="$parent"
      fi
    fi
  done

  cat << EOF
              *)
                ;;
          esac
          ;;
  esac
}

_jsh_commands() {
    local -a commands
    commands=(
EOF

  # Top level commands
  grep '^# @cmd' "$src" | sed 's/^# @cmd //' | while read -r line; do
    cmd_part="${line%% :*}"
    desc="${line#* : }"
    if [[ "$cmd_part" != *" "* ]]; then
      echo "        '$cmd_part:$desc'"
    fi
  done

  cat << EOF
    )
    _describe -t commands 'jsh command' commands
}
EOF

  # Subcommand functions
  local parents
  parents=$(grep '^# @cmd' "$src" | sed 's/^# @cmd //' | while read -r line; do
    cmd_part="${line%% :*}"
    if [[ "$cmd_part" == *" "* ]]; then
      echo "${cmd_part%% *}"
    fi
  done | sort -u)

  for parent in $parents; do
    echo ""
    echo "_jsh_${parent}_commands() {"
    echo "    local -a commands"
    echo "    commands=("
    grep "^# @cmd $parent " "$src" | sed "s/^# @cmd $parent //" | while read -r line; do
      # Trim leading space if any
      line="${line## }"
      subcmd="${line%% :*}"
      if [[ -z "$subcmd" || "$subcmd" == :* ]]; then continue; fi
      desc="${line#* : }"
      echo "        '$subcmd:$desc'"
    done
    echo "    )"
    echo "    _describe -t commands '$parent command' commands"
    echo "}"
  done

  echo ""
  echo "_jsh"
}

# ==============================================================================
# Main Dispatcher
# ==============================================================================

# @cmd help : Show this help message
show_help() {
  local src="${SOURCE:-$0}"

  echo -e "${BOLD}${CYAN}jsh${RESET} - Dotfiles Management Utility"
  echo ""
  echo -e "${BOLD}USAGE:${RESET}"
  echo "  jsh <command> [options]"
  echo ""
  echo -e "${BOLD}COMMANDS:${RESET}"

  # Parse @cmd comments to generate help dynamically
  local -a parent_cmds

  # Collect and display top-level commands
  while IFS= read -r line; do
    local cmd_part="${line%% :*}"
    local desc="${line#* : }"

    if [[ "$cmd_part" != *" "* ]]; then
      # Top-level command
      printf "  ${GREEN}%-22s${RESET} %s\n" "$cmd_part" "$desc"
    else
      # Track parent for subcommands
      local parent="${cmd_part%% *}"
      if [[ ! " ${parent_cmds[*]} " =~ ${parent} ]]; then
        parent_cmds+=("$parent")
      fi
    fi
  done < <(grep '^# @cmd' "$src" | sed 's/^# @cmd //')

  # Display parent commands with note about subcommands
  for parent in "${parent_cmds[@]}"; do
    local subs=""
    local parent_desc=""

    # Get parent description if it exists
    while IFS= read -r line; do
      local cmd_part="${line%% :*}"
      local desc="${line#* : }"

      if [[ "$cmd_part" == "$parent" ]]; then
        parent_desc="$desc"
      elif [[ "$cmd_part" == "$parent "* ]]; then
        local sub="${cmd_part#* }"
        if [[ -z "$subs" ]]; then
          subs="$sub"
        else
          subs="$subs, $sub"
        fi
      fi
    done < <(grep "^# @cmd $parent" "$src" | sed 's/^# @cmd //')

    if [[ -n "$subs" ]]; then
      printf "  ${GREEN}%-22s${RESET} %s (subcommands: %s)\n" "$parent" "$parent_desc" "$subs"
    fi
  done

  echo ""
}

# Check for help flag only when no command is provided or explicit help command
if [[ $# -eq 0 ]] || [[ "$1" == "help" || "$1" == "--help" || "$1" == "-h" ]]; then
  show_help
  exit 0
fi

COMMAND="$1"
shift

case "$COMMAND" in
  bootstrap | init) task_bootstrap "$@" ;;
  setup) task_setup "$@" ;;
  install) task_install "$@" ;;
  configure) task_configure "$@" ;;
  clean | cleanup) task_clean "$@" ;;
  stow | link) task_stow "$@" ;;
  unstow | unlink) task_unstow "$@" ;;
  uninstall) task_uninstall "$@" ;;
  upgrade | update) task_upgrade "$@" ;;
  status) cmd_status "$@" ;;
  doctor | check) cmd_doctor "$@" ;;
  backup) cmd_backup "$@" ;;
  restore) cmd_restore "$@" ;;
  list | ls) cmd_list "$@" ;;
  brew) cmd_brew "$@" ;;
  wsl) task_wsl "$@" ;;
  completion) cmd_completion ;;
  help | --help | -h) show_help ;;
  *) error "Unknown command: $COMMAND" ;;
esac
