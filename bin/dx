#!/usr/bin/env bash

# Docker Context Manager - Multi-host Docker management tool
# Manages and monitors Docker containers across multiple contexts

set -euo pipefail

# Colors for output
BLUE='\033[0;34m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
CYAN='\033[0;36m'
DIM='\033[2m'
NC='\033[0m' # No Color

# Configuration file location
CONFIG_FILE="${HOME}/.jsh/configs/docker/contexts.json"

# Print colored messages
print_info() {
    echo -e "${BLUE}$1${NC}"
}

print_success() {
    echo -e "${GREEN}$1${NC}"
}

print_warning() {
    echo -e "${YELLOW}$1${NC}"
}

print_error() {
    echo -e "${RED}$1${NC}"
}

print_dim() {
    echo -e "${DIM}$1${NC}"
}

# Check if jq is available
check_jq() {
    if ! command -v jq >/dev/null 2>&1; then
        print_error "Error: jq is required but not installed"
        echo "Install with: brew install jq (macOS) or apt install jq (Linux)"
        exit 1
    fi
}

# Check if config file exists
check_config() {
    if [[ ! -f "${CONFIG_FILE}" ]]; then
        print_error "Error: Configuration file not found: ${CONFIG_FILE}"
        echo "Creating default configuration..."
        mkdir -p "$(dirname "${CONFIG_FILE}")"
        echo '{"contexts":{}}' > "${CONFIG_FILE}"
        print_success "Created empty configuration file"
    fi
}

# Get all context names
get_context_names() {
    check_jq
    check_config
    jq -r '.contexts | keys[]' "${CONFIG_FILE}" 2>/dev/null || true
}

# Get context property
get_context_prop() {
    local context="$1"
    local prop="$2"
    check_jq
    check_config
    jq -r ".contexts[\"${context}\"].${prop} // empty" "${CONFIG_FILE}" 2>/dev/null || echo ""
}

# Check if context exists
context_exists() {
    local context="$1"
    local exists
    exists=$(jq -r ".contexts | has(\"${context}\")" "${CONFIG_FILE}" 2>/dev/null || echo "false")
    [[ "${exists}" = "true" ]]
}

# Test context connectivity
test_context_connectivity() {
    local context="$1"
    local host
    host=$(get_context_prop "${context}" "host")

    if [[ -z "${host}" ]]; then
        return 1
    fi

    # Start timing (use gdate if available for milliseconds, otherwise use seconds)
    local start_time
    if command -v gdate >/dev/null 2>&1; then
        start_time=$(gdate +%s%3N)
    else
        start_time=$(($(date +%s) * 1000))
    fi

    # Extract connection type and details
    if [[ "${host}" =~ ^ssh:// ]]; then
        # SSH connection
        local ssh_target="${host#ssh://}"

        # Test SSH connection with timeout
        if timeout 5 ssh -o ConnectTimeout=5 -o BatchMode=yes -o StrictHostKeyChecking=accept-new "${ssh_target}" "docker version >/dev/null 2>&1" >/dev/null 2>&1; then
            local end_time
            if command -v gdate >/dev/null 2>&1; then
                end_time=$(gdate +%s%3N)
            else
                end_time=$(($(date +%s) * 1000))
            fi
            local elapsed=$((end_time - start_time))
            echo "${elapsed}"
            return 0
        else
            return 1
        fi
    elif [[ "${host}" =~ ^unix:// ]]; then
        # Unix socket connection - use default docker command
        # Most setups (OrbStack, Docker Desktop) already configure docker to use the right socket
        if timeout 5 docker version >/dev/null 2>&1; then
            local end_time
            if command -v gdate >/dev/null 2>&1; then
                end_time=$(gdate +%s%3N)
            else
                end_time=$(($(date +%s) * 1000))
            fi
            local elapsed=$((end_time - start_time))
            echo "${elapsed}"
            return 0
        else
            return 1
        fi
    else
        # Try as-is with timeout
        if timeout 5 docker -H "${host}" version >/dev/null 2>&1; then
            local end_time
            if command -v gdate >/dev/null 2>&1; then
                end_time=$(gdate +%s%3N)
            else
                end_time=$(($(date +%s) * 1000))
            fi
            local elapsed=$((end_time - start_time))
            echo "${elapsed}"
            return 0
        else
            return 1
        fi
    fi
}

# List all contexts
list_contexts() {
    check_jq
    check_config

    print_info "Configured Docker Contexts:"
    echo ""
    printf "%-20s %-10s %-30s %-s\n" "NAME" "STATUS" "TAGS" "HOST"
    printf "%.100s\n" "===================================================================================================="

    local contexts
    mapfile -t contexts < <(get_context_names)

    if [[ ${#contexts[@]} -eq 0 ]]; then
        print_warning "No contexts configured"
        echo ""
        echo "Add a context with: dx context add <name>"
        return 0
    fi

    for context in "${contexts[@]}"; do
        [[ -z "${context}" ]] && continue

        local host
        local enabled
        local tags
        local status_icon
        local status_color

        host=$(get_context_prop "${context}" "host")
        enabled=$(get_context_prop "${context}" "enabled")
        tags=$(jq -r ".contexts[\"${context}\"].tags // [] | join(\",\")" "${CONFIG_FILE}" 2>/dev/null || echo "")

        if [[ "${enabled}" = "false" ]]; then
            status_icon="○ disabled"
            status_color="${DIM}"
        else
            # Test connectivity
            if test_context_connectivity "${context}" >/dev/null 2>&1; then
                status_icon="● active"
                status_color="${GREEN}"
            else
                status_icon="✗ offline"
                status_color="${RED}"
            fi
        fi

        printf "${status_color}%-20s %-10s${NC} %-30s %s\n" \
            "${context}" "${status_icon}" "${tags}" "${host}"
    done

    echo ""
}

# Add new context
add_context() {
    local context_name="$1"

    check_jq
    check_config

    if [[ -z "${context_name}" ]]; then
        print_error "Error: Context name required"
        echo "Usage: dx context add <name>"
        return 1
    fi

    if context_exists "${context_name}"; then
        print_error "Error: Context '${context_name}' already exists"
        return 1
    fi

    # Interactive prompts
    echo ""
    print_info "Adding new context: ${context_name}"
    echo ""

    # Get host
    read -rp "Docker host (e.g., ssh://user@host or unix:///var/run/docker.sock): " host
    if [[ -z "${host}" ]]; then
        print_error "Error: Host is required"
        return 1
    fi

    # Get description
    read -rp "Description (optional): " description

    # Get tags
    read -rp "Tags (comma-separated, optional): " tags_input
    local tags_json="[]"
    if [[ -n "${tags_input}" ]]; then
        # Convert comma-separated to JSON array
        tags_json=$(echo "${tags_input}" | jq -R 'split(",") | map(gsub("^\\s+|\\s+$";""))')
    fi

    # Add to config
    local new_context
    new_context=$(jq -n \
        --arg host "${host}" \
        --arg desc "${description}" \
        --argjson tags "${tags_json}" \
        '{host: $host, description: $desc, tags: $tags, enabled: true}')

    jq ".contexts[\"${context_name}\"] = ${new_context}" "${CONFIG_FILE}" > "${CONFIG_FILE}.tmp" && \
        mv "${CONFIG_FILE}.tmp" "${CONFIG_FILE}"

    echo ""
    print_success "✓ Context '${context_name}' added successfully"

    # Test connectivity
    echo ""
    print_info "Testing connectivity..."
    if elapsed=$(test_context_connectivity "${context_name}" 2>&1); then
        print_success "✓ Connection successful (${elapsed}ms)"
    else
        print_warning "⚠ Connection failed - please check your configuration"
    fi
    echo ""
}

# Remove context
remove_context() {
    local context_name="$1"

    check_jq
    check_config

    if [[ -z "${context_name}" ]]; then
        print_error "Error: Context name required"
        echo "Usage: dx context remove <name>"
        return 1
    fi

    if ! context_exists "${context_name}"; then
        print_error "Error: Context '${context_name}' not found"
        return 1
    fi

    # Confirm removal
    read -rp "Remove context '${context_name}'? [y/N] " -n 1
    echo ""

    if [[ ! ${REPLY} =~ ^[Yy]$ ]]; then
        print_info "Cancelled"
        return 0
    fi

    # Remove from config
    jq "del(.contexts[\"${context_name}\"])" "${CONFIG_FILE}" > "${CONFIG_FILE}.tmp" && \
        mv "${CONFIG_FILE}.tmp" "${CONFIG_FILE}"

    print_success "✓ Context '${context_name}' removed"
}

# Test context
test_context() {
    local context_name="$1"

    if [[ -z "${context_name}" ]]; then
        print_error "Error: Context name required"
        echo "Usage: dx context test <name>"
        return 1
    fi

    if ! context_exists "${context_name}"; then
        print_error "Error: Context '${context_name}' not found"
        return 1
    fi

    local host
    host=$(get_context_prop "${context_name}" "host")

    echo ""
    print_info "Testing context: ${context_name}"
    print_dim "Host: ${host}"
    echo ""

    if elapsed=$(test_context_connectivity "${context_name}" 2>&1); then
        print_success "✓ Connection successful (${elapsed}ms)"

        # Try to get Docker version
        if [[ "${host}" =~ ^ssh:// ]]; then
            local ssh_target="${host#ssh://}"
            local docker_version
            docker_version=$(timeout 5 ssh -o ConnectTimeout=5 -o BatchMode=yes "${ssh_target}" "docker version --format '{{.Server.Version}}'" 2>/dev/null || echo "unknown")
            print_dim "Docker version: ${docker_version}"
        elif [[ "${host}" =~ ^unix:// ]]; then
            local docker_version
            docker_version=$(docker -H "${host}" version --format '{{.Server.Version}}' 2>/dev/null || echo "unknown")
            print_dim "Docker version: ${docker_version}"
        fi
    else
        print_error "✗ Connection failed"
        echo ""
        echo "Troubleshooting:"
        if [[ "${host}" =~ ^ssh:// ]]; then
            echo "  - Verify SSH access to the host"
            echo "  - Ensure Docker is installed and running on remote host"
            echo "  - Check that remote user has Docker permissions"
        else
            echo "  - Verify Docker daemon is running"
            echo "  - Check host path/socket exists"
        fi
        return 1
    fi
    echo ""
}

# Enable/disable context
toggle_context() {
    local context_name="$1"
    local action="$2"

    check_jq
    check_config

    if [[ -z "${context_name}" ]] || [[ -z "${action}" ]]; then
        print_error "Error: Context name and action required"
        return 1
    fi

    if ! context_exists "${context_name}"; then
        print_error "Error: Context '${context_name}' not found"
        return 1
    fi

    local enabled="true"
    [[ "${action}" = "disable" ]] && enabled="false"

    jq ".contexts[\"${context_name}\"].enabled = ${enabled}" "${CONFIG_FILE}" > "${CONFIG_FILE}.tmp" && \
        mv "${CONFIG_FILE}.tmp" "${CONFIG_FILE}"

    print_success "✓ Context '${context_name}' ${action}d"
}

# Run docker compose ps across contexts
run_ps() {
    local filter_tag="$1"

    check_jq
    check_config

    echo ""
    echo -e "${BLUE}╭──────────────────────────────────────────────────╮${NC}"
    echo -e "${BLUE}│ Docker Multi-Context Status                      │${NC}"
    echo -e "${BLUE}╰──────────────────────────────────────────────────╯${NC}"
    echo ""

    local contexts
    mapfile -t contexts < <(get_context_names)

    if [[ ${#contexts[@]} -eq 0 ]]; then
        print_warning "No contexts configured"
        return 0
    fi

    local total_contexts=0
    local available_contexts=0
    local total_containers=0

    for context in "${contexts[@]}"; do
        [[ -z "${context}" ]] && continue

        local enabled
        enabled=$(get_context_prop "${context}" "enabled")

        # Skip disabled contexts
        if [[ "${enabled}" = "false" ]]; then
            continue
        fi

        # Filter by tag if specified
        if [[ -n "${filter_tag}" ]]; then
            local context_tags
            context_tags=$(jq -r ".contexts[\"${context}\"].tags // [] | join(\",\")" "${CONFIG_FILE}" 2>/dev/null || echo "")
            if [[ ! ",${context_tags}," =~ ,${filter_tag}, ]]; then
                continue
            fi
        fi

        total_contexts=$((total_contexts + 1))

        local host
        local description
        local compose_path
        host=$(get_context_prop "${context}" "host")
        description=$(get_context_prop "${context}" "description")
        compose_path=$(get_context_prop "${context}" "compose_path")

        # Default to home directory if not specified
        if [[ -z "${compose_path}" ]]; then
            compose_path="~"
        fi

        echo -e "${CYAN}[${context}]${NC} ${description} ${DIM}(${host})${NC}"

        # Test connectivity
        if elapsed=$(test_context_connectivity "${context}" 2>&1); then
            echo -e "  ${GREEN}✓${NC} Connected (${elapsed}ms)"
            available_contexts=$((available_contexts + 1))

            # Run docker compose ps
            local compose_output
            if [[ "${host}" =~ ^ssh:// ]]; then
                local ssh_target="${host#ssh://}"
                compose_output=$(timeout 10 ssh -o ConnectTimeout=5 -o BatchMode=yes "${ssh_target}" \
                    "cd ${compose_path} && docker compose ps --format '{{.Service}}\t{{.State}}\t{{.Health}}\t{{.Status}}'" 2>/dev/null || echo "")
            else
                compose_output=$(docker -H "${host}" compose -f "${compose_path}/docker-compose.yml" ps --format '{{.Service}}\t{{.State}}\t{{.Health}}\t{{.Status}}' 2>/dev/null || echo "")
            fi

            if [[ -n "${compose_output}" ]]; then
                # Parse and format output
                echo "${compose_output}" | while IFS=$'\t' read -r service state health status; do
                    if [[ -n "${service}" ]]; then
                        total_containers=$((total_containers + 1))

                        # Color code based on state
                        local state_color="${RED}"
                        local state_display="Down"
                        if [[ "${state}" = "running" ]]; then
                            state_color="${GREEN}"
                            state_display="Up"
                        elif [[ "${state}" = "restarting" ]]; then
                            state_color="${YELLOW}"
                            state_display="Rstr"
                        fi

                        # Health display
                        local health_display="-"
                        local health_color="${NC}"
                        if [[ "${health}" = "healthy" ]]; then
                            health_display="ok"
                            health_color="${GREEN}"
                        elif [[ "${health}" = "unhealthy" ]]; then
                            health_display="!!"
                            health_color="${RED}"
                        elif [[ "${health}" = "starting" ]]; then
                            health_display=".."
                            health_color="${YELLOW}"
                        fi

                        # Parse uptime
                        local uptime="-"
                        if [[ "${status}" =~ Up\ ([0-9]+)\ second ]]; then
                            uptime="${BASH_REMATCH[1]}s"
                        elif [[ "${status}" =~ Up\ ([0-9]+)\ minute ]]; then
                            uptime="${BASH_REMATCH[1]}m"
                        elif [[ "${status}" =~ Up\ ([0-9]+)\ hour ]]; then
                            uptime="${BASH_REMATCH[1]}h"
                        elif [[ "${status}" =~ Up\ ([0-9]+)\ day ]]; then
                            uptime="${BASH_REMATCH[1]}d"
                        elif [[ "${status}" =~ Up\ ([0-9]+)\ week ]]; then
                            uptime="${BASH_REMATCH[1]}w"
                        fi

                        printf "  %-25s ${state_color}%-4s${NC} ${health_color}%-2s${NC} %-6s\n" \
                            "${service}" "${state_display}" "${health_display}" "${uptime}"
                    fi
                done
            else
                print_dim "  No containers found"
            fi
        else
            echo -e "  ${RED}✗${NC} Connection failed"
        fi

        echo ""
    done

    if [[ "$total_contexts" -eq 0 ]]; then
        print_warning "No matching contexts found"
        if [[ -n "${filter_tag}" ]]; then
            echo "Filter: ${filter_tag}"
        fi
        return 0
    fi

    echo -e "${DIM}Summary: ${available_contexts}/${total_contexts} contexts available${NC}"
    echo ""
}

# Run arbitrary command across contexts
run_exec() {
    local filter_tag=""
    local command=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --filter)
                filter_tag="$2"
                shift 2
                ;;
            *)
                command="$1"
                shift
                ;;
        esac
    done

    if [[ -z "${command}" ]]; then
        print_error "Error: Command required"
        echo "Usage: dx exec [--filter TAG] <command>"
        return 1
    fi

    check_jq
    check_config

    echo ""
    print_info "Executing across contexts: ${command}"
    if [[ -n "${filter_tag}" ]]; then
        print_dim "Filter: ${filter_tag}"
    fi
    echo ""

    local contexts
    mapfile -t contexts < <(get_context_names)

    for context in "${contexts[@]}"; do
        [[ -z "${context}" ]] && continue

        local enabled
        enabled=$(get_context_prop "${context}" "enabled")

        if [[ "${enabled}" = "false" ]]; then
            continue
        fi

        # Filter by tag
        if [[ -n "${filter_tag}" ]]; then
            local context_tags
            context_tags=$(jq -r ".contexts[\"${context}\"].tags // [] | join(\",\")" "${CONFIG_FILE}" 2>/dev/null || echo "")
            if [[ ! ",${context_tags}," =~ ,${filter_tag}, ]]; then
                continue
            fi
        fi

        local host
        host=$(get_context_prop "${context}" "host")

        echo -e "${CYAN}[${context}]${NC} ${DIM}(${host})${NC}"

        # Execute command
        if [[ "${host}" =~ ^ssh:// ]]; then
            local ssh_target="${host#ssh://}"
            timeout 10 ssh -o ConnectTimeout=5 -o BatchMode=yes "${ssh_target}" "${command}" 2>&1 || print_error "  Command failed"
        else
            docker -H "${host}" "$command" 2>&1 || print_error "  Command failed"
        fi

        echo ""
    done
}

# Show help
show_help() {
    cat << 'EOF'
Docker Context Manager - Multi-host Docker management

Usage: dx <command> [options] [arguments]

CONTEXT MANAGEMENT:
  contexts                  List all configured contexts
  context add <name>        Add new context (interactive)
  context remove <name>     Remove context
  context test <name>       Test context connectivity
  context enable <name>     Enable context
  context disable <name>    Disable context

MULTI-CONTEXT OPERATIONS:
  ps [--filter TAG]         Run docker compose ps across contexts
  exec [--filter TAG] CMD   Execute docker command across contexts
  status [--filter TAG]     Show aggregated status (alias for ps)

OPTIONS:
  --filter TAG              Filter contexts by tag

EXAMPLES:
  dx contexts               List all contexts
  dx context add prod-web   Add production web server context
  dx context test prod-web  Test connection to prod-web
  dx ps                     Show all containers across all contexts
  dx ps --filter production Show containers on production contexts
  dx exec "docker system df"                Run command across all contexts
  dx exec --filter local "docker ps -a"     Run command on local contexts

CONFIGURATION:
  Config file: ~/.jsh/configs/docker/contexts.json

  Context structure:
    {
      "host": "ssh://user@host or unix:///var/run/docker.sock",
      "description": "Human readable description",
      "tags": ["tag1", "tag2"],
      "enabled": true,
      "compose_path": "/path/to/compose/directory"
    }

  Fields:
    - host: Docker connection endpoint (required)
    - description: Human-readable description (optional)
    - tags: Array of tags for filtering (optional)
    - enabled: Enable/disable context (default: true)
    - compose_path: Working directory for docker compose commands (default: ~)

SSH REQUIREMENTS:
  - SSH key-based authentication (no passwords)
  - Remote user must have Docker permissions
  - Docker daemon must be running on remote host

For more information, see: https://github.com/jovalle/jsh
EOF
}

# Show version
show_version() {
    echo "Docker Context Manager (dx) v1.0.0"
}

# Main command dispatcher
main() {
    local command="${1:-help}"
    shift || true

    case "${command}" in
        contexts|ctx|ls)
            list_contexts
            ;;
        context)
            local subcommand="${1:-}"
            shift || true

            case "${subcommand}" in
                add)
                    add_context "$@"
                    ;;
                remove|rm|delete)
                    remove_context "$@"
                    ;;
                test)
                    test_context "$@"
                    ;;
                enable)
                    toggle_context "$1" "enable"
                    ;;
                disable)
                    toggle_context "$1" "disable"
                    ;;
                *)
                    print_error "Unknown context subcommand: ${subcommand}"
                    echo ""
                    echo "Available subcommands: add, remove, test, enable, disable"
                    exit 1
                    ;;
            esac
            ;;
        ps|status)
            local filter_tag=""
            if [[ "${1:-}" == "--filter" ]]; then
                filter_tag="$2"
            fi
            run_ps "${filter_tag}"
            ;;
        exec|run)
            run_exec "$@"
            ;;
        help|--help|-h)
            show_help
            ;;
        version|--version|-v)
            show_version
            ;;
        *)
            print_error "Unknown command: ${command}"
            echo ""
            echo "Run 'dx help' for usage information"
            exit 1
            ;;
    esac
}

# Run main function
main "$@"
