#!/usr/bin/env bash
# @name jgit
# @version 1.0.0
# @desc Git project and repository management (jsh flavor)
# @usage jgit [command] [args...]
#
# @cmd (none)              In repo: detailed view | Not in repo: list all
# @cmd update              Safe pull: stash → rebase → apply
# @cmd profile             Show/apply git identity profiles (leak check)
# @cmd list                List all projects with status
# @cmd path <name>         Output path for shell cd wrapper
# @cmd commit              Identity-enforced commit (requires profile)
# @cmd push                Push commits (use -i for interactive)
# @cmd backup              Manage jgit backup refs
# @cmd <other>             Passthrough to git
#
# @sub profile:list        List all profiles with key/signing info
# @sub profile:<name>      Apply profile to current repo
# @sub profile:migrate     Migrate ssh_host → ssh_key
# @sub backup:list         List backup refs
# @sub backup:restore      Restore from backup ref
#
# @option -i,--interactive  Enable interactive mode (commit, push)
# @option -v,--verbose      Verbose output (for list command)
# @option -h,--help         Show this help message
#
# @example jgit
# @example jgit update
# @example jgit profile work
# @example jgit list -v
# @example jgit commit -i
#
# shellcheck shell=bash
#
# Note: Use 'project' wrapper for add/create commands (enables auto-cd):
#   project add <url>       Clone repo and cd into it
#   project create <name>   Create project and cd into it

[[ -n $DEBUG ]] && set -x

set -eou pipefail
IFS=$'\n\t'

# =============================================================================
# Configuration
# =============================================================================

JSH_DIR="${JSH_DIR:-${HOME}/.jsh}"
JSH_PROFILES="${JSH_PROFILES:-${JSH_DIR}/local/profiles.json}"
_PROJECTS_DEFAULT_PATHS="${HOME}/.jsh,${HOME}/projects/*"

# =============================================================================
# Dependencies
# =============================================================================

# Source CLI framework (provides help generation and colors)
source "${0%/*}/../lib/cli.sh" 2>/dev/null || source "${JSH_DIR:-$HOME/.jsh}/lib/cli.sh"

# =============================================================================
# Colors (override cli.sh with proper ANSI escapes for this script)
# =============================================================================
# cli.sh provides colors but we need $'\033[...' escape sequences for printf

if [[ -t 1 ]] && [[ "${NO_COLOR:-}" != "1" ]] && [[ "${TERM:-}" != "dumb" ]]; then
    C_CYAN=$'\033[36m'
    C_GREEN=$'\033[32m'
    C_YELLOW=$'\033[33m'
    C_RED=$'\033[31m'
    C_BLUE=$'\033[34m'
    C_BOLD=$'\033[1m'
    C_DIM=$'\033[2m'
    C_RESET=$'\033[0m'
else
    C_CYAN='' C_GREEN='' C_YELLOW='' C_RED=''
    C_BLUE='' C_BOLD='' C_DIM='' C_RESET=''
fi

abort() {
    error "$*"
    exit 1
}

# Portable lowercase conversion
_lowercase() {
    printf '%s' "$1" | tr '[:upper:]' '[:lower:]'
}

# =============================================================================
# Profile Helpers (reads from local/profiles.json)
# =============================================================================

# Get profile data by name
_profiles_get() {
    local name="$1"
    [[ -f "$JSH_PROFILES" ]] || return 1

    # Use jq for JSON, yq for YAML
    if [[ "$JSH_PROFILES" == *.json ]] && command -v jq &>/dev/null; then
        jq -r --arg name "$name" '.profiles[$name] // empty' "$JSH_PROFILES" 2>/dev/null
    elif command -v yq &>/dev/null; then
        # shellcheck disable=SC2016 # $name is yq variable substitution, not bash
        yq -r --arg name "$name" '.profiles[$name] // empty' "$JSH_PROFILES" 2>/dev/null
    else
        return 1
    fi
}

# List all profile names
_profiles_list() {
    [[ -f "$JSH_PROFILES" ]] || return 0

    # Use jq for JSON, yq for YAML
    if [[ "$JSH_PROFILES" == *.json ]] && command -v jq &>/dev/null; then
        jq -r '.profiles | keys[]' "$JSH_PROFILES" 2>/dev/null
    elif command -v yq &>/dev/null; then
        yq -r '.profiles | keys | .[]' "$JSH_PROFILES" 2>/dev/null
    fi
}

# Check if profile exists
_profiles_exists() {
    local name="$1"
    local result
    result="$(_profiles_get "$name")"
    [[ -n "$result" ]]
}

# Parse profile field from JSON data
_profile_field() {
    local data="$1"
    local field="$2"

    # Data comes from _profiles_get which returns JSON
    if command -v jq &>/dev/null; then
        printf '%s' "$data" | jq -r ".${field} // empty"
    elif command -v yq &>/dev/null; then
        printf '%s' "$data" | yq -r ".${field} // empty"
    fi
}

# Validate profile has all required fields and resources exist
# Returns 0 if valid, 1 if invalid (prints error to stderr)
_profile_validate() {
    local profile_name="$1"
    local profile_data="$2"

    local required_fields=("name" "email" "user" "ssh_key")
    local field value

    for field in "${required_fields[@]}"; do
        value=$(_profile_field "$profile_data" "$field")
        if [[ -z "$value" ]]; then
            error "Profile '${profile_name}' missing required field: ${field}"
            return 1
        fi
    done

    # Validate ssh_key file exists (expand ~)
    local ssh_key
    ssh_key=$(_profile_field "$profile_data" "ssh_key")
    ssh_key="${ssh_key/#\~/${HOME}}"
    if [[ ! -f "$ssh_key" ]]; then
        error "SSH key not found: $ssh_key (profile: ${profile_name})"
        return 1
    fi

    return 0
}

# Expand ~ in a path
_expand_tilde() {
    local path="$1"
    printf '%s' "${path/#\~/${HOME}}"
}

# =============================================================================
# SSH Helpers
# =============================================================================

# Check if an SSH host alias exists in ~/.ssh/config
_ssh_host_exists() {
    local host="$1"
    local ssh_config="${HOME}/.ssh/config"

    [[ -f "$ssh_config" ]] || return 1
    grep -qiE "^[[:space:]]*Host[[:space:]]+(.*[[:space:]])?${host}([[:space:]]|$)" "$ssh_config"
}

# Derive SSH host alias from platform host and user
# Convention: <platform>-<user>
_ssh_derive_host() {
    local platform_host="$1"
    local user="$2"

    local platform
    platform="${platform_host%.com}"
    platform="${platform%.org}"
    platform="${platform%.io}"
    platform="${platform//./-}"

    printf '%s-%s' "$platform" "$user"
}

# Parse a git URL and extract components
# Output: platform|owner|repo (pipe-separated)
_git_parse_url() {
    local url="$1"
    local platform="" owner="" repo=""

    if [[ "$url" == git@* ]]; then
        local host_part="${url#git@}"
        host_part="${host_part%%:*}"
        local path_part="${url#*:}"

        if [[ "$host_part" == *.* ]]; then
            platform="$host_part"
        else
            platform="$host_part"
        fi

        owner="${path_part%%/*}"
        repo="${path_part#*/}"
        repo="${repo%.git}"

    elif [[ "$url" == https://* ]]; then
        local host_part="${url#https://}"
        platform="${host_part%%/*}"
        local path_part="${host_part#*/}"
        owner="${path_part%%/*}"
        repo="${path_part#*/}"
        repo="${repo%.git}"

    elif [[ "$url" == ssh://* ]]; then
        local host_part="${url#ssh://git@}"
        platform="${host_part%%/*}"
        local path_part="${host_part#*/}"
        owner="${path_part%%/*}"
        repo="${path_part#*/}"
        repo="${repo%.git}"

    elif [[ "$url" == */* ]] && [[ "$url" != *:* ]] && [[ "$url" != *.* ]]; then
        # Shorthand format: owner/repo (assume github.com)
        platform="github.com"
        owner="${url%%/*}"
        repo="${url#*/}"
        repo="${repo%.git}"
    fi

    printf '%s|%s|%s' "$platform" "$owner" "$repo"
}

# Find profile matching a git URL owner
_profile_find_by_user() {
    local target_user="$1"

    while IFS= read -r profile_name; do
        [[ -z "$profile_name" ]] && continue
        local profile_data profile_user
        profile_data="$(_profiles_get "$profile_name")"
        profile_user=$(_profile_field "$profile_data" "user")

        if [[ "$profile_user" == "$target_user" ]]; then
            printf '%s\n' "$profile_name"
            return 0
        fi
    done < <(_profiles_list)

    return 1
}

# Get SSH host for a profile (explicit or derived)
_profile_ssh_host() {
    local profile_name="$1"
    local fallback_platform="${2:-github.com}"

    local profile_data ssh_host host user
    profile_data="$(_profiles_get "$profile_name")"
    ssh_host=$(_profile_field "$profile_data" "ssh_host")
    host=$(_profile_field "$profile_data" "host")
    user=$(_profile_field "$profile_data" "user")

    if [[ -n "$ssh_host" ]]; then
        printf '%s' "$ssh_host"
        return 0
    fi

    local platform="${host:-$fallback_platform}"
    if [[ -n "$user" ]]; then
        _ssh_derive_host "$platform" "$user"
        return 0
    fi

    return 1
}

# =============================================================================
# Path Helpers
# =============================================================================

# Expand a path pattern to actual directories
_expand_path() {
    local pattern="$1"
    pattern="${pattern/#\~/${HOME}}"

    if [[ "${pattern}" == *"*"* ]]; then
        # Enable globbing (may be disabled by caller) and nullglob for expansion
        set +f
        shopt -s nullglob
        for expanded in ${pattern}; do
            [[ -d "${expanded}" ]] && printf '%s\n' "${expanded}"
        done
        shopt -u nullglob
    else
        [[ -d "${pattern}" ]] && printf '%s\n' "${pattern}"
    fi
}

# Get all project directories
_projects_get_all() {
    local paths="${JSH_PROJECTS:-${_PROJECTS_DEFAULT_PATHS}}"
    local IFS=','

    # Disable glob expansion so patterns aren't expanded before _expand_path
    set -f
    for entry in ${paths}; do
        entry="${entry#"${entry%%[![:space:]]*}"}"
        entry="${entry%"${entry##*[![:space:]]}"}"

        while IFS= read -r dir; do
            [[ -n "$dir" ]] && printf '%s\n' "${dir}"
        done < <(_expand_path "${entry}")
    done
    set +f
}

# Get display name for a project (shortened path)
_projects_display_name() {
    local path="$1"
    if [[ "${path}" == "${HOME}"* ]]; then
        printf '%s\n' "~${path#"$HOME"}"
    else
        printf '%s\n' "${path}"
    fi
}

# Get default projects directory for new projects
# Note: JSH_DIR is excluded - it's the config directory, not for user projects
_projects_default_dir() {
    local paths="${JSH_PROJECTS:-${_PROJECTS_DEFAULT_PATHS}}"
    local IFS=','
    local fallback=""
    local jsh_dir="${JSH_DIR:-${HOME}/.jsh}"

    # Disable glob expansion so ~/projects/* doesn't expand prematurely
    set -f
    for entry in ${paths}; do
        entry="${entry#"${entry%%[![:space:]]*}"}"
        entry="${entry%"${entry##*[![:space:]]}"}"
        entry="${entry/#\~/${HOME}}"

        # Skip JSH_DIR - it's for jsh config, not user projects
        [[ "${entry}" == "${jsh_dir}" ]] && continue

        if [[ "${entry}" == *"*"* ]]; then
            entry="${entry%/\*}"
            entry="${entry%\*}"
            if [[ -d "${entry}" ]]; then
                printf '%s\n' "${entry}"
                return 0
            fi
        elif [[ -z "${fallback}" ]] && [[ -d "${entry}" ]]; then
            fallback="${entry}"
        fi
    done

    set +f  # Re-enable glob expansion

    if [[ -n "${fallback}" ]]; then
        printf '%s\n' "${fallback}"
    else
        printf '%s\n' "${HOME}/projects"
    fi
}

# Extract project name from git URL
_projects_name_from_url() {
    local url="$1"
    local name
    name="${url%.git}"
    name="${name##*/}"
    name="${name##*:}"
    name="${name##*/}"
    printf '%s\n' "${name}"
}

# =============================================================================
# Git Helpers
# =============================================================================

# Get git status summary (compact format)
_git_status_summary() {
    local dir="${1:-.}"
    local staged unstaged untracked parts=()

    staged=$(git -C "$dir" diff --cached --numstat 2>/dev/null | wc -l | tr -d ' ')
    unstaged=$(git -C "$dir" diff --numstat 2>/dev/null | wc -l | tr -d ' ')
    untracked=$(git -C "$dir" ls-files --others --exclude-standard 2>/dev/null | wc -l | tr -d ' ')

    [[ "$staged" -gt 0 ]] && parts+=("${C_GREEN}+${staged}${C_RESET} staged")
    [[ "$unstaged" -gt 0 ]] && parts+=("${C_YELLOW}*${unstaged}${C_RESET} modified")
    [[ "$untracked" -gt 0 ]] && parts+=("${C_RED}?${untracked}${C_RESET} untracked")

    if [[ ${#parts[@]} -eq 0 ]]; then
        printf '%s\n' "${C_DIM}clean${C_RESET}"
    else
        local IFS=', '
        printf '%s\n' "${parts[*]}"
    fi
}

# Get last commit info
_git_last_commit() {
    local dir="${1:-.}"
    local format="${2:-%cr · %s}"
    git -C "$dir" log -1 --format="$format" 2>/dev/null
}

# Get submodule status
_git_submodules() {
    local dir="${1:-.}"
    git -C "$dir" submodule status 2>/dev/null | while read -r line; do
        local status="${line:0:1}"
        local sha="${line:1:7}"
        local path="${line#* }"
        path="${path%% *}"

        case "$status" in
            '-') printf '  %s%s%s @ %s (not initialized)\n' "$C_DIM" "$path" "$C_RESET" "$sha" ;;
            '+') printf '  %s%s%s @ %s (dirty)\n' "$C_YELLOW" "$path" "$C_RESET" "$sha" ;;
            'U') printf '  %s%s%s @ %s (conflict)\n' "$C_RED" "$path" "$C_RESET" "$sha" ;;
            *)   printf '  %s @ %s\n' "$path" "$sha" ;;
        esac
    done
}

# Get upstream status (ahead/behind)
_git_upstream_status() {
    local dir="${1:-.}"
    # shellcheck disable=SC1083
    local upstream
    upstream=$(git -C "$dir" rev-parse --abbrev-ref '@{u}' 2>/dev/null) || return 0

    local ahead behind
    ahead=$(git -C "$dir" rev-list --count '@{u}..HEAD' 2>/dev/null)
    behind=$(git -C "$dir" rev-list --count 'HEAD..@{u}' 2>/dev/null)

    local status=""
    [[ "$ahead" -gt 0 ]] && status+="↑${ahead} ahead"
    [[ "$behind" -gt 0 ]] && { [[ -n "$status" ]] && status+=", "; status+="↓${behind} behind"; }

    [[ -n "$status" ]] && printf '%s\n' "$status"
}

# =============================================================================
# Profile Commands
# =============================================================================

# Apply a profile to a git repository
_profiles_apply() {
    local profile_name="$1"
    local dir="${2:-.}"
    local profile_data p_name email user ssh_key signingkey gpgsign signingformat host

    profile_data="$(_profiles_get "$profile_name")"
    if [[ -z "$profile_data" ]]; then
        error "Profile not found: $profile_name"
        return 1
    fi

    if ! git -C "$dir" rev-parse --git-dir &>/dev/null; then
        error "Not a git repository: $dir"
        return 1
    fi

    # Validate required fields before applying
    if ! _profile_validate "$profile_name" "$profile_data"; then
        return 1
    fi

    p_name=$(_profile_field "$profile_data" "name")
    email=$(_profile_field "$profile_data" "email")
    user=$(_profile_field "$profile_data" "user")
    ssh_key=$(_profile_field "$profile_data" "ssh_key")
    signingkey=$(_profile_field "$profile_data" "signingkey")
    gpgsign=$(_profile_field "$profile_data" "gpgsign")
    signingformat=$(_profile_field "$profile_data" "signingformat")
    host=$(_profile_field "$profile_data" "host")

    # Store profile assignment as source of truth
    git -C "$dir" config --local jsh.profile "$profile_name"

    # Set identity in local git config
    git -C "$dir" config --local user.name "$p_name"
    git -C "$dir" config --local user.email "$email"

    # Set SSH command for key isolation (standard URLs, specific key)
    local expanded_ssh_key
    expanded_ssh_key="$(_expand_tilde "$ssh_key")"
    git -C "$dir" config --local core.sshCommand "ssh -i ${expanded_ssh_key} -o IdentitiesOnly=yes"

    # Handle signing configuration
    if [[ -n "$signingkey" ]]; then
        local expanded_signingkey
        expanded_signingkey="$(_expand_tilde "$signingkey")"
        git -C "$dir" config --local user.signingkey "$expanded_signingkey"
        git -C "$dir" config --local commit.gpgsign "${gpgsign:-true}"
        git -C "$dir" config --local gpg.format "${signingformat:-ssh}"
    else
        # Explicitly disable signing to prevent default key leakage
        git -C "$dir" config --local commit.gpgsign "false"
        git -C "$dir" config --local --unset user.signingkey 2>/dev/null || true
        git -C "$dir" config --local --unset gpg.format 2>/dev/null || true
    fi

    # Migrate old-style SSH host alias remote URLs to standard hosts
    local origin_url
    origin_url=$(git -C "$dir" remote get-url origin 2>/dev/null) || true

    if [[ -n "$origin_url" ]]; then
        local parsed url_host repo_name
        parsed="$(_git_parse_url "$origin_url")"
        url_host="${parsed%%|*}"
        repo_name="${parsed##*|}"

        # Detect old-style SSH host aliases (e.g., github-jovalle)
        if [[ -n "$url_host" ]] && [[ "$url_host" != *.* ]]; then
            # Non-FQDN host = SSH alias, migrate to standard host
            local standard_host="${host:-github.com}"
            local new_origin_url="git@${standard_host}:${user}/${repo_name}.git"
            git -C "$dir" remote set-url origin "$new_origin_url"
            info "Migrated remote: ${url_host} → ${standard_host} (using core.sshCommand)"
        fi
    fi

    return 0
}

# Detect which profile matches a git repo's config
# Prefers jsh.profile (explicit assignment) over email matching (legacy)
_profiles_detect() {
    local dir="${1:-.}"

    # First: check explicit profile assignment
    local assigned
    assigned=$(git -C "$dir" config --local jsh.profile 2>/dev/null) || true
    if [[ -n "$assigned" ]]; then
        printf '%s\n' "$assigned"
        return 0
    fi

    # Fallback: match by email (legacy repos without jsh.profile)
    local current_email profile_name profile_data p_email
    current_email=$(git -C "$dir" config user.email 2>/dev/null)
    [[ -z "$current_email" ]] && return 1

    while IFS= read -r profile_name; do
        [[ -z "$profile_name" ]] && continue
        profile_data="$(_profiles_get "$profile_name")"
        p_email=$(_profile_field "$profile_data" "email")

        if [[ "$p_email" == "$current_email" ]]; then
            printf '%s\n' "$profile_name"
            return 0
        fi
    done < <(_profiles_list)

    return 1
}

# Show current profile status with leak check
cmd_profile_status() {
    if ! git rev-parse --git-dir &>/dev/null; then
        error "Not in a git repository"
        return 1
    fi

    local assigned_profile origin_url
    local current_name current_email ssh_cmd
    assigned_profile=$(git config --local jsh.profile 2>/dev/null) || true
    current_name=$(git config user.name 2>/dev/null)
    current_email=$(git config user.email 2>/dev/null)
    ssh_cmd=$(git config --local core.sshCommand 2>/dev/null) || true
    origin_url=$(git remote get-url origin 2>/dev/null) || true

    if [[ -n "$assigned_profile" ]]; then
        printf 'Profile:  %b%s%b\n' "$C_GREEN" "$assigned_profile" "$C_RESET"
    else
        printf 'Profile:  %b(none)%b\n' "$C_DIM" "$C_RESET"
    fi

    printf 'Name:     %s\n' "${current_name:-${C_DIM}(not set)${C_RESET}}"
    printf 'Email:    %s\n' "${current_email:-${C_DIM}(not set)${C_RESET}}"
    printf 'Origin:   %b%s%b\n' "$C_CYAN" "${origin_url:-${C_DIM}(not set)${C_RESET}}" "$C_RESET"

    # Show SSH key info
    if [[ -n "$ssh_cmd" ]]; then
        local key_path
        key_path=$(printf '%s' "$ssh_cmd" | sed -n 's/.*-i \([^ ]*\).*/\1/p')
        if [[ -n "$key_path" ]]; then
            local key_name="${key_path##*/}"
            if [[ -f "$key_path" ]]; then
                printf 'SSH Key:  %s %b✓%b\n' "$key_name" "$C_GREEN" "$C_RESET"
            else
                printf 'SSH Key:  %s %b✗ NOT FOUND%b\n' "$key_name" "$C_RED" "$C_RESET"
            fi
        fi
    fi

    # Show signing status
    local signingkey gpgsign
    signingkey=$(git config --local user.signingkey 2>/dev/null) || true
    gpgsign=$(git config --local commit.gpgsign 2>/dev/null) || true
    if [[ -n "$signingkey" ]] && [[ "$gpgsign" == "true" ]]; then
        local format
        format=$(git config --local gpg.format 2>/dev/null) || true
        printf 'Signing:  %s (%s) %b✓%b\n' "${signingkey##*/}" "${format:-gpg}" "$C_GREEN" "$C_RESET"
    else
        printf 'Signing:  %b(disabled)%b\n' "$C_DIM" "$C_RESET"
    fi

    # Identity leak check
    printf '\n'
    printf '%bIdentity Check:%b\n' "$C_BOLD" "$C_RESET"
    local has_leak=false

    if [[ -n "${GIT_AUTHOR_NAME:-}" ]]; then
        printf '  GIT_AUTHOR_NAME ...... %b⚠ "%s" OVERRIDES profile!%b\n' "$C_YELLOW" "$GIT_AUTHOR_NAME" "$C_RESET"
        has_leak=true
    else
        printf '  GIT_AUTHOR_NAME ...... %bok%b\n' "$C_GREEN" "$C_RESET"
    fi

    if [[ -n "${GIT_AUTHOR_EMAIL:-}" ]]; then
        printf '  GIT_AUTHOR_EMAIL ..... %b⚠ "%s" OVERRIDES profile!%b\n' "$C_YELLOW" "$GIT_AUTHOR_EMAIL" "$C_RESET"
        has_leak=true
    else
        printf '  GIT_AUTHOR_EMAIL ..... %bok%b\n' "$C_GREEN" "$C_RESET"
    fi

    if [[ -n "${GIT_COMMITTER_NAME:-}" ]]; then
        printf '  GIT_COMMITTER_NAME ... %b⚠ "%s" OVERRIDES profile!%b\n' "$C_YELLOW" "$GIT_COMMITTER_NAME" "$C_RESET"
        has_leak=true
    else
        printf '  GIT_COMMITTER_NAME ... %bok%b\n' "$C_GREEN" "$C_RESET"
    fi

    if [[ -n "${GIT_COMMITTER_EMAIL:-}" ]]; then
        printf '  GIT_COMMITTER_EMAIL .. %b⚠ "%s" OVERRIDES profile!%b\n' "$C_YELLOW" "$GIT_COMMITTER_EMAIL" "$C_RESET"
        has_leak=true
    else
        printf '  GIT_COMMITTER_EMAIL .. %bok%b\n' "$C_GREEN" "$C_RESET"
    fi

    if [[ "$has_leak" == "true" ]]; then
        printf '\n  %b⚠ jgit commit will override these env vars with profile values.%b\n' "$C_YELLOW" "$C_RESET"
    fi
}

# List all profiles
cmd_profile_list() {
    if [[ ! -f "$JSH_PROFILES" ]]; then
        printf '%s\n' "No profiles configured."
        printf '%s\n' "Create config at: $JSH_PROFILES"
        return 0
    fi

    local current_profile
    current_profile=$(git config --local jsh.profile 2>/dev/null) || true

    printf '%b%-15s %-28s %-20s %s%b\n' "$C_DIM" "PROFILE" "EMAIL" "SSH KEY" "SIGNING" "$C_RESET"
    printf '%s\n' "$(printf '%80s' '' | tr ' ' '─')"

    while IFS= read -r profile_name; do
        [[ -z "$profile_name" ]] && continue
        local profile_data email ssh_key signingkey signingformat marker
        local ssh_display signing_display
        profile_data="$(_profiles_get "$profile_name")"
        email=$(_profile_field "$profile_data" "email")
        ssh_key=$(_profile_field "$profile_data" "ssh_key")
        signingkey=$(_profile_field "$profile_data" "signingkey")
        signingformat=$(_profile_field "$profile_data" "signingformat")

        # SSH key display
        if [[ -n "$ssh_key" ]]; then
            ssh_display="${ssh_key##*/}"
        else
            ssh_display="${C_RED}✗ missing${C_RESET}"
        fi

        # Signing display
        if [[ -n "$signingkey" ]]; then
            signing_display="✓ ${signingformat:-ssh}"
        else
            signing_display="✗ none"
        fi

        if [[ "$profile_name" == "$current_profile" ]]; then
            marker="${C_GREEN}* ${C_RESET}"
        else
            marker="  "
        fi

        printf '%s%b%-15s%b %-28s %-20s %s\n' "$marker" "$C_CYAN" "$profile_name" "$C_RESET" "$email" "$ssh_display" "$signing_display"
    done < <(_profiles_list)
}

# Apply a profile to the current repo
cmd_profile_apply() {
    local profile_name="$1"

    if [[ -z "$profile_name" ]]; then
        printf '%s\n' "Usage: jgit profile <name>" >&2
        printf '\n%s\n' "Available profiles:" >&2
        _profiles_list | while read -r p; do printf '%s\n' "  $p" >&2; done
        return 1
    fi

    if ! git rev-parse --git-dir &>/dev/null; then
        error "Not in a git repository"
        return 1
    fi

    if ! _profiles_apply "$profile_name"; then
        return 1
    fi

    printf '%b\n' "${C_GREEN}Applied profile:${C_RESET} ${C_CYAN}${profile_name}${C_RESET}"
    printf '\n'
    cmd_profile_status
}

# Migrate profiles from ssh_host to ssh_key
cmd_profile_migrate() {
    if [[ ! -f "$JSH_PROFILES" ]]; then
        error "No profiles file found: $JSH_PROFILES"
        return 1
    fi

    local ssh_config="${HOME}/.ssh/config"
    local migrated=0

    while IFS= read -r profile_name; do
        [[ -z "$profile_name" ]] && continue
        local profile_data ssh_host ssh_key
        profile_data="$(_profiles_get "$profile_name")"
        ssh_host=$(_profile_field "$profile_data" "ssh_host")
        ssh_key=$(_profile_field "$profile_data" "ssh_key")

        # Skip if already has ssh_key or no ssh_host
        [[ -n "$ssh_key" ]] && continue
        [[ -z "$ssh_host" ]] && continue

        # Look up IdentityFile from ssh config
        local identity_file=""
        if [[ -f "$ssh_config" ]]; then
            identity_file=$(awk -v host="$ssh_host" '
                BEGIN { found=0 }
                /^[[:space:]]*Host[[:space:]]/ {
                    found=0
                    n=split($0, hosts, /[[:space:]]+/)
                    for (i=2; i<=n; i++) {
                        if (hosts[i] == host) found=1
                    }
                }
                found && /^[[:space:]]*IdentityFile[[:space:]]/ {
                    gsub(/^[[:space:]]*IdentityFile[[:space:]]+/, "")
                    print
                    exit
                }
            ' "$ssh_config")
        fi

        if [[ -n "$identity_file" ]]; then
            info "Profile '${profile_name}': ssh_host '${ssh_host}' → ssh_key '${identity_file}'"
            migrated=$((migrated + 1))
        else
            warn "Profile '${profile_name}': ssh_host '${ssh_host}' found but no IdentityFile in ${ssh_config}"
        fi
    done < <(_profiles_list)

    if [[ "$migrated" -eq 0 ]]; then
        info "No profiles need migration."
    else
        info "${migrated} profile(s) identified for migration."
        info "Update your ${JSH_PROFILES} manually with the ssh_key paths shown above."
    fi
}

# Profile command dispatcher
cmd_profile() {
    local subcmd="${1:-}"

    case "$subcmd" in
        ""|status)     cmd_profile_status ;;
        list|ls)       cmd_profile_list ;;
        migrate)       cmd_profile_migrate ;;
        -h|--help|help)
            cat << EOF
Usage: jgit profile [command] [args]

Commands:
  (none)        Show current profile for this repo
  list          List all configured profiles
  migrate       Migrate ssh_host → ssh_key using ~/.ssh/config
  <name>        Apply profile to current repo

Config: $JSH_PROFILES
EOF
            ;;
        *)
            if _profiles_exists "$subcmd" 2>/dev/null; then
                cmd_profile_apply "$subcmd"
            else
                error "Unknown profile: $subcmd"
                printf '%s\n' "Use 'jgit profile list' to see available profiles." >&2
                return 1
            fi
            ;;
    esac
}

# =============================================================================
# Default & Update Commands
# =============================================================================

# Generate ASCII art banner for project name
# Uses figlet if available, otherwise creates a styled box header
_banner() {
    local name="$1"
    local profile="${2:-}"

    # Try figlet with "small" font (most legible)
    if command -v figlet &>/dev/null; then
        local banner
        banner=$(figlet -f small "$name" 2>/dev/null)
        if [[ -n "$banner" ]]; then
            printf '%b' "$C_BOLD$C_CYAN"
            while IFS= read -r line; do
                printf '  %s\n' "$line"
            done <<< "$banner"
            printf '%b' "$C_RESET"
            if [[ -n "$profile" ]]; then
                printf '%b  profile: %s%b\n' "$C_DIM" "$profile" "$C_RESET"
            fi
            return 0
        fi
    fi

    # Fallback: styled box header
    local name_len=${#name}
    local box_width=$((name_len + 6))
    [[ $box_width -lt 40 ]] && box_width=40

    local top_border bottom_border padding
    top_border="╭$(printf '─%.0s' $(seq 1 $((box_width - 2))))╮"
    bottom_border="╰$(printf '─%.0s' $(seq 1 $((box_width - 2))))╯"
    padding=$(( (box_width - 2 - name_len) / 2 ))

    printf '%b%s%b\n' "$C_DIM" "$top_border" "$C_RESET"
    printf '%b│%b%*s%b%s%b%*s%b│%b\n' \
        "$C_DIM" "$C_RESET" \
        "$padding" "" \
        "$C_BOLD$C_CYAN" "$name" "$C_RESET" \
        "$((box_width - 2 - name_len - padding))" "" \
        "$C_DIM" "$C_RESET"
    printf '%b%s%b\n' "$C_DIM" "$bottom_border" "$C_RESET"

    if [[ -n "$profile" ]]; then
        printf '%b  profile: %s%b\n' "$C_DIM" "$profile" "$C_RESET"
    fi
}

# Section header helper
_section() {
    local title="$1"
    printf '\n%b┌─ %s %b%s%b\n' "$C_DIM" "$title" "$C_DIM" "$(printf '─%.0s' $(seq 1 $((50 - ${#title}))))" "$C_RESET"
}

# Row helper with label and value
_row() {
    local label="$1"
    local value="$2"
    printf '%b│%b  %-12s %s\n' "$C_DIM" "$C_RESET" "$label" "$value"
}

# Detailed repo info (when in a git repo)
cmd_repo_info() {
    local repo_name branch origin_url detected_profile repo_root

    repo_root=$(git rev-parse --show-toplevel)
    repo_name=$(basename "$repo_root")
    branch=$(git branch --show-current 2>/dev/null)
    [[ -z "$branch" ]] && branch=$(git rev-parse --short HEAD 2>/dev/null || echo "unknown")
    origin_url=$(git remote get-url origin 2>/dev/null)
    detected_profile="$(_profiles_detect 2>/dev/null)" || true

    # Banner
    printf '\n'
    _banner "$repo_name" "$detected_profile"

    # ─────────────────────────────────────────────────────────────────
    # Repository Section
    # ─────────────────────────────────────────────────────────────────
    _section "Repository"

    # Branch with indicator
    local branch_display
    case "$branch" in
        main|master) branch_display="${C_GREEN}${branch}${C_RESET}" ;;
        develop|dev) branch_display="${C_CYAN}${branch}${C_RESET}" ;;
        feature/*|feat/*) branch_display="${C_BLUE}${branch}${C_RESET}" ;;
        bugfix/*|fix/*|hotfix/*) branch_display="${C_RED}${branch}${C_RESET}" ;;
        *) branch_display="${C_YELLOW}${branch}${C_RESET}" ;;
    esac
    _row "Branch" "$branch_display"

    # Remote
    if [[ -n "$origin_url" ]]; then
        _row "Remote" "${C_DIM}origin →${C_RESET} $origin_url"
    fi

    # Upstream status
    local upstream ahead behind
    # shellcheck disable=SC1083
    upstream=$(git rev-parse --abbrev-ref '@{u}' 2>/dev/null) || true
    if [[ -n "$upstream" ]]; then
        ahead=$(git rev-list --count '@{u}..HEAD' 2>/dev/null || echo 0)
        behind=$(git rev-list --count 'HEAD..@{u}' 2>/dev/null || echo 0)

        local sync_status=""
        if [[ "$ahead" -gt 0 ]] && [[ "$behind" -gt 0 ]]; then
            sync_status="${C_YELLOW}↑${ahead} ↓${behind}${C_RESET} diverged from ${C_DIM}${upstream}${C_RESET}"
        elif [[ "$ahead" -gt 0 ]]; then
            sync_status="${C_GREEN}↑${ahead}${C_RESET} ahead of ${C_DIM}${upstream}${C_RESET}"
        elif [[ "$behind" -gt 0 ]]; then
            sync_status="${C_RED}↓${behind}${C_RESET} behind ${C_DIM}${upstream}${C_RESET}"
        else
            sync_status="${C_GREEN}✓${C_RESET} in sync with ${C_DIM}${upstream}${C_RESET}"
        fi
        _row "Upstream" "$sync_status"
    fi

    # Tags pointing at HEAD
    local tags
    tags=$(git tag --points-at HEAD 2>/dev/null | tr '\n' ' ')
    if [[ -n "$tags" ]]; then
        _row "Tags" "${C_CYAN}${tags}${C_RESET}"
    fi

    # ─────────────────────────────────────────────────────────────────
    # Working Tree Section
    # ─────────────────────────────────────────────────────────────────
    _section "Working Tree"

    local staged unstaged untracked stash_count
    staged=$(git diff --cached --numstat 2>/dev/null | wc -l | tr -d ' ')
    unstaged=$(git diff --numstat 2>/dev/null | wc -l | tr -d ' ')
    untracked=$(git ls-files --others --exclude-standard 2>/dev/null | wc -l | tr -d ' ')
    stash_count=$(git stash list 2>/dev/null | wc -l | tr -d ' ')

    if [[ "$staged" -eq 0 ]] && [[ "$unstaged" -eq 0 ]] && [[ "$untracked" -eq 0 ]]; then
        _row "Status" "${C_GREEN}✓ Clean working tree${C_RESET}"
    else
        [[ "$staged" -gt 0 ]] && _row "Staged" "${C_GREEN}+${staged}${C_RESET} files ready to commit"
        [[ "$unstaged" -gt 0 ]] && _row "Modified" "${C_YELLOW}*${unstaged}${C_RESET} files with changes"
        [[ "$untracked" -gt 0 ]] && _row "Untracked" "${C_RED}?${untracked}${C_RESET} new files"
    fi

    [[ "$stash_count" -gt 0 ]] && _row "Stashed" "${C_BLUE}${stash_count}${C_RESET} $([ "$stash_count" -eq 1 ] && echo "entry" || echo "entries")"

    # ─────────────────────────────────────────────────────────────────
    # Recent Activity Section
    # ─────────────────────────────────────────────────────────────────
    _section "Recent Activity"

    # Last 3 commits
    local commit_hash commit_msg commit_time
    while IFS='|' read -r commit_hash commit_msg commit_time; do
        [[ -z "$commit_hash" ]] && continue
        printf '%b│%b    %b%s%b %s %b(%s)%b\n' \
            "$C_DIM" "$C_RESET" \
            "$C_DIM" "$commit_hash" "$C_RESET" \
            "$commit_msg" \
            "$C_DIM" "$commit_time" "$C_RESET"
    done < <(git log -3 --format="%h|%s|%cr" 2>/dev/null)

    # ─────────────────────────────────────────────────────────────────
    # Submodules Section (if any)
    # ─────────────────────────────────────────────────────────────────
    local submodule_output
    submodule_output=$(git submodule status 2>/dev/null)
    if [[ -n "$submodule_output" ]]; then
        _section "Submodules"
        while read -r line; do
            [[ -z "$line" ]] && continue
            # Format: [status]<sha> <path> (<description>)
            # Status: space=clean, +=modified, -=not init, U=conflict
            local status="${line:0:1}"
            local rest="${line:1}"

            # Handle space as status (clean)
            if [[ "$status" == " " ]]; then
                status=""
            fi

            # Extract SHA (40 chars) and path
            local sha path desc
            sha="${rest:0:7}"
            rest="${rest:41}"  # Skip full SHA + space
            path="${rest%% *}"
            desc="${rest#* }"
            desc="${desc#(}"
            desc="${desc%)}"

            local indicator
            case "$status" in
                '-') indicator="${C_DIM}○${C_RESET} ${path} ${C_DIM}@ ${sha}${C_RESET} ${C_DIM}(not initialized)${C_RESET}" ;;
                '+') indicator="${C_YELLOW}●${C_RESET} ${path} ${C_DIM}@ ${sha}${C_RESET} ${C_YELLOW}(modified)${C_RESET}" ;;
                'U') indicator="${C_RED}●${C_RESET} ${path} ${C_DIM}@ ${sha}${C_RESET} ${C_RED}(conflict)${C_RESET}" ;;
                *)   indicator="${C_GREEN}●${C_RESET} ${path} ${C_DIM}@ ${sha}${C_RESET}" ;;
            esac
            printf '%b│%b    %s\n' "$C_DIM" "$C_RESET" "$indicator"
        done <<< "$submodule_output"
    fi

    # Footer
    printf '%b└%b\n\n' "$C_DIM" "$C_RESET"
}

# Default command (context-aware)
cmd_default() {
    if git rev-parse --git-dir &>/dev/null; then
        cmd_repo_info
    else
        cmd_list
    fi
}

# Safe update: stash → fetch → rebase → pop
cmd_update() {
    if ! git rev-parse --git-dir &>/dev/null; then
        error "Not in a git repository"
        return 1
    fi

    local stash_name="" has_changes=false

    # Check for uncommitted changes
    if ! git diff --quiet || ! git diff --cached --quiet || [[ -n "$(git ls-files --others --exclude-standard)" ]]; then
        has_changes=true
        stash_name="jgit-update-$(date +%Y%m%d-%H%M%S)"
        info "Stashing changes as: $stash_name"
        git stash push -u -m "$stash_name" || abort "Failed to stash changes"
    fi

    # Fetch from origin
    info "Fetching from origin..."
    git fetch origin || abort "Failed to fetch"

    # Identify default branch (main > master > develop)
    local default_branch=""
    for b in main master develop; do
        if git show-ref --verify --quiet "refs/remotes/origin/$b"; then
            default_branch="$b"
            break
        fi
    done

    if [[ -z "$default_branch" ]]; then
        warn "No default branch found (main/master/develop)"
        [[ "$has_changes" == true ]] && git stash pop
        return 1
    fi

    # Rebase current branch onto origin/default
    local current_branch
    current_branch=$(git branch --show-current)
    info "Rebasing ${current_branch:-HEAD} onto origin/${default_branch}..."

    if ! git rebase "origin/${default_branch}"; then
        warn "Rebase conflicts detected"
        if [[ "$has_changes" == true ]]; then
            warn "Your stashed changes are preserved as: $stash_name"
            warn "After resolving conflicts, run: git stash pop"
        fi
        return 1
    fi

    # Pop stash if created
    if [[ "$has_changes" == true ]]; then
        info "Restoring stashed changes..."
        if ! git stash pop; then
            warn "Conflicts when restoring stash"
            warn "Your changes are still in stash. Resolve conflicts and run: git stash pop"
            return 1
        fi
    fi

    success "Update complete"
}

# =============================================================================
# Project Commands
# =============================================================================

# Output project path (for shell wrapper to cd)
cmd_path() {
    local name="$1"
    local name_lower matches=()

    if [[ -z "$name" ]]; then
        error "Usage: jgit path <name>"
        return 1
    fi

    name_lower="$(_lowercase "$name")"

    while IFS= read -r dir; do
        [[ -z "$dir" ]] && continue
        local basename
        basename="${dir##*/}"

        if [[ "$(_lowercase "$basename")" == "$name_lower" ]] || \
           [[ "$(_lowercase "${basename#.}")" == "$name_lower" ]]; then
            matches+=("$dir")
        fi
    done < <(_projects_get_all)

    case ${#matches[@]} in
        0)
            error "No project found: $name"
            return 1
            ;;
        1)
            printf '%s\n' "${matches[0]}"
            ;;
        *)
            warn "Multiple matches for '$name', using first:"
            for dir in "${matches[@]}"; do
                printf '%s\n' "  $(_projects_display_name "$dir")" >&2
            done
            printf '%s\n' "${matches[0]}"
            ;;
    esac
}

# List all projects with git status
cmd_list() {
    local verbose=false
    [[ "${1:-}" == "-v" || "${1:-}" == "--verbose" ]] && verbose=true

    local all_dirs=()
    while IFS= read -r dir; do
        [[ -n "$dir" ]] && all_dirs+=("$dir")
    done < <(_projects_get_all)

    local total=${#all_dirs[@]}
    if [[ ${total} -eq 0 ]]; then
        printf '%s\n' "No projects found."
        printf '%s\n' "Configure paths with \$JSH_PROJECTS (comma-separated)."
        return 0
    fi

    # Header
    printf '%b%-30s %-15s %s%b\n' "$C_DIM" "PROJECT" "STATUS" "PROFILE" "$C_RESET"
    printf '%s\n' "$(printf '%60s' '' | tr ' ' '─')"

    # Projects
    for dir in "${all_dirs[@]}"; do
        # Validate it's actually a valid git repository (not just having a .git dir)
        git -C "$dir" rev-parse --git-dir &>/dev/null || continue

        local display_name branch status_str profile_name=""
        display_name="$(_projects_display_name "$dir")"

        branch=$(git -C "$dir" branch --show-current 2>/dev/null)
        [[ -z "$branch" ]] && branch=$(git -C "$dir" rev-parse --short HEAD 2>/dev/null || echo "-")

        # Compact status
        local staged unstaged untracked status_parts=""
        staged=$(git -C "$dir" diff --cached --numstat 2>/dev/null | wc -l | tr -d ' ')
        unstaged=$(git -C "$dir" diff --numstat 2>/dev/null | wc -l | tr -d ' ')
        untracked=$(git -C "$dir" ls-files --others --exclude-standard 2>/dev/null | wc -l | tr -d ' ')

        [[ "$staged" -gt 0 ]] && status_parts+="${C_GREEN}+${staged}${C_RESET} "
        [[ "$unstaged" -gt 0 ]] && status_parts+="${C_YELLOW}*${unstaged}${C_RESET} "
        [[ "$untracked" -gt 0 ]] && status_parts+="${C_RED}?${untracked}${C_RESET}"

        if [[ -z "$status_parts" ]]; then
            status_str="${C_CYAN}${branch}${C_RESET} ${C_DIM}clean${C_RESET}"
        else
            status_str="${C_CYAN}${branch}${C_RESET} ${status_parts}"
        fi

        if [[ "$verbose" == true ]]; then
            profile_name="$(_profiles_detect "$dir" 2>/dev/null)" || true
            [[ -z "$profile_name" ]] && profile_name="${C_DIM}-${C_RESET}"
        fi

        if [[ "$verbose" == true ]]; then
            printf '%-30s %-15b %s\n' "$display_name" "$status_str" "$profile_name"
        else
            printf '%-30s %b\n' "$display_name" "$status_str"
        fi
    done

    # Footer
    printf '%s\n' "$(printf '%60s' '' | tr ' ' '─')"
    printf '%b%d projects%b\n' "$C_DIM" "$total" "$C_RESET"
}

# Clone with smart SSH fallback
# Called via: project add <url> [name]
cmd_add() {
    local url="$1"
    local name="${2:-}"

    if [[ -z "$url" ]]; then
        cat << 'EOF' >&2
Usage: project add <git-url> [name]

Clone a git repository with smart SSH key selection.
Automatically selects SSH key based on repo owner matching profile user.

Examples:
  project add git@github.com:user/repo.git
  project add https://github.com/user/repo.git
  project add git@github.com:user/repo.git myrepo
EOF
        return 1
    fi

    [[ -z "$name" ]] && name="$(_projects_name_from_url "$url")"

    if [[ -z "$name" ]]; then
        error "Could not determine project name from URL: $url"
        return 1
    fi

    local target_dir
    target_dir="$(_projects_default_dir)/${name}"

    if [[ -d "$target_dir" ]]; then
        error "Directory already exists: $target_dir"
        return 1
    fi

    # Create parent directory
    mkdir -p "$(dirname "$target_dir")" || abort "Failed to create directory"

    # Parse URL
    local parsed platform owner repo
    parsed="$(_git_parse_url "$url")"
    platform="${parsed%%|*}"
    owner="${parsed#*|}"
    owner="${owner%%|*}"
    repo="${parsed##*|}"

    # Try to find matching profile for SSH host
    local clone_url="$url"
    local matched_profile ssh_host

    if matched_profile="$(_profile_find_by_user "$owner")"; then
        ssh_host="$(_profile_ssh_host "$matched_profile" "$platform")"

        if [[ -n "$ssh_host" ]] && _ssh_host_exists "$ssh_host"; then
            clone_url="git@${ssh_host}:${owner}/${repo}.git"
            info "Using SSH key for profile: ${C_CYAN}${matched_profile}${C_RESET}"
        fi
    fi

    printf '%b\n' "Cloning ${C_CYAN}${name}${C_RESET}..."

    # Helper to output cd info
    _output_cd_info() {
        if [[ -n "${JSH_CD_FILE:-}" ]]; then
            # Write to temp file for shell wrapper to read
            printf '%s' "$target_dir" > "${JSH_CD_FILE}"
        elif [[ -n "${JSH_WRAPPER:-}" ]]; then
            printf 'CD:%s\n' "$target_dir"
        else
            printf '\n  %s→%s cd %s\n' "$C_CYAN" "$C_RESET" "$(_projects_display_name "$target_dir")"
        fi
    }

    # Try smart SSH URL first
    if git clone "$clone_url" "$target_dir" 2>/dev/null; then
        success "cloned to: $(_projects_display_name "$target_dir")"
        _output_cd_info
        return 0
    fi

    # Fallback to original URL
    if [[ "$clone_url" != "$url" ]]; then
        warn "SSH clone failed, trying original URL..."
        if git clone "$url" "$target_dir" 2>/dev/null; then
            success "cloned to: $(_projects_display_name "$target_dir")"
            _output_cd_info
            return 0
        fi
    fi

    # Final fallback: HTTPS
    if [[ "$url" != https://* ]] && [[ -n "$platform" ]] && [[ "$platform" == *.* ]]; then
        local https_url="https://${platform}/${owner}/${repo}.git"
        warn "Trying HTTPS fallback..."
        if git clone "$https_url" "$target_dir"; then
            success "cloned to: $(_projects_display_name "$target_dir")"
            warn "Cloned via HTTPS. Run 'jgit profile <name>' to set up SSH."
            _output_cd_info
            return 0
        fi
    fi

    error "Failed to clone repository"
    return 1
}

# Create new project with profile selection
# Called via: project create <name>
cmd_create() {
    local name="${1:-}"

    if [[ -z "$name" ]]; then
        error "Usage: project create <name>"
        return 1
    fi

    local target_dir
    target_dir="$(_projects_default_dir)/${name}"

    if [[ -d "$target_dir" ]]; then
        error "Directory already exists: $target_dir"
        return 1
    fi

    # Interactive profile selection
    local profiles=() profile_info=() selected_profile=""
    while IFS= read -r p; do
        [[ -z "$p" ]] && continue
        profiles+=("$p")
        local info pname pemail
        info="$(_profiles_get "$p")"
        pname=$(_profile_field "$info" "name")
        pemail=$(_profile_field "$info" "email")
        profile_info+=("$pname <$pemail>")
    done < <(_profiles_list)

    if [[ ${#profiles[@]} -gt 0 ]]; then
        # Interactive selection only if stdin is a tty
        if [[ -t 0 ]]; then
            printf '\nSelect a profile for this project:\n'
            local i=1
            for idx in "${!profiles[@]}"; do
                printf '  %s%d)%s %s - %s\n' "$C_CYAN" "$i" "$C_RESET" "${profiles[$idx]}" "${profile_info[$idx]}"
                ((i++))
            done
            printf '  %ss)%s Skip (no profile)\n' "$C_DIM" "$C_RESET"
            printf '\n'

            local choice
            read -rp "Choice [1]: " choice
            choice="${choice:-1}"

            if [[ "$choice" != "s" ]] && [[ "$choice" =~ ^[0-9]+$ ]]; then
                local idx=$((choice - 1))
                if [[ $idx -ge 0 ]] && [[ $idx -lt ${#profiles[@]} ]]; then
                    selected_profile="${profiles[$idx]}"
                fi
            fi
        else
            # Non-interactive: use first profile
            selected_profile="${profiles[0]}"
            info "using profile: ${selected_profile}"
        fi
    else
        info "no profiles configured (add to $JSH_PROFILES)"
    fi

    # Create project directory and initialize git
    mkdir -p "$target_dir" || abort "Failed to create directory"
    cd "$target_dir" || return 1
    git init -q || abort "Failed to initialize git repository"

    # Build origin URL from profile
    local origin_url=""
    if [[ -n "$selected_profile" ]]; then
        local profile_data pname pemail puser phost pssh_host
        profile_data="$(_profiles_get "$selected_profile")"
        pname=$(_profile_field "$profile_data" "name")
        pemail=$(_profile_field "$profile_data" "email")
        puser=$(_profile_field "$profile_data" "user")
        phost=$(_profile_field "$profile_data" "host")
        pssh_host=$(_profile_field "$profile_data" "ssh_host")

        # Set git user config
        [[ -n "$pname" ]] && git config user.name "$pname"
        [[ -n "$pemail" ]] && git config user.email "$pemail"

        # Construct origin URL
        if [[ -n "$puser" ]]; then
            local ssh_target
            if [[ -n "$pssh_host" ]]; then
                ssh_target="$pssh_host"
            elif [[ -n "$phost" ]]; then
                ssh_target="$(_ssh_derive_host "$phost" "$puser")"
            else
                ssh_target="$(_ssh_derive_host "github.com" "$puser")"
            fi
            origin_url="git@${ssh_target}:${puser}/${name}.git"
            git remote add origin "$origin_url"
        fi
    fi

    # Create README.md
    cat > README.md << EOF
# ${name}

## Description

A brief description of this project.

## Getting Started

\`\`\`bash
# Installation instructions
\`\`\`

## License

MIT
EOF

    # Create .gitignore
    cat > .gitignore << 'EOF'
# Dependencies
node_modules/
vendor/
.venv/
__pycache__/

# Build outputs
dist/
build/
*.o
*.a
*.so
*.dylib

# IDE
.idea/
.vscode/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db

# Environment
.env
.env.local
*.local

# Logs
*.log
logs/

# Coverage
coverage/
.nyc_output/
EOF

    git add -A
    git commit -q -m "Initial commit"

    # Output in requested order
    printf '\n'
    printf '  %s✓%s %s\n' "$C_GREEN" "$C_RESET" "$(_projects_display_name "$target_dir")"
    printf '  %s✓%s README.md\n' "$C_GREEN" "$C_RESET"
    printf '  %s✓%s .gitignore\n' "$C_GREEN" "$C_RESET"
    if [[ -n "$origin_url" ]]; then
        printf '  %s✓%s .git initialized %s→%s %s\n' "$C_GREEN" "$C_RESET" "$C_DIM" "$C_RESET" "$origin_url"
    else
        printf '  %s✓%s .git initialized\n' "$C_GREEN" "$C_RESET"
    fi
    printf '\n'

    # Output directory for cd handling
    # JSH_CD_FILE is temp file from project() wrapper for cd path communication
    if [[ -n "${JSH_CD_FILE:-}" ]]; then
        printf '%s' "$target_dir" > "${JSH_CD_FILE}"
    elif [[ -n "${JSH_WRAPPER:-}" ]]; then
        printf 'CD:%s\n' "$target_dir"
    fi
}

# =============================================================================
# Interactive Mode Support
# =============================================================================

# Source interactive library (lazy load)
_source_interactive() {
    if [[ -z "${_UI_RESET:-}" ]]; then
        if [[ -f "${JSH_DIR}/lib/jgit/jgit-interactive.sh" ]]; then
            source "${JSH_DIR}/lib/jgit/jgit-interactive.sh"
        else
            abort "Interactive library not found: ${JSH_DIR}/lib/jgit/jgit-interactive.sh"
        fi
    fi
}

# Check if -i or --interactive is in args
_has_interactive_flag() {
    for arg in "$@"; do
        case "$arg" in
            -i|--interactive) return 0 ;;
        esac
    done
    return 1
}

# Remove -i/--interactive from args and echo the rest
_strip_interactive_flag() {
    for arg in "$@"; do
        case "$arg" in
            -i|--interactive) ;;
            *) printf '%s\n' "$arg" ;;
        esac
    done
}

# =============================================================================
# Commit Command
# =============================================================================

cmd_commit() {
    if _has_interactive_flag "$@"; then
        _source_interactive
        local -a args=()
        while IFS= read -r arg; do
            [[ -n "$arg" ]] && args+=("$arg")
        done < <(_strip_interactive_flag "$@")
        cmd_commit_interactive "${args[@]}"
        return $?
    fi

    # Profile-enforced commit
    if ! git rev-parse --git-dir &>/dev/null; then
        error "Not in a git repository"
        return 1
    fi

    # Step 1: Resolve profile
    local profile_name
    profile_name=$(git config --local jsh.profile 2>/dev/null) || true
    if [[ -z "$profile_name" ]]; then
        error "No profile assigned. Run: jgit profile <name>"
        printf '%s\n' "Available profiles:" >&2
        _profiles_list | while read -r p; do printf '%s\n' "  $p" >&2; done
        return 1
    fi

    # Step 2: Load and validate profile
    local profile_data
    profile_data="$(_profiles_get "$profile_name")"
    if [[ -z "$profile_data" ]]; then
        error "Profile '${profile_name}' not found in ${JSH_PROFILES}"
        return 1
    fi

    if ! _profile_validate "$profile_name" "$profile_data"; then
        return 1
    fi

    # Step 3: Extract fields
    local p_name email ssh_key signingkey signingformat
    p_name=$(_profile_field "$profile_data" "name")
    email=$(_profile_field "$profile_data" "email")
    ssh_key=$(_profile_field "$profile_data" "ssh_key")
    signingkey=$(_profile_field "$profile_data" "signingkey")
    signingformat=$(_profile_field "$profile_data" "signingformat")

    # Expand paths
    ssh_key="$(_expand_tilde "$ssh_key")"
    [[ -n "$signingkey" ]] && signingkey="$(_expand_tilde "$signingkey")"

    # Step 4: Build commit command with identity enforcement
    # git-level args go before "commit", commit-level args go after
    local -a git_args=()
    local -a sign_args=()

    # Handle signing
    if [[ -n "$signingkey" ]]; then
        git_args+=("-c" "user.signingkey=${signingkey}")
        git_args+=("-c" "gpg.format=${signingformat:-ssh}")
        sign_args+=("--gpg-sign=${signingkey}")
    else
        sign_args+=("--no-gpg-sign")
    fi

    # Step 5: Execute with profile identity (env vars override everything)
    GIT_AUTHOR_NAME="$p_name" \
    GIT_AUTHOR_EMAIL="$email" \
    GIT_COMMITTER_NAME="$p_name" \
    GIT_COMMITTER_EMAIL="$email" \
    GIT_SSH_COMMAND="ssh -i ${ssh_key} -o IdentitiesOnly=yes" \
    git -c "user.name=${p_name}" \
        -c "user.email=${email}" \
        "${git_args[@]}" \
        commit "${sign_args[@]}" "$@"
}

# =============================================================================
# Push Command
# =============================================================================

cmd_push() {
    if _has_interactive_flag "$@"; then
        _source_interactive
        local -a args=()
        while IFS= read -r arg; do
            [[ -n "$arg" ]] && args+=("$arg")
        done < <(_strip_interactive_flag "$@")
        cmd_push_interactive "${args[@]}"
    else
        exec git push "$@"
    fi
}

# =============================================================================
# Backup Command (utility)
# =============================================================================

cmd_backup() {
    local subcmd="${1:-list}"
    shift 2>/dev/null || true

    case "$subcmd" in
        list|ls)
            _source_interactive
            _backup_list
            ;;
        restore)
            if [[ -z "${1:-}" ]]; then
                error "Usage: jgit backup restore <ref>"
                return 1
            fi
            _source_interactive
            _backup_restore "$1"
            ;;
        *)
            error "Unknown backup command: $subcmd"
            printf '%s\n' "Usage: jgit backup [list|restore <ref>]"
            return 1
            ;;
    esac
}

# =============================================================================
# Usage & Main
# =============================================================================

# Handle help/version
[[ "${1:-}" == "-h" || "${1:-}" == "--help" ]] && { cli_help; exit 0; }
[[ "${1:-}" == "--version" ]] && { cli_version; exit 0; }

case "${1:-}" in
    # Project commands
    path)      shift; cmd_path "$@" ;;
    list|-l)   shift; cmd_list "$@" ;;

    # Commands that require the project wrapper for cd
    add)
        if [[ -z "${JSH_WRAPPER:-}" ]]; then
            error "Use 'project add <url>' instead (enables auto-cd)"
            exit 1
        fi
        shift; cmd_add "$@"
        ;;
    create)
        if [[ -z "${JSH_WRAPPER:-}" ]]; then
            error "Use 'project create <name>' instead (enables auto-cd)"
            exit 1
        fi
        shift; cmd_create "$@"
        ;;

    # Profile commands
    profile)   shift; cmd_profile "$@" ;;

    # Update command
    update)    cmd_update ;;

    # Interactive-enabled commands
    commit)    shift; cmd_commit "$@" ;;
    push)      shift; cmd_push "$@" ;;

    # Backup management
    backup)    shift; cmd_backup "$@" ;;

    # No command - context-aware default
    "")        cmd_default ;;

    # Pass through to git (unknown commands)
    *)         exec git "$@" ;;
esac
