#!/usr/bin/env bash
# @name nukem
# @version 1.0.0
# @desc Force-remove Kubernetes namespace stuck in Terminating state
# @usage nukem [options] <namespace>
#
# @cmd list  List namespaces in Terminating state
#
# @option -l,--list          List all namespaces in Terminating state
# @option -f,--force         Skip confirmation prompt
# @option -n,--dry-run       Show what would be done without making changes
# @option -c,--context <CTX> Use specific kubectl context
# @option -v,--verbose       Enable verbose output
# @option -h,--help          Show this help message
# @option --version          Show version information
#
# @example nukem stuck-namespace
# @example nukem -f stuck-namespace
# @example nukem --list
#
# shellcheck shell=bash
#
# Safely removes finalizers from a namespace that's stuck terminating.
# This is a destructive operation - use with caution.

set -euo pipefail

# =============================================================================
# Configuration
# =============================================================================

readonly SCRIPT_NAME="${0##*/}"

# Timeout for kubectl operations (seconds)
readonly KUBECTL_TIMEOUT="${NUKEM_TIMEOUT:-30}"

# =============================================================================
# Dependencies
# =============================================================================

# Source CLI framework (provides help generation and colors)
source "${0%/*}/../lib/cli.sh" 2>/dev/null || source "${JSH_DIR:-$HOME/.jsh}/lib/cli.sh"

# Override debug with script-specific env var
debug() { [[ "${NUKEM_DEBUG:-0}" == "1" ]] && _debug "$@" || true; }

# =============================================================================
# Utilities
# =============================================================================

# Check if kubectl is available
require_kubectl() {
    if ! command -v kubectl &>/dev/null; then
        die "kubectl is required but not installed"
    fi
}

# Build kubectl command with optional context
kubectl_cmd() {
    local cmd=(kubectl)
    [[ -n "${KUBECTL_CONTEXT:-}" ]] && cmd+=(--context "${KUBECTL_CONTEXT}")
    cmd+=(--request-timeout="${KUBECTL_TIMEOUT}s")
    "${cmd[@]}" "$@"
}

# List namespaces stuck in Terminating state
list_terminating() {
    info "Checking for namespaces in Terminating state..."

    local namespaces
    namespaces=$(kubectl_cmd get namespaces -o jsonpath='{range .items[?(@.status.phase=="Terminating")]}{.metadata.name}{"\n"}{end}' 2>/dev/null || true)

    if [[ -z "${namespaces}" ]]; then
        success "No namespaces stuck in Terminating state"
        return 0
    fi

    printf "\n%sNamespaces in Terminating state:%s\n" "${C_BOLD}" "${C_RESET}"
    printf "%s─────────────────────────────────%s\n" "${C_DIM}" "${C_RESET}"
    while IFS= read -r ns; do
        local finalizers
        finalizers=$(kubectl_cmd get namespace "${ns}" -o jsonpath='{.spec.finalizers}' 2>/dev/null || echo "[]")
        printf "  %s%s%s" "${C_CYAN}" "${ns}" "${C_RESET}"
        if [[ "${finalizers}" != "[]" && "${finalizers}" != "" ]]; then
            printf "  %sfinalizers: %s%s" "${C_DIM}" "${finalizers}" "${C_RESET}"
        fi
        printf "\n"
    done <<< "${namespaces}"
    printf "\n"
}

# Get namespace details
get_namespace_info() {
    local ns="$1"

    # Check if namespace exists
    if ! kubectl_cmd get namespace "${ns}" &>/dev/null; then
        die "Namespace '${ns}' not found"
    fi

    # Get namespace phase
    local phase
    phase=$(kubectl_cmd get namespace "${ns}" -o jsonpath='{.status.phase}' 2>/dev/null)

    if [[ "${phase}" != "Terminating" ]]; then
        die "Namespace '${ns}' is not in Terminating state (current: ${phase:-Active})"
    fi

    # Get finalizers
    local finalizers
    finalizers=$(kubectl_cmd get namespace "${ns}" -o jsonpath='{.spec.finalizers}' 2>/dev/null || echo "[]")

    printf '%s' "${finalizers}"
}

# Remove finalizers from namespace
remove_finalizers() {
    local ns="$1"
    local dry_run="${2:-false}"

    if [[ "${dry_run}" == "true" ]]; then
        info "[DRY RUN] Would remove finalizers from namespace '${ns}'"

        # Show current state
        printf "\n%sCurrent namespace JSON:%s\n" "${C_BOLD}" "${C_RESET}"
        kubectl_cmd get namespace "${ns}" -o json | head -30
        printf "\n%s... (truncated)%s\n\n" "${C_DIM}" "${C_RESET}"

        info "[DRY RUN] Would POST to: /api/v1/namespaces/${ns}/finalize"
        return 0
    fi

    debug "Fetching namespace JSON..."
    local ns_json
    ns_json=$(kubectl_cmd get namespace "${ns}" -o json)

    debug "Removing finalizers from JSON..."
    # Remove finalizers array (handles both array content and empty array)
    local modified_json
    modified_json=$(echo "${ns_json}" | tr -d '\n' | sed 's/"finalizers":\s*\[[^]]*\]/"finalizers": []/')

    debug "Applying modified namespace via finalize endpoint..."
    if echo "${modified_json}" | kubectl_cmd replace --raw "/api/v1/namespaces/${ns}/finalize" -f - &>/dev/null; then
        success "Finalizers removed from namespace '${ns}'"

        # Wait a moment and check if it's gone
        sleep 2
        if ! kubectl_cmd get namespace "${ns}" &>/dev/null; then
            success "Namespace '${ns}' has been deleted"
        else
            info "Namespace may take a moment to fully delete"
        fi
        return 0
    else
        die "Failed to remove finalizers from namespace '${ns}'"
    fi
}

# confirm() is provided by common.sh

# =============================================================================
# Main
# =============================================================================

main() {
    local namespace=""
    local force=false
    local dry_run=false
    local list_mode=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                cli_help
                exit 0
                ;;
            --version)
                cli_version
                exit 0
                ;;
            -l|--list)
                list_mode=true
                shift
                ;;
            -f|--force)
                force=true
                shift
                ;;
            -n|--dry-run)
                dry_run=true
                shift
                ;;
            -c|--context)
                [[ $# -lt 2 ]] && die "Option $1 requires an argument"
                KUBECTL_CONTEXT="$2"
                shift 2
                ;;
            -v|--verbose)
                NUKEM_DEBUG=1
                export NUKEM_DEBUG
                shift
                ;;
            -*)
                die "Unknown option: $1 (use --help for usage)"
                ;;
            *)
                if [[ -z "${namespace}" ]]; then
                    namespace="$1"
                else
                    die "Unexpected argument: $1"
                fi
                shift
                ;;
        esac
    done

    # Check requirements
    require_kubectl

    # Handle list mode
    if [[ "${list_mode}" == "true" ]]; then
        list_terminating
        exit 0
    fi

    # Require namespace argument
    if [[ -z "${namespace}" ]]; then
        die "Namespace argument required (use --help for usage)"
    fi

    # Validate namespace exists and is terminating
    info "Checking namespace '${namespace}'..."
    local finalizers
    finalizers=$(get_namespace_info "${namespace}")

    if [[ "${finalizers}" == "[]" || -z "${finalizers}" ]]; then
        warn "Namespace '${namespace}' has no finalizers (may delete on its own)"
        if ! confirm "Proceed anyway?"; then
            info "Operation cancelled"
            exit 3
        fi
    fi

    # Show warning and get confirmation
    if [[ "${force}" != "true" && "${dry_run}" != "true" ]]; then
        printf "\n%s%sWARNING:%s About to remove finalizers from namespace '%s'\n" "${C_YELLOW}" "${C_BOLD}" "${C_RESET}" "${namespace}"
        printf "%sFinalizers: %s%s\n\n" "${C_DIM}" "${finalizers}" "${C_RESET}"
        printf "This operation:\n"
        printf "  * Is %sirreversible%s\n" "${C_RED}" "${C_RESET}"
        printf "  * May leave orphaned external resources (LBs, volumes, etc.)\n"
        printf "  * Should only be used when finalizers are known to be stuck\n\n"

        if ! confirm "Are you sure you want to proceed?"; then
            info "Operation cancelled"
            exit 3
        fi
    fi

    # Execute
    remove_finalizers "${namespace}" "${dry_run}"
}

# Handle interrupts gracefully
trap 'printf "\n"; die "Interrupted"' INT TERM

main "$@"
