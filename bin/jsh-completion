#!/usr/bin/env bash
# @name jsh-completion
# @desc Dynamic completion helper for jsh
#
# This script extracts command metadata from live CLI dispatch and command
# source files so completions stay in sync with real commands.
#
# Usage:
#   jsh-completion commands              # List all commands with descriptions
#   jsh-completion subcommands <cmd>     # List subcommands for a command
#   jsh-completion options <cmd>         # List options for a command

set -euo pipefail

JSH_DIR="${JSH_DIR:-${HOME}/.jsh}"

# Extract top-level commands from jsh dispatch case block.
# This avoids stale completions when @jsh-cmd comments drift.
_dispatch_commands() {
    local jsh_file="${JSH_DIR}/jsh"
    [[ -f "${jsh_file}" ]] || return 1

    awk '
        /^[[:space:]]*case[[:space:]]+"\$\{cmd\}"[[:space:]]+in[[:space:]]*$/ { in_case=1; next }
        in_case && /^[[:space:]]*esac[[:space:]]*$/ { exit }
        in_case {
            if ($0 ~ /^[[:space:]]*[^#].*\)[[:space:]]*$/) {
                patterns = $0
                sub(/^[[:space:]]*/, "", patterns)
                sub(/\)[[:space:]]*$/, "", patterns)
                gsub(/[[:space:]]+/, "", patterns)
                if (patterns == "*") next

                count = split(patterns, parts, "|")
                for (i = 1; i <= count; i++) {
                    cmd = parts[i]
                    if (cmd ~ /^[a-z][a-z0-9-]*$/) {
                        print cmd
                    }
                }
            }
        }
    ' "${jsh_file}" | sort -u
}

_cmd_help_output() {
    local cmd="$1"
    local jsh_cmd="${JSH_DIR}/jsh"

    [[ -x "${jsh_cmd}" ]] || return 1
    "${jsh_cmd}" "${cmd}" --help 2>/dev/null | sed -E 's/\x1B\[[0-9;]*[A-Za-z]//g' || true
}

_extract_help_section() {
    local section="$1"

    awk -v section="${section}" '
        $0 == section { in_section=1; next }
        in_section {
            if ($0 == "") {
                if (seen_line) exit
                next
            }
            if ($0 ~ /^[A-Z][A-Za-z[:space:]]*$/) exit
            print
            seen_line=1
        }
    '
}

# Extract all top-level commands.
# Output format: "command:description" (for zsh _describe)
cmd_commands() {
    local cmd
    while IFS= read -r cmd; do
        [[ -n "${cmd}" ]] && echo "${cmd}:${cmd}"
    done < <(_dispatch_commands)
}

# Extract subcommands for a given command from @jsh-sub tags
# The trick: @jsh-sub tags must follow the @jsh-cmd they belong to
# Output format: "subcommand:description"
cmd_subcommands() {
    local cmd="$1"
    local all_cmds
    all_cmds="$(_dispatch_commands | tr '\n' ' ')"
    [[ " ${all_cmds} " == *" ${cmd} "* ]] || return 0

    local help_output
    help_output="$(_cmd_help_output "${cmd}")"
    [[ -n "${help_output}" ]] || return 0

    while IFS= read -r line; do
        [[ -z "${line}" ]] && continue
        if [[ "${line}" =~ ^[[:space:]]*([a-z][a-z0-9_-]*)[[:space:]]+(.+)$ ]]; then
            echo "${BASH_REMATCH[1]}:${BASH_REMATCH[2]}"
        fi
    done < <(printf '%s\n' "${help_output}" | _extract_help_section "Commands")
}

# Extract options for a given command from @jsh-opt tags
# Options follow their @jsh-cmd and apply until the next @jsh-cmd
# Output format: "-s,--long:description" or "--long:description"
cmd_options() {
    local cmd="$1"
    local all_cmds
    all_cmds="$(_dispatch_commands | tr '\n' ' ')"
    [[ " ${all_cmds} " == *" ${cmd} "* ]] || return 0

    local help_output
    help_output="$(_cmd_help_output "${cmd}")"
    [[ -n "${help_output}" ]] || return 0

    while IFS= read -r line; do
        [[ -z "${line}" ]] && continue
        local rest option_desc option
        local -a parsed_options=()

        rest="${line#${line%%[![:space:]]*}}"
        while [[ "${rest}" =~ ^(-{1,2}[^[:space:],]+(=[^[:space:],]+)?),?[[:space:]]*(.*)$ ]]; do
            parsed_options+=("${BASH_REMATCH[1]}")
            rest="${BASH_REMATCH[3]}"
        done

        option_desc="${rest#${rest%%[![:space:]]*}}"
        [[ ${#parsed_options[@]} -eq 0 ]] && continue
        [[ -z "${option_desc}" ]] && continue

        for option in "${parsed_options[@]}"; do
            echo "${option}:${option_desc}"
        done
    done < <(printf '%s\n' "${help_output}" | _extract_help_section "Options")
}

# Main dispatch
case "${1:-}" in
    commands)
        cmd_commands
        ;;
    subcommands)
        [[ -z "${2:-}" ]] && exit 0
        cmd_subcommands "$2"
        ;;
    options)
        [[ -z "${2:-}" ]] && exit 0
        cmd_options "$2"
        ;;
    *)
        echo "Usage: jsh-completion {commands|subcommands|options} [command]" >&2
        exit 1
        ;;
esac
