#!/usr/bin/env bash
# shellcheck shell=bash
# proxy - Execute commands with proxy environment configured
#
# Wraps commands with HTTP/HTTPS proxy environment variables set.
# Useful for tools that need proxy but don't use system settings.
#
# Usage: proxy [options] <command> [args...]

set -euo pipefail

# =============================================================================
# Configuration
# =============================================================================

readonly SCRIPT_NAME="${0##*/}"
readonly SCRIPT_VERSION="1.0.0"

# Default proxy settings (override via environment or config)
PROXY_HTTP="${PROXY_HTTP:-${HTTP_PROXY:-}}"
PROXY_HTTPS="${PROXY_HTTPS:-${HTTPS_PROXY:-}}"
PROXY_SOCKS="${PROXY_SOCKS:-${ALL_PROXY:-}}"
NO_PROXY_LIST="${NO_PROXY_LIST:-${NO_PROXY:-localhost,127.0.0.1,::1}}"

# Config file location
readonly PROXY_CONFIG_FILE="${XDG_CONFIG_HOME:-${HOME}/.config}/proxy/config"

# Common proxy presets
declare -A PROXY_PRESETS=(
    [corporate]="http://proxy.corporate.com:8080"
    [local]="http://127.0.0.1:8080"
    [mitmproxy]="http://127.0.0.1:8080"
    [burp]="http://127.0.0.1:8080"
    [charles]="http://127.0.0.1:8888"
    [fiddler]="http://127.0.0.1:8888"
    [squid]="http://127.0.0.1:3128"
    [privoxy]="http://127.0.0.1:8118"
    [tor]="socks5://127.0.0.1:9050"
    [ssh]="socks5://127.0.0.1:1080"
)

# =============================================================================
# Colors & Output
# =============================================================================

if [[ -t 1 ]] && [[ "${NO_COLOR:-}" != "1" ]]; then
    readonly C_RESET='\033[0m'
    readonly C_RED='\033[0;31m'
    readonly C_GREEN='\033[0;32m'
    readonly C_YELLOW='\033[0;33m'
    readonly C_BLUE='\033[0;34m'
    readonly C_CYAN='\033[0;36m'
    readonly C_BOLD='\033[1m'
    readonly C_DIM='\033[2m'
else
    readonly C_RESET='' C_RED='' C_GREEN='' C_YELLOW=''
    readonly C_BLUE='' C_CYAN='' C_BOLD='' C_DIM=''
fi

# Output helpers - color variables are safe in format strings here
die()     { printf "%s%serror:%s %s\n" "${C_RED}" "${C_BOLD}" "${C_RESET}" "$*" >&2; exit 1; }
warn()    { printf "%s%swarn:%s %s\n" "${C_YELLOW}" "${C_BOLD}" "${C_RESET}" "$*" >&2; }
success() { printf "%s%ssuccess:%s %s\n" "${C_GREEN}" "${C_BOLD}" "${C_RESET}" "$*"; }
info()    { printf "%sinfo:%s %s\n" "${C_BLUE}" "${C_RESET}" "$*"; }
debug()   { [[ "${PROXY_DEBUG:-0}" == "1" ]] && printf "%sdebug: %s%s\n" "${C_DIM}" "$*" "${C_RESET}" >&2 || true; }

# =============================================================================
# Help
# =============================================================================

show_help() {
    cat << EOF
${C_BOLD}proxy${C_RESET} - Execute commands with proxy environment configured

${C_BOLD}USAGE${C_RESET}
    ${SCRIPT_NAME} [options] <command> [args...]
    ${SCRIPT_NAME} -p <preset> <command> [args...]
    ${SCRIPT_NAME} --shell

${C_BOLD}DESCRIPTION${C_RESET}
    Executes a command with proxy environment variables (HTTP_PROXY, HTTPS_PROXY,
    http_proxy, https_proxy, NO_PROXY, no_proxy, ALL_PROXY) configured. Both
    uppercase and lowercase variants are set for maximum compatibility.

    Useful for:
    • Tools that don't respect system proxy settings
    • Temporary proxy usage without modifying shell environment
    • Testing through debugging proxies (mitmproxy, Burp, Charles)
    • Routing traffic through SSH tunnels or Tor

${C_BOLD}OPTIONS${C_RESET}
    -p, --preset NAME   Use a preset proxy configuration
    -u, --url URL       Use custom proxy URL
    -s, --socks URL     Use SOCKS proxy (sets ALL_PROXY)
    -n, --no-proxy LIST Comma-separated hosts to bypass (default: localhost,...)
    --shell             Start interactive shell with proxy configured
    --env               Print export commands (for eval)
    --test              Test proxy connectivity
    --list              List available presets
    -v, --verbose       Show proxy configuration before running
    -h, --help          Show this help message
    --version           Show version information

${C_BOLD}PRESETS${C_RESET}
$(for preset in "${!PROXY_PRESETS[@]}"; do
    printf "    %-15s %s\n" "${preset}" "${PROXY_PRESETS[${preset}]}"
done | sort || true)

${C_BOLD}EXAMPLES${C_RESET}
    # Run curl through local proxy
    ${SCRIPT_NAME} -u http://127.0.0.1:8080 curl https://api.example.com

    # Use mitmproxy preset
    ${SCRIPT_NAME} -p mitmproxy curl -k https://httpbin.org/ip

    # Route git through corporate proxy
    ${SCRIPT_NAME} -p corporate git clone https://github.com/user/repo

    # Use SOCKS proxy (e.g., SSH tunnel)
    ${SCRIPT_NAME} -s socks5://127.0.0.1:1080 wget https://example.com

    # Start shell with proxy configured
    ${SCRIPT_NAME} -p local --shell

    # Export for current shell (use with eval)
    eval "\$(${SCRIPT_NAME} -p local --env)"

    # Test proxy connectivity
    ${SCRIPT_NAME} -u http://127.0.0.1:8080 --test

    # Bypass proxy for internal hosts
    ${SCRIPT_NAME} -p corporate -n "*.internal.com,10.*" curl https://api.example.com

${C_BOLD}CONFIGURATION${C_RESET}
    Default proxy can be set via:
    1. Command-line options (-u, -p)
    2. Environment variables (PROXY_HTTP, PROXY_HTTPS, PROXY_SOCKS)
    3. Config file: ${PROXY_CONFIG_FILE}

    Config file format (shell):
        PROXY_HTTP="http://proxy.example.com:8080"
        PROXY_HTTPS="http://proxy.example.com:8080"
        NO_PROXY_LIST="localhost,127.0.0.1,.internal.com"

        # Custom presets (add to PROXY_PRESETS array)
        PROXY_PRESETS[myproxy]="http://myproxy:3128"

${C_BOLD}ENVIRONMENT${C_RESET}
    PROXY_HTTP          Default HTTP proxy URL
    PROXY_HTTPS         Default HTTPS proxy URL
    PROXY_SOCKS         Default SOCKS proxy URL (sets ALL_PROXY)
    NO_PROXY_LIST       Hosts to bypass proxy
    PROXY_DEBUG         Enable debug output (set to 1)
    NO_COLOR            Disable colored output (set to 1)

${C_BOLD}NOTES${C_RESET}
    • For HTTPS inspection, you may need to trust the proxy's CA certificate
    • Use -k or --insecure with curl when using MITM proxies
    • Some applications only check lowercase or uppercase variants
    • SOCKS proxies require applications that support SOCKS or tools like proxychains

${C_BOLD}EXIT CODES${C_RESET}
    0   Success (or command's exit code in passthrough mode)
    1   General error
    2   Proxy not reachable (with --test)
    3   Invalid preset or configuration

${C_BOLD}VERSION${C_RESET}
    ${SCRIPT_VERSION}

EOF
}

# =============================================================================
# Utilities
# =============================================================================

# Load config file if it exists
load_config() {
    if [[ -f "${PROXY_CONFIG_FILE}" ]]; then
        debug "Loading config from ${PROXY_CONFIG_FILE}"
        # shellcheck source=/dev/null
        source "${PROXY_CONFIG_FILE}"
    fi
}

# Parse proxy URL and validate
validate_proxy_url() {
    local url="$1"
    local name="${2:-proxy}"

    # Basic validation - should start with http://, https://, or socks://
    if [[ ! "${url}" =~ ^(https?|socks[45]?)://[^[:space:]]+ ]]; then
        die "Invalid ${name} URL: ${url}\nExpected format: http://host:port or socks5://host:port"
    fi

    debug "Validated ${name}: ${url}"
}

# Build proxy environment variables
build_proxy_env() {
    local http_proxy="${1:-}"
    local https_proxy="${2:-${http_proxy}}"
    local socks_proxy="${3:-}"
    local no_proxy="${4:-localhost,127.0.0.1,::1}"

    local env_vars=()

    if [[ -n "${http_proxy}" ]]; then
        env_vars+=(
            "HTTP_PROXY=${http_proxy}"
            "http_proxy=${http_proxy}"
        )
    fi

    if [[ -n "${https_proxy}" ]]; then
        env_vars+=(
            "HTTPS_PROXY=${https_proxy}"
            "https_proxy=${https_proxy}"
        )
    fi

    if [[ -n "${socks_proxy}" ]]; then
        env_vars+=(
            "ALL_PROXY=${socks_proxy}"
            "all_proxy=${socks_proxy}"
        )
    fi

    if [[ -n "${no_proxy}" ]]; then
        env_vars+=(
            "NO_PROXY=${no_proxy}"
            "no_proxy=${no_proxy}"
        )
    fi

    printf '%s\n' "${env_vars[@]}"
}

# Test proxy connectivity
test_proxy() {
    local proxy_url="$1"

    info "Testing proxy: ${proxy_url}"

    # Extract host and port from URL
    local host port
    if [[ "${proxy_url}" =~ ^[a-z0-9]+://([^:/]+):([0-9]+) ]]; then
        host="${BASH_REMATCH[1]}"
        port="${BASH_REMATCH[2]}"
    elif [[ "${proxy_url}" =~ ^[a-z0-9]+://([^:/]+) ]]; then
        host="${BASH_REMATCH[1]}"
        port="8080"  # default
    else
        die "Cannot parse proxy URL: ${proxy_url}"
    fi

    debug "Testing connectivity to ${host}:${port}"

    # Test TCP connectivity
    if command -v nc &>/dev/null; then
        if nc -z -w 3 "${host}" "${port}" 2>/dev/null; then
            success "Proxy is reachable at ${host}:${port}"
        else
            die "Cannot connect to proxy at ${host}:${port}"
        fi
    elif command -v timeout &>/dev/null; then
        if timeout 3 bash -c "echo >/dev/tcp/${host}/${port}" 2>/dev/null; then
            success "Proxy is reachable at ${host}:${port}"
        else
            die "Cannot connect to proxy at ${host}:${port}"
        fi
    else
        warn "Cannot test connectivity (nc or timeout not available)"
    fi

    # Test HTTP if curl is available
    if command -v curl &>/dev/null; then
        info "Testing HTTP through proxy..."
        local test_url="http://httpbin.org/ip"

        if curl -s -m 10 --proxy "${proxy_url}" "${test_url}" &>/dev/null; then
            local result
            result=$(curl -s -m 10 --proxy "${proxy_url}" "${test_url}" 2>/dev/null || true)
            success "HTTP proxy working"
            if [[ -n "${result}" ]]; then
                printf "%sResponse: %s%s\n" "${C_DIM}" "${result}" "${C_RESET}"
            fi
        else
            warn "HTTP test failed (proxy may require authentication or only support HTTPS)"
        fi
    fi
}

# List available presets
list_presets() {
    printf "%sAvailable proxy presets:%s\n" "${C_BOLD}" "${C_RESET}"
    printf "%s─────────────────────────────────────────%s\n" "${C_DIM}" "${C_RESET}"
    for preset in $(printf '%s\n' "${!PROXY_PRESETS[@]}" | sort); do
        printf "  %s%-15s%s %s\n" "${C_CYAN}" "${preset}" "${C_RESET}" "${PROXY_PRESETS[${preset}]}"
    done
    printf "\n%sUse: %s -p <preset> <command>%s\n" "${C_DIM}" "${SCRIPT_NAME}" "${C_RESET}"
}

# =============================================================================
# Main
# =============================================================================

main() {
    local proxy_url=""
    local socks_url=""
    local no_proxy="${NO_PROXY_LIST}"
    local verbose=false
    local shell_mode=false
    local env_mode=false
    local test_mode=false

    # Load config file first
    load_config

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                show_help
                exit 0
                ;;
            --version)
                printf "%s version %s\n" "${SCRIPT_NAME}" "${SCRIPT_VERSION}"
                exit 0
                ;;
            --list)
                list_presets
                exit 0
                ;;
            -p|--preset)
                [[ $# -lt 2 ]] && die "Option $1 requires an argument"
                local preset_name="$2"
                if [[ -z "${PROXY_PRESETS[${preset_name}]:-}" ]]; then
                    die "Unknown preset: ${preset_name}\nUse --list to see available presets"
                fi
                proxy_url="${PROXY_PRESETS[${preset_name}]}"
                shift 2
                ;;
            -u|--url)
                [[ $# -lt 2 ]] && die "Option $1 requires an argument"
                proxy_url="$2"
                shift 2
                ;;
            -s|--socks)
                [[ $# -lt 2 ]] && die "Option $1 requires an argument"
                socks_url="$2"
                shift 2
                ;;
            -n|--no-proxy)
                [[ $# -lt 2 ]] && die "Option $1 requires an argument"
                no_proxy="$2"
                shift 2
                ;;
            --shell)
                shell_mode=true
                shift
                ;;
            --env)
                env_mode=true
                shift
                ;;
            --test)
                test_mode=true
                shift
                ;;
            -v|--verbose)
                verbose=true
                PROXY_DEBUG=1
                export PROXY_DEBUG
                shift
                ;;
            --)
                shift
                break
                ;;
            -*)
                die "Unknown option: $1 (use --help for usage)"
                ;;
            *)
                break
                ;;
        esac
    done

    # Use defaults if no proxy specified
    if [[ -z "${proxy_url}" && -z "${socks_url}" ]]; then
        if [[ -n "${PROXY_SOCKS}" ]]; then
            socks_url="${PROXY_SOCKS}"
        elif [[ -n "${PROXY_HTTP}" ]]; then
            proxy_url="${PROXY_HTTP}"
        fi
    fi

    # Still no proxy?
    if [[ -z "${proxy_url}" && -z "${socks_url}" ]]; then
        if [[ "${test_mode}" == "true" || "${env_mode}" == "true" || "${shell_mode}" == "true" || $# -gt 0 ]]; then
            die "No proxy specified. Use -u URL, -p PRESET, or configure PROXY_HTTP"
        fi
        show_help
        exit 0
    fi

    # Validate URLs
    [[ -n "${proxy_url}" ]] && validate_proxy_url "${proxy_url}" "HTTP proxy"
    [[ -n "${socks_url}" ]] && validate_proxy_url "${socks_url}" "SOCKS proxy"

    # Handle test mode
    if [[ "${test_mode}" == "true" ]]; then
        test_proxy "${proxy_url:-${socks_url}}"
        exit 0
    fi

    # Build environment
    local env_lines
    env_lines=$(build_proxy_env "${proxy_url}" "${proxy_url}" "${socks_url}" "${no_proxy}")

    # Handle env mode (for eval)
    if [[ "${env_mode}" == "true" ]]; then
        while IFS= read -r line; do
            printf 'export %s\n' "${line}"
        done <<< "${env_lines}"
        exit 0
    fi

    # Show configuration if verbose
    if [[ "${verbose}" == "true" ]]; then
        printf "%sProxy configuration:%s\n" "${C_BOLD}" "${C_RESET}"
        while IFS= read -r line; do
            printf "  %s%s%s\n" "${C_CYAN}" "${line}" "${C_RESET}"
        done <<< "${env_lines}"
        printf "\n"
    fi

    # Build env array for command execution
    local env_array=()
    while IFS= read -r line; do
        env_array+=("${line}")
    done <<< "${env_lines}"

    # Handle shell mode
    if [[ "${shell_mode}" == "true" ]]; then
        local shell_cmd="${SHELL:-/bin/bash}"
        info "Starting shell with proxy configured..."
        printf "%s(Exit shell to remove proxy settings)%s\n" "${C_DIM}" "${C_RESET}"
        exec env "${env_array[@]}" "${shell_cmd}"
    fi

    # Require command
    if [[ $# -eq 0 ]]; then
        die "No command specified. Use --shell for interactive shell, or provide a command."
    fi

    # Execute command with proxy environment
    debug "Executing: $*"
    exec env "${env_array[@]}" "$@"
}

# Handle interrupts
trap 'exit 130' INT TERM

main "$@"
