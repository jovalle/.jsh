# .jshrc - Shell Agnostic Configuration

# Exit early for non-interactive shells to save startup time
[[ $- != *i* ]] && return

# ============================================================================
# GRACEFUL DEGRADATION PATTERNS
# ============================================================================
#
# jsh supports multiple environments with varying tool availability:
# - macos-personal: Full tool access
# - macos-corporate: Restricted, may lack admin rights
# - truenas: Read-only system, minimal tools
# - ssh-remote: Minimal environment
# - linux-generic: Variable tool availability
#
# This config uses these patterns for graceful degradation:
#
# 1. SILENT SKIP: Features that silently skip when unavailable
#    `command -v tool > /dev/null 2>&1 && alias x=tool`
#
# 2. DEBUG LOGGING: Features that log skip to debug (JSH_DEBUG=1)
#    `_jsh_try_eval "tool" "$(tool init bash)"`
#
# 3. HELPFUL ERROR: Functions that explain what's missing
#    `require_dependency "jq"` (shows environment-specific install guidance)
#
# Set JSH_DEBUG=1 to see what's being skipped during startup.
# ============================================================================

# ============================================================================
# 1. ESSENTIAL EXPORTS
# ============================================================================

# Core paths and editors
export CLICOLORS=1         # Colorize output
export EDITOR=vim          # Default CLI editor
export VISUAL=vim          # Default full-screen editor
export TERM=xterm-256color # Terminal type for 256 colors
# SH variable might differ, but let's try to detect
export SH=${SHELL##*/}

# Project/work directories
export GIT_BASE=${HOME}/projects     # Git projects base
export WORK_DIR=${GIT_BASE}          # Default work directory
export JSH=${JSH_ROOT:-${HOME}}/.jsh # Ideal JSH location
export JSH_CUSTOM=${HOME}/.jsh_local # Local overrides (optional)
export GEM_HOME="${HOME}/.gem"         # Ruby gems location

# Silence/optimize specific tools
export DIRENV_LOG_FORMAT=           # Silence direnv for p10k
export GITSTATUS_RESPONSE_TIMEOUT=5 # Quick timeout for git status
export DIRENV_WARN_TIMEOUT=30s      # Direnv timeout
export PYTHONDONTWRITEBYTECODE=1    # No .pyc files on import

# Shell environment
# Default locale - use C.UTF-8 as fallback if en_US.UTF-8 unavailable
_detect_locale() {
  local cache_file="${HOME}/.cache/jsh/locale"
  if [[ -f "${cache_file}" ]] && [[ -n "$(cat "${cache_file}" 2>/dev/null)" ]]; then
    cat "${cache_file}"
    return
  fi

  local locale_result
  if locale -a 2>/dev/null | grep -qE "^en_US\.UTF-8$|^en_US\.utf8$"; then
    locale_result="en_US.UTF-8"
  elif locale -a 2>/dev/null | grep -qE "^C\.UTF-8$|^C\.utf8$"; then
    locale_result="C.UTF-8"
  else
    locale_result="C"
  fi

  mkdir -p "$(dirname "${cache_file}")"
  echo "${locale_result}" > "${cache_file}"
  echo "${locale_result}"
}

export LANG=$(_detect_locale)
export LC_ALL="${LANG}"
unset -f _detect_locale
export XDG_CONFIG_HOME="${HOME}/.config" # Where apps should store config files

# Terminal optimizations
export LESS="-RXE" # No wrapping, no clearing, exit on EOF

# ---- Color helper functions ---
if command -v tput > /dev/null 2>&1; then
  error() { echo -e "$(tput setaf 1)$*$(tput sgr0)"; }   # Red
  warn() { echo -e "$(tput setaf 3)$*$(tput sgr0)"; }    # Yellow/Orange
  success() { echo -e "$(tput setaf 2)$*$(tput sgr0)"; } # Green
  info() { echo -e "$(tput setaf 4)$*$(tput sgr0)"; }    # Blue
else
  error() { echo -e "\033[31m$*\033[0m"; }   # Red
  warn() { echo -e "\033[33m$*\033[0m"; }    # Yellow
  success() { echo -e "\033[32m$*\033[0m"; } # Green
  info() { echo -e "\033[34m$*\033[0m"; }    # Blue
fi

# ============================================================================
# 1b. ENVIRONMENT DETECTION
# ============================================================================

# Detect runtime environment type for graceful degradation
# JSH_ENV will be one of: macos-personal, macos-corporate, truenas, ssh-remote, linux-generic
if [[ -f "${JSH}/src/lib/environment.sh" ]]; then
  # shellcheck disable=SC1091
  source "${JSH}/src/lib/environment.sh"
  get_jsh_env > /dev/null  # Populate JSH_ENV (suppress output)
fi

# ============================================================================
# 1c. GRACEFUL DEGRADATION
# ============================================================================

# Load graceful degradation helpers for safe feature loading
if [[ -f "${JSH}/src/lib/graceful.sh" ]]; then
  # shellcheck disable=SC1091
  source "${JSH}/src/lib/graceful.sh"
fi

# ============================================================================
# 2. PATH SETUP
# ============================================================================

# Paths - ORDER MATTERS (priority: local > jsh > system)
# Note: Array syntax is bash/zsh compatible
_build_path_prefix() {
  local cache_file="${HOME}/.cache/jsh/path_prefix"
  local cache_mtime_file="${cache_file}.mtime"
  local current_mtime=$(date +%s)

  # Cache valid for 1 hour (3600 seconds)
  if [[ -f "${cache_file}" ]] && [[ -f "${cache_mtime_file}" ]]; then
    local cached_mtime=$(cat "${cache_mtime_file}")
    if (( current_mtime - cached_mtime < 3600 )); then
      cat "${cache_file}"
      return
    fi
  fi

  # Rebuild path
  local local_paths=(
    "${HOME}/.local/bin"
    "${JSH}"     # jsh CLI script at repo root
    "${JSH}/bin" # Additional utilities
    "${GEM_HOME}/bin"
    "${HOME}/.cargo/bin"
    "${JSH}/.fzf/bin"
    "${HOME}/go/bin"
    "${HOME}/.linuxbrew/bin"
    "${HOME}/linuxbrew/.linuxbrew/bin"
    "/home/linuxbrew/.linuxbrew/bin"
    "/opt/homebrew/bin"
    "/opt/homebrew/opt/ruby/bin"
  )

  local local_prefix=""
  for p in "${local_paths[@]}"; do
    if [[ -d "${p}" ]]; then
      if [[ -z "${local_prefix}" ]]; then
        local_prefix="${p}"
      else
        local_prefix="${local_prefix}:${p}"
      fi
    fi
  done

  mkdir -p "$(dirname "${cache_file}")"
  echo "${local_prefix}" > "${cache_file}"
  echo "${current_mtime}" > "${cache_mtime_file}"
  echo "${local_prefix}"
}

local_prefix=$(_build_path_prefix)
if [[ -n "${local_prefix}" ]]; then
  export PATH="${local_prefix}:${PATH}"
fi
unset local_prefix
unset -f _build_path_prefix

# ============================================================================
# 2b. HOMEBREW ENVIRONMENT SETUP
# ============================================================================

# Initialize Homebrew/Linuxbrew environment if available
# This sets up HOMEBREW_PREFIX, HOMEBREW_CELLAR, MANPATH, INFOPATH, etc.
# Note: Root users should use 'jsh brew' which delegates to BREW_USER
_init_brew_env() {
  # Skip for root - root should use 'jsh brew' for delegation
  [[ "${EUID:-$(id -u)}" -eq 0 ]] && return 0

  local cache_file="${HOME}/.cache/jsh/brew_shellenv"
  local cache_mtime_file="${cache_file}.mtime"
  local current_mtime=$(date +%s)

  # Cache valid for 24 hours (86400 seconds)
  if [[ -f "${cache_file}" ]] && [[ -f "${cache_mtime_file}" ]]; then
    local cached_mtime=$(cat "${cache_mtime_file}")
    if (( current_mtime - cached_mtime < 86400 )); then
      source "${cache_file}"
      return 0
    fi
  fi

  local brew_candidates=(
    "/home/linuxbrew/.linuxbrew/bin/brew"
    "/opt/homebrew/bin/brew"
    "/usr/local/bin/brew"
    "${HOME}/.linuxbrew/bin/brew"
  )

  for brew_bin in "${brew_candidates[@]}"; do
    if [[ -x "${brew_bin}" ]]; then
      mkdir -p "$(dirname "${cache_file}")"
      "${brew_bin}" shellenv > "${cache_file}" 2>/dev/null
      echo "${current_mtime}" > "${cache_mtime_file}"
      source "${cache_file}"
      return 0
    fi
  done
  return 1
}
_init_brew_env
unset -f _init_brew_env

# ============================================================================
# 3. SHELL ALIASES
# ============================================================================

# ---- Directory Navigation ----
alias ..='cd ../' .2='cd ../../' .3='cd ../../../' .4='cd ../../../../' .5='cd ../../../../../' .6='cd ../../../../../../'

# ---- File Operations ----
alias cp='cp -iv' mv='mv -iv' rm='rm -i' mkdir='mkdir -pv'
# dud/duf might vary by OS/shell but usually fine
alias dud='du -d 1 -h'
alias duf='du -sh *'

# Colorize essential binaries
alias grep='grep --color=auto'

# ls color support detection
if command ls --color -d . > /dev/null 2>&1; then
  alias ls='ls --color=auto -a'
  export LS_PREVIEW="ls --color=always"
elif command ls -G -d . > /dev/null 2>&1; then
  alias ls='ls -G -a'
  export LS_PREVIEW="ls -G"
else
  alias ls='ls -a'
  export LS_PREVIEW="ls"
fi

# diff color support detection
if command diff --color /dev/null /dev/null > /dev/null 2>&1; then
  alias diff='diff --color=auto'
fi

alias l='ls -l' ll='ls -la' lll='ls -laFh'
alias psg='ps aux | grep -i' psl='ps aux | less'

# t - Wrapper for supercrabtree's k
# A more informative 'ls' replacement that displays additional file information
# including git status, file permissions, size, and last modified time
t() {
  if [[ $# -eq 0 ]]; then
    if command -v k > /dev/null 2>&1; then k; else ls -la; fi
  else
    local all_dirs=true
    for arg in "$@"; do
      [[ ! -d "${arg}" ]] && {
        all_dirs=false
        break
      }
    done

    if [[ "${all_dirs}" == true ]]; then
      for dir in "$@"; do
        if command -v k > /dev/null 2>&1; then k "${dir}"; else ls -la "${dir}"; fi
      done
    else
      touch "$@"
    fi
  fi
}

# ---- Permissions ----
alias 000='chmod 000' 640='chmod 640' 644='chmod 644' 755='chmod 755' 775='chmod 775' mx='chmod a+x'

# ---- Terminal & System ----
alias c='clear' ccd='clear && cd' e='exit' fix_stty='stty sane' epochtime='date +%s'
alias ts='date +%F-%H%M' timestamp='date "+%Y%m%dT%H%M%S"'
# path alias needs echo -e which is bash/zsh compatible usually
alias path='echo -e ${PATH//:/\\n}'
alias perm='stat --printf "%a %n \n "'
alias whatis='declare -f'
alias which='type -a'
alias h='history'

# ---- Superuser ----
alias _='sudo' please='sudo'

# ---- System Commands ----
alias g='grep -i' edit='vim' v='vim'

# ---- Git ----
alias g_='git commit -m'
# git+ uses $() which is standard
alias git+='git push --set-upstream origin $(git rev-parse --abbrev-ref HEAD)'
alias git-='git reset HEAD~1'
alias gl='git log --graph --oneline'
alias gdiff='git diff --name-only master'
alias gvimdiff='git difftool --tool=vimdiff --no-prompt'

# ---- Kubernetes ----
alias k='kubectl' kav='kubectl api-versions' kci='kubectl cluster-info' kaf='kubectl apply -f'
alias kctx='kubectx' kns='kubens'
alias kctx+='kubectx --add' kctx-='kubectx --delete'
alias kdf='kubectl delete -f' kexec='kubectl exec -it' netshoot='kubectl run tmp-shell --rm -i --tty --image nicolaka/netshoot'

# ---- Infrastructure & Tools ----
alias a='ansible' ap='ansible-playbook' av='ansible-vault' tf='terraform' pn='pnpm'

# ---- SSH & Remote ----
alias sshx='eval $(ssh-agent) && ssh-add 2>/dev/null'
# Proxy aliases
# shellcheck disable=SC2154
alias proxy+='export {http,https}_proxy,{HTTP,HTTPS}_PROXY=${PROXY_ENDPOINT}; export {NO_PROXY,no_proxy}=${PROXY_ENDPOINT:-go,localhost}'
alias proxy-='unset {http,https}_proxy,{HTTP,HTTPS}_PROXY,NO_PROXY,no_proxy'

# ---- Development & Tmux ----
alias vz='vim ~/.zshrc'
alias vb='vim ~/.bashrc'
alias vj='vim ~/.jshrc'
alias tmux='tmux -2'

# ---- GNU Tool Replacements ----
# (Keeping the checks)
command -v gawk > /dev/null 2>&1 && alias awk='command gawk'
command -v gbase64 > /dev/null 2>&1 && alias base64='command gbase64'
command -v gbasename > /dev/null 2>&1 && alias basename='command gbasename'
command -v gcat > /dev/null 2>&1 && alias cat='command gcat'
command -v gchmod > /dev/null 2>&1 && alias chmod='command gchmod'
command -v gchown > /dev/null 2>&1 && alias chown='command gchown'
command -v gcp > /dev/null 2>&1 && alias cp='command gcp -iv'
command -v gcut > /dev/null 2>&1 && alias cut='command gcut'
command -v gdate > /dev/null 2>&1 && alias date='command gdate'
command -v gdd > /dev/null 2>&1 && alias dd='command gdd'
command -v gdf > /dev/null 2>&1 && alias df='command gdf'
command -v gdirname > /dev/null 2>&1 && alias dirname='command gdirname'
command -v gdu > /dev/null 2>&1 && alias du='command gdu'
command -v gecho > /dev/null 2>&1 && alias echo='command gecho'
command -v genv > /dev/null 2>&1 && alias env='command genv'
command -v gfind > /dev/null 2>&1 && alias find='command gfind'
command -v ggrep > /dev/null 2>&1 && alias grep='command ggrep --color=auto -i'
command -v ghead > /dev/null 2>&1 && alias head='command ghead'
command -v gln > /dev/null 2>&1 && alias ln='command gln'
command -v gls > /dev/null 2>&1 && alias gls='command gls --color=auto' ls='command gls --color=auto -a' l='command gls --color=auto -l' ll='command gls --color=auto -la' lll='command gls --color=auto -laFh'
command -v gmkdir > /dev/null 2>&1 && alias mkdir='command gmkdir -pv'
command -v gmv > /dev/null 2>&1 && alias mv='command gmv -iv'
command -v grm > /dev/null 2>&1 && alias rm='command grm -i'
command -v gsed > /dev/null 2>&1 && alias sed='command gsed'
command -v gsort > /dev/null 2>&1 && alias sort='command gsort'
command -v gtail > /dev/null 2>&1 && alias tail='command gtail'
command -v gtar > /dev/null 2>&1 && alias tar='command gtar'
command -v gtouch > /dev/null 2>&1 && alias touch='command gtouch'
command -v gtr > /dev/null 2>&1 && alias tr='command gtr'
command -v guniq > /dev/null 2>&1 && alias uniq='command guniq'
command -v gwc > /dev/null 2>&1 && alias wc='command gwc'
command -v gwhich > /dev/null 2>&1 && alias which='command gwhich'
command -v gxargs > /dev/null 2>&1 && alias xargs='command gxargs'

# ---- Tool Replacements ----
command -v eza > /dev/null 2>&1 && alias l='eza -a -l --git --icons --color=always' ll='eza --git --icons --level=2 --long --tree --long --color=always' lll='eza --git --icons --long --tree --color=always'
command -v hx > /dev/null 2>&1 && alias vim='hx'
command -v nvim > /dev/null 2>&1 && alias vim='nvim'
command -v vim > /dev/null 2>&1 && alias vi='vim'

# ============================================================================
# 4. SHELL FUNCTIONS
# ============================================================================

caffeinate_cmd() { gnome-session-inhibit --inhibit idle:sleep sleep infinity; }
ffpid() { lsof -t -c "$@"; }
quiet() {
  if [[ $# -eq 0 ]]; then
    return
  else
    "$@" > /dev/null 2>&1
  fi
}

duh() {
  if [[ $(uname) == "Darwin" ]]; then
    du -hd 1 "${1:-.}" | sort -h
  else
    du -h --max-depth=1 "${1:-.}" | sort -h
  fi
}

extract() {
  if [[ ! -f "$1" ]]; then
    error "'$1' is not a valid file"
    return 1
  fi
  case "$1" in
    *.tar.bz2) tar xjf "$1" ;;
    *.tar.gz) tar xzf "$1" ;;
    *.bz2) bunzip2 "$1" ;;
    *.rar) unrar e "$1" ;;
    *.gz) gunzip "$1" ;;
    *.tar) tar xf "$1" ;;
    *.tbz2) tar xjf "$1" ;;
    *.tgz) tar xzf "$1" ;;
    *.zip) unzip "$1" ;;
    *.Z) uncompress "$1" ;;
    *.7z) 7z x "$1" ;;
    *)
      error "'$1' cannot be extracted"
      return 1
      ;;
  esac
}

ff() { /usr/bin/find . -name "$@"; }
ffs() { /usr/bin/find . -name "$*"'*'; }
ffe() { /usr/bin/find . -name '*'"$*"; }

http2ssh() {
  REPO_URL=$(git remote -v | grep -m1 '^origin' | sed -Ene's#.*(https://[^[:space:]]*).*#\1#p')
  [[ -z "${REPO_URL}" ]] && {
    error "Could not identify repo URL"
    return 1
  }

  USER=$(echo "${REPO_URL}" | sed -Ene's#https://github.com/([^/]*)/(.*)#\1#p')
  [[ -z "${USER}" ]] && {
    error "Could not identify user"
    return 2
  }

  REPO=$(echo "${REPO_URL}" | sed -Ene's#https://github.com/([^/]*)/(.*)#\2#p')
  [[ -z "${REPO}" ]] && {
    error "Could not identify repo"
    return 3
  }

  NEW_URL="git@github.com:${USER}/${REPO}"
  warn "Changing repo URL from: '${REPO_URL}' to: '${NEW_URL}'"

  if git remote set-url origin "${NEW_URL}"; then
    success "New URL set"
  else
    error "Failed to set URL"
    return 4
  fi
}

nukem() {
  [[ -z "$1" ]] && {
    echo "Usage: $0 <namespace>"
    return 1
  }
  warn "Removing finalizers from namespace: $1"
  if kubectl get namespace "$1" -o json | tr -d "\n" |
    sed "s/\"finalizers\": \[[^]]\+\]/\"finalizers\": []/" |
    kubectl replace --raw "/api/v1/namespaces/$1/finalize" -f -; then
    success "Finalizers removed"
  else
    error "Failed"
    return 2
  fi
}

ipmi() {
  [[ -z "${IPMI_HOST}" || -z "${IPMI_USER}" || -z "${IPMI_CRED_FILE}" ]] &&
    {
      error "IPMI env vars not set"
      return 1
    }
  [[ $1 == "fan" ]] || {
    ipmitool -I lanplus -H "${IPMI_HOST}" -U "${IPMI_USER}" -f "${IPMI_CRED_FILE}" "$@"
    return
  }
  ipmitool -I lanplus -H "${IPMI_HOST}" -U "${IPMI_USER}" -f "${IPMI_CRED_FILE}" raw 0x30 0x30 0x01 0x00
  if [[ $# -eq 2 ]]; then
    local hex_speed
    hex_speed=$(printf '%x\n' "$2")
    ipmitool -I lanplus -H "${IPMI_HOST}" -U "${IPMI_USER}" -f "${IPMI_CRED_FILE}" raw 0x30 0x30 0x02 0xff "0x${hex_speed}"
  else
    error "Usage: ipmi fan <speed_0-255>"
    return 1
  fi
}

proxy() {
  local PROXY="${PROXY_ENDPOINT:-go,localhost}"
  env http_proxy="${PROXY}" https_proxy="${PROXY}" HTTP_PROXY="${PROXY}" HTTPS_PROXY="${PROXY}" \
    NO_PROXY="${PROXY}" no_proxy="${PROXY}" "$@"
}

rcode() {
  [[ $# -ne 2 ]] && {
    echo "Usage: rcode <ssh_host> <remote_path>"
    return 1
  }
  code --remote "ssh-remote+${1}" "${2}"
}

# Test minimal zsh prompt (without p10k)
zsh-minimal() {
  env ZSH_MINIMAL=1 zsh
}

# Git User Profile Management
gu() {
  local profile_file="${JSH}/configs/git/profiles.json"

  # Check dependencies with environment-aware guidance
  if ! command -v jq > /dev/null 2>&1; then
    if [[ -f "${JSH}/src/lib/dependencies.sh" ]]; then
      source "${JSH}/src/lib/dependencies.sh"
      require_dependency "jq"
    else
      error "jq is required. Install with: brew install jq (macOS) or apt install jq (Linux)"
    fi
    return 1
  fi

  if ! command -v git > /dev/null 2>&1; then
    error "git is required but not installed"
    return 1
  fi

  # Check if we're in a git repository
  if ! git rev-parse --git-dir > /dev/null 2>&1; then
    error "Not in a git repository"
    return 1
  fi

  # Check if config file exists
  if [[ ! -f "${profile_file}" ]]; then
    error "Git profiles config not found: ${profile_file}"
    info "Create it with the following structure:"
    cat << 'EXAMPLE'
{
  "profiles": {
    "personal": {
      "name": "Your Name",
      "email": "personal@example.com",
      "username": "personal-github"
    },
    "work": {
      "name": "Your Work Name",
      "email": "work@company.com",
      "username": "work-github"
    }
  }
}
EXAMPLE
    return 1
  fi

  # If no argument, show current config and available profiles
  if [[ $# -eq 0 ]]; then
    info "Current git configuration:"
    echo "  Name:     $(git config user.name || echo '<not set>')"
    echo "  Email:    $(git config user.email || echo '<not set>')"
    echo "  Username: $(git config github.user || echo '<not set>')"
    echo ""
    info "Available profiles:"
    jq -r '.profiles | keys[]' "${profile_file}" | sed 's/^/  - /'
    echo ""
    info "Usage: gu <profile_name>"
    return 0
  fi

  local profile_name="$1"

  # Extract profile data
  local name email username
  name=$(jq -r ".profiles.\"${profile_name}\".name // empty" "${profile_file}")
  email=$(jq -r ".profiles.\"${profile_name}\".email // empty" "${profile_file}")
  username=$(jq -r ".profiles.\"${profile_name}\".username // empty" "${profile_file}")

  # Check if profile exists
  if [[ -z "${name}" || -z "${email}" ]]; then
    error "Profile '${profile_name}' not found in ${profile_file}"
    info "Available profiles:"
    jq -r '.profiles | keys[]' "${profile_file}" | sed 's/^/  - /'
    return 1
  fi

  # Apply git config locally (repository-level)
  info "Configuring git user profile: ${profile_name}"
  git config user.name "${name}"
  git config user.email "${email}"

  # Set github.user if username is provided (useful for gh CLI and other tools)
  if [[ -n "${username}" ]]; then
    git config github.user "${username}"
  fi

  # Verify configuration
  success "Git profile '${profile_name}' applied successfully!"
  echo "  Name:     ${name}"
  echo "  Email:    ${email}"
  [[ -n "${username}" ]] && echo "  Username: ${username}"

  # Show scope
  info "Configuration is local to this repository: $(git rev-parse --show-toplevel)"
}

# Path deduplication (POSIX compliant using awk)
dedup_path() {
  if [[ -n "${PATH}" ]]; then
    PATH=$(echo -n "${PATH}" | awk -v RS=: -v ORS=: '!a[$0]++' | sed 's/:$//')
    export PATH
  fi
}
dedup_path

# Check for outdated Homebrew packages (graceful if unavailable)
if command -v brew > /dev/null 2>&1 && command -v jsh > /dev/null 2>&1; then
  # Use timeout to prevent hung startup if brew is slow
  if declare -f _jsh_with_timeout &>/dev/null; then
    _jsh_with_timeout 3 jsh brew check --quiet 2>/dev/null || true
  else
    # Fallback if graceful.sh not loaded
    jsh brew check --quiet 2>/dev/null || true
  fi
else
  _jsh_debug "startup" "Skipping brew check (brew or jsh unavailable)"
fi

# Navigation: Search path for cd
export CDPATH=".:~:~/projects:~/.jsh"

# Safety: Prevent file overwrite on stdout redirection
# History hygiene: Ignore specific commands
if [[ -n "${BASH_VERSION}" ]]; then
  set -o noclobber
  export HISTIGNORE="&:[ ]*:exit:ls:bg:fg:history:clear"
elif [[ -n "${ZSH_VERSION}" ]]; then
  setopt NO_CLOBBER
  export HISTORY_IGNORE="(ls|cd|pwd|exit|cd ..)"
fi

# ============================================================================
# 5. SHELL COMPLETION HELPERS
# ============================================================================

# Helper function to load tool completions (called from shell-specific configs)
# Usage: _jsh_load_completions <shell_name>
_jsh_load_completions() {
  local shell="$1"
  _jsh_debug "completions" "Loading completions for ${shell}"

  # Common completions for all shells (using graceful degradation)
  _jsh_try_eval "direnv" "$(direnv hook "${shell}")"
  _jsh_try_eval "docker" "$(docker completion "${shell}")"
  _jsh_try_completion "task" "eval" "task --completion ${shell}" "${shell}"
  _jsh_try_eval "zoxide" "$(zoxide init "${shell}")"

  _jsh_try_completion "kubectl" "eval" "kubectl completion ${shell}" "${shell}"
  _jsh_try_completion "uc" "eval" "uc completion ${shell}" "${shell}"

  # Shell-specific variations
  case "${shell}" in
    bash)
      _jsh_try_eval "fzf" "$(fzf --bash)"
      ;;
    zsh)
      _jsh_try_completion "fzf" "eval" "fzf --zsh" "${shell}"
      ;;
    *)
      warn "Unknown shell: ${shell}"
      return 1
      ;;
  esac

  # Configure atuin with fzf integration for reverse search
  if command -v atuin > /dev/null 2>&1; then
    _jsh_debug "completions" "Loading atuin integration"
    # Disable default atuin up-arrow binding to use fzf instead
    export ATUIN_NOBIND="true"
    eval "$(atuin init "${shell}")"

    # Bind Ctrl+R to atuin search (keeps the TUI for manual searches)
    case "${shell}" in
      bash)
        bind -x '"\C-r": __atuin_history'
        ;;
      zsh)
        bindkey '^r' atuin-search
        ;;
    esac

    # Custom fzf-based reverse search with atuin data showing relative times
    __atuin_fzf_history() {
      local selected clipboard_cmd

      # Detect clipboard command
      if command -v pbcopy > /dev/null 2>&1; then
        clipboard_cmd="pbcopy"
      elif command -v xclip > /dev/null 2>&1; then
        clipboard_cmd="xclip -selection clipboard"
      elif command -v xsel > /dev/null 2>&1; then
        clipboard_cmd="xsel --clipboard --input"
      elif command -v wl-copy > /dev/null 2>&1; then
        clipboard_cmd="wl-copy"
      else
        clipboard_cmd="cat" # fallback, just prints
      fi

      # Use atuin search to get formatted output with time and command
      # Format: relative_time | duration | command
      selected=$(atuin history list --format "{time} │ {duration} │ {command}" 2> /dev/null |
        fzf --ansi \
          --tiebreak=index \
          --height=40% \
          --reverse \
          --border \
          --prompt="History > " \
          --preview='echo {3..}' \
          --preview-window=up:3:wrap \
          --delimiter='│' \
          --with-nth=1,2,3.. \
          --bind="ctrl-y:execute-silent(echo {3..} | tr -d ' ' | ${clipboard_cmd})+abort" \
          --header='CTRL-R: atuin TUI | CTRL-Y: copy | UP/DOWN: navigate' |
        awk -F'│' '{gsub(/^[[:space:]]+|[[:space:]]+$/, "", $3); print $3}')

      if [[ -n "${selected}" ]]; then
        case "${shell}" in
          bash)
            READLINE_LINE="${selected}"
            READLINE_POINT=${#READLINE_LINE}
            ;;
          zsh)
            # shellcheck disable=SC2034
            BUFFER="${selected}"
            # shellcheck disable=SC2034
            CURSOR=${#BUFFER}
            ;;
        esac
      fi
    }
  fi
}

# Load project navigation functions (project/projects commands)
# shellcheck disable=SC1091
[[ -f "${JSH}/src/lib/projects.sh" ]] && source "${JSH}/src/lib/projects.sh"

# Load local customizations
# shellcheck disable=SC1090
[[ -f "${JSH_CUSTOM}" ]] && source "${JSH_CUSTOM}"
