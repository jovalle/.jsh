# .jshrc - Shell Agnostic Configuration

# ============================================================================
# 1. ESSENTIAL EXPORTS
# ============================================================================

# Core paths and editors
export CLICOLORS=1         # Colorize output
export EDITOR=vim          # Default CLI editor
export VISUAL=vim          # Default full-screen editor
export TERM=xterm-256color # Terminal type for 256 colors
# SH variable might differ, but let's try to detect
export SH=${SHELL##*/}

# Project/work directories
export GIT_BASE=${HOME}/projects     # Git projects base
export WORK_DIR=${GIT_BASE}          # Default work directory
export JSH=${JSH_ROOT:-${HOME}}/.jsh # Ideal JSH location
export JSH_CUSTOM=${HOME}/.jsh_local # Local overrides (optional)
export GEM_HOME="$HOME/.gem"         # Ruby gems location

# Silence/optimize specific tools
export DIRENV_LOG_FORMAT=           # Silence direnv for p10k
export GITSTATUS_RESPONSE_TIMEOUT=5 # Quick timeout for git status
export DIRENV_WARN_TIMEOUT=30s      # Direnv timeout
export PYTHONDONTWRITEBYTECODE=1    # No .pyc files on import

# Shell environment
# Default locale - use C.UTF-8 as fallback if en_US.UTF-8 unavailable
if locale -a 2>/dev/null | grep -qE "^en_US\.UTF-8$|^en_US\.utf8$"; then
  export LANG=en_US.UTF-8
elif locale -a 2>/dev/null | grep -qE "^C\.UTF-8$|^C\.utf8$"; then
  export LANG=C.UTF-8
else
  export LANG=C
fi
# Set LC_ALL only if a valid UTF-8 locale is available
if locale -a 2> /dev/null | grep -q "^en_US.UTF-8\|^en_US.utf8"; then
  export LC_ALL=en_US.UTF-8
elif locale -a 2>/dev/null | grep -qE "^C\.UTF-8$|^C\.utf8$"; then
  export LC_ALL=C.UTF-8
else
  unset LC_ALL  # Prevent invalid locale errors
fi
export XDG_CONFIG_HOME="${HOME}/.config" # Where apps should store config files

# Terminal optimizations
export LESS="-RXE" # No wrapping, no clearing, exit on EOF

# ---- Color helper functions ---
if command -v tput > /dev/null 2>&1; then
  error() { echo -e "$(tput setaf 1)$*$(tput sgr0)"; }   # Red
  warn() { echo -e "$(tput setaf 3)$*$(tput sgr0)"; }    # Yellow/Orange
  success() { echo -e "$(tput setaf 2)$*$(tput sgr0)"; } # Green
  info() { echo -e "$(tput setaf 4)$*$(tput sgr0)"; }    # Blue
else
  error() { echo -e "\033[31m$*\033[0m"; }   # Red
  warn() { echo -e "\033[33m$*\033[0m"; }    # Yellow
  success() { echo -e "\033[32m$*\033[0m"; } # Green
  info() { echo -e "\033[34m$*\033[0m"; }    # Blue
fi

# ============================================================================
# 2. PATH SETUP
# ============================================================================

# Paths - ORDER MATTERS (priority: local > jsh > system)
# Note: Array syntax is bash/zsh compatible
local_paths=(
  "${HOME}/.local/bin"
  "${JSH}"          # jsh CLI script at repo root
  "${JSH}/bin"      # Additional utilities
  "${GEM_HOME}/bin"
  "${JSH}/.fzf/bin"
  "${HOME}/go/bin"
  "${HOME}/.linuxbrew/bin"
  "${HOME}/linuxbrew/.linuxbrew/bin"
  "/home/linuxbrew/.linuxbrew/bin"
  "/opt/homebrew/bin"
  "/opt/homebrew/opt/ruby/bin"
)

local_prefix=""
for p in "${local_paths[@]}"; do
  if [[ -d "${p}" ]]; then
    if [[ -z "${local_prefix}" ]]; then
      local_prefix="${p}"
    else
      local_prefix="${local_prefix}:${p}"
    fi
  fi
done

if [[ -n "${local_prefix}" ]]; then
  export PATH="${local_prefix}:${PATH}"
fi
unset local_paths local_prefix

# ============================================================================
# 2b. HOMEBREW ENVIRONMENT SETUP
# ============================================================================

# Initialize Homebrew/Linuxbrew environment if available
# This sets up HOMEBREW_PREFIX, HOMEBREW_CELLAR, MANPATH, INFOPATH, etc.
# Note: Root users should use 'jsh brew' which delegates to BREW_USER
_init_brew_env() {
  # Skip for root - root should use 'jsh brew' for delegation
  [[ "${EUID:-$(id -u)}" -eq 0 ]] && return 0

  local brew_candidates=(
    "/home/linuxbrew/.linuxbrew/bin/brew"
    "/opt/homebrew/bin/brew"
    "/usr/local/bin/brew"
    "${HOME}/.linuxbrew/bin/brew"
  )

  for brew_bin in "${brew_candidates[@]}"; do
    if [[ -x "${brew_bin}" ]]; then
      eval "$("${brew_bin}" shellenv 2>/dev/null)"
      return 0
    fi
  done
  return 1
}
_init_brew_env
unset -f _init_brew_env

# ============================================================================
# 3. SHELL ALIASES
# ============================================================================

# ---- Directory Navigation ----
alias ..='cd ../' .2='cd ../../' .3='cd ../../../' .4='cd ../../../../' .5='cd ../../../../../' .6='cd ../../../../../../'

# ---- File Operations ----
alias cp='cp -iv' mv='mv -iv' rm='rm -i' mkdir='mkdir -pv'
# dud/duf might vary by OS/shell but usually fine
alias dud='du -d 1 -h' duf='du -sh *'

# Colorize essential binaries
alias grep='grep --color=auto'

# ls color support detection
if command ls --color -d . > /dev/null 2>&1; then
  alias ls='ls --color=auto -a'
  export LS_PREVIEW="ls --color=always"
elif command ls -G -d . > /dev/null 2>&1; then
  alias ls='ls -G -a'
  export LS_PREVIEW="ls -G"
else
  alias ls='ls -a'
  export LS_PREVIEW="ls"
fi

# diff color support detection
if command diff --color /dev/null /dev/null > /dev/null 2>&1; then
  alias diff='diff --color=auto'
fi

alias l='ls -l' ll='ls -la' lll='ls -laFh'
alias psg='ps aux | grep -i' psl='ps aux | less'

# 't' command
t() {
  if [[ $# -eq 0 ]]; then
    if command -v k > /dev/null 2>&1; then k; else ls -la; fi
  else
    local all_dirs=true
    for arg in "$@"; do
      [[ ! -d "$arg" ]] && {
        all_dirs=false
        break
      }
    done

    if [[ "$all_dirs" == true ]]; then
      for dir in "$@"; do
        if command -v k > /dev/null 2>&1; then k "$dir"; else ls -la "$dir"; fi
      done
    else
      touch "$@"
    fi
  fi
}

# ---- Permissions ----
alias 000='chmod 000' 640='chmod 640' 644='chmod 644' 755='chmod 755' 775='chmod 775' mx='chmod a+x'

# ---- Terminal & System ----
alias c='clear' ccd='clear && cd' e='exit' fix_stty='stty sane' epochtime='date +%s'
alias ts='date +%F-%H%M' timestamp='date "+%Y%m%dT%H%M%S"'
# path alias needs echo -e which is bash/zsh compatible usually
alias path='echo -e ${PATH//:/\\n}'
alias perm='stat --printf "%a %n \n "'
alias whatis='declare -f'
alias which='type -a'
alias h='history'

# ---- Superuser ----
alias _='sudo' please='sudo'

# ---- System Commands ----
alias g='grep -i' edit='vim' v='vim'

# ---- Git ----
alias g_='git commit -m'
# git+ uses $() which is standard
alias git+='git push --set-upstream origin $(git rev-parse --abbrev-ref HEAD)'
alias git-='git reset HEAD~1'
alias gl='git log --graph --oneline'
alias gdiff='git diff --name-only master'
alias gvimdiff='git difftool --tool=vimdiff --no-prompt'

# ---- Kubernetes ----
alias k='kubectl' kav='kubectl api-versions' kci='kubectl cluster-info' kaf='kubectl apply -f'
alias kctx='kubectx' kns='kubens'
alias kctx+='kubectx --add' kctx-='kubectx --delete'
alias kdf='kubectl delete -f' kexec='kubectl exec -it' netshoot='kubectl run tmp-shell --rm -i --tty --image nicolaka/netshoot'

# ---- Infrastructure & Tools ----
alias a='ansible' ap='ansible-playbook' av='ansible-vault' tf='terraform' pn='pnpm'

# ---- SSH & Remote ----
alias sshx='eval $(ssh-agent) && ssh-add 2>/dev/null'
# Proxy aliases
# shellcheck disable=SC2154
alias proxy+='export {{http,https}_proxy,{HTTP,HTTPS}_PROXY}=${PROXY_ENDPOINT}; export {NO_PROXY,no_proxy}=${PROXY_ENDPOINT:-go,localhost}'
alias proxy-='unset {{http,https}_proxy,{HTTP,HTTPS}_PROXY,NO_PROXY,no_proxy}'

# ---- Development & Tmux ----
alias vz='vim ~/.zshrc'
alias vb='vim ~/.bashrc'
alias vj='vim ~/.jshrc'
alias tmux='tmux -2'

# ---- GNU Tool Replacements ----
# (Keeping the checks)
command -v gawk > /dev/null 2>&1 && alias awk='command gawk'
command -v gbase64 > /dev/null 2>&1 && alias base64='command gbase64'
command -v gbasename > /dev/null 2>&1 && alias basename='command gbasename'
command -v gcat > /dev/null 2>&1 && alias cat='command gcat'
command -v gchmod > /dev/null 2>&1 && alias chmod='command gchmod'
command -v gchown > /dev/null 2>&1 && alias chown='command gchown'
command -v gcp > /dev/null 2>&1 && alias cp='command gcp -iv'
command -v gcut > /dev/null 2>&1 && alias cut='command gcut'
command -v gdate > /dev/null 2>&1 && alias date='command gdate'
command -v gdd > /dev/null 2>&1 && alias dd='command gdd'
command -v gdf > /dev/null 2>&1 && alias df='command gdf'
command -v gdirname > /dev/null 2>&1 && alias dirname='command gdirname'
command -v gdu > /dev/null 2>&1 && alias du='command gdu'
command -v gecho > /dev/null 2>&1 && alias echo='command gecho'
command -v genv > /dev/null 2>&1 && alias env='command genv'
command -v gfind > /dev/null 2>&1 && alias find='command gfind'
command -v ggrep > /dev/null 2>&1 && alias grep='command ggrep --color=auto -i'
command -v ghead > /dev/null 2>&1 && alias head='command ghead'
command -v gln > /dev/null 2>&1 && alias ln='command gln'
command -v gls > /dev/null 2>&1 && alias gls='command gls --color=auto' ls='command gls --color=auto -a' l='command gls --color=auto -l' ll='command gls --color=auto -la' lll='command gls --color=auto -laFh'
command -v gmkdir > /dev/null 2>&1 && alias mkdir='command gmkdir -pv'
command -v gmv > /dev/null 2>&1 && alias mv='command gmv -iv'
command -v grm > /dev/null 2>&1 && alias rm='command grm -i'
command -v gsed > /dev/null 2>&1 && alias sed='command gsed'
command -v gsort > /dev/null 2>&1 && alias sort='command gsort'
command -v gtail > /dev/null 2>&1 && alias tail='command gtail'
command -v gtar > /dev/null 2>&1 && alias tar='command gtar'
command -v gtouch > /dev/null 2>&1 && alias touch='command gtouch'
command -v gtr > /dev/null 2>&1 && alias tr='command gtr'
command -v guniq > /dev/null 2>&1 && alias uniq='command guniq'
command -v gwc > /dev/null 2>&1 && alias wc='command gwc'
command -v gwhich > /dev/null 2>&1 && alias which='command gwhich'
command -v gxargs > /dev/null 2>&1 && alias xargs='command gxargs'

# ---- Tool Replacements ----
command -v eza > /dev/null 2>&1 && alias l='eza -a -l --git --icons --color=always' ll='eza --git --icons --level=2 --long --tree --long --color=always' lll='eza --git --icons --long --tree --color=always'
command -v hx > /dev/null 2>&1 && alias vim='hx'
command -v nvim > /dev/null 2>&1 && alias vim='nvim'
command -v vim > /dev/null 2>&1 && alias vi='vim'

# ============================================================================
# 4. SHELL FUNCTIONS
# ============================================================================

caffeinate_cmd() { gnome-session-inhibit --inhibit idle:sleep sleep infinity; }
ffpid() { lsof -t -c "$@"; }
quiet() {
  if [[ $# -eq 0 ]]; then
    return
  else
    "$@" > /dev/null 2>&1
  fi
}

duh() {
  if [[ $(uname) == "Darwin" ]]; then
    du -hd 1 "${1:-.}" | sort -h
  else
    du -h --max-depth=1 "${1:-.}" | sort -h
  fi
}

extract() {
  if [[ ! -f "$1" ]]; then
    error "'$1' is not a valid file"
    return 1
  fi
  case "$1" in
    *.tar.bz2) tar xjf "$1" ;;
    *.tar.gz) tar xzf "$1" ;;
    *.bz2) bunzip2 "$1" ;;
    *.rar) unrar e "$1" ;;
    *.gz) gunzip "$1" ;;
    *.tar) tar xf "$1" ;;
    *.tbz2) tar xjf "$1" ;;
    *.tgz) tar xzf "$1" ;;
    *.zip) unzip "$1" ;;
    *.Z) uncompress "$1" ;;
    *.7z) 7z x "$1" ;;
    *)
      error "'$1' cannot be extracted"
      return 1
      ;;
  esac
}

ff() { /usr/bin/find . -name "$@"; }
ffs() { /usr/bin/find . -name "$*"'*'; }
ffe() { /usr/bin/find . -name '*'"$*"; }

http2ssh() {
  REPO_URL=$(git remote -v | grep -m1 '^origin' | sed -Ene's#.*(https://[^[:space:]]*).*#\1#p')
  [[ -z "${REPO_URL}" ]] && {
    error "Could not identify repo URL"
    return 1
  }

  USER=$(echo "${REPO_URL}" | sed -Ene's#https://github.com/([^/]*)/(.*)#\1#p')
  [[ -z "${USER}" ]] && {
    error "Could not identify user"
    return 2
  }

  REPO=$(echo "${REPO_URL}" | sed -Ene's#https://github.com/([^/]*)/(.*)#\2#p')
  [[ -z "${REPO}" ]] && {
    error "Could not identify repo"
    return 3
  }

  NEW_URL="git@github.com:${USER}/${REPO}"
  warn "Changing repo URL from: '${REPO_URL}' to: '${NEW_URL}'"

  if git remote set-url origin "${NEW_URL}"; then
    success "New URL set"
  else
    error "Failed to set URL"
    return 4
  fi
}

nukem() {
  [[ -z "$1" ]] && {
    echo "Usage: $0 <namespace>"
    return 1
  }
  warn "Removing finalizers from namespace: $1"
  if kubectl get namespace "$1" -o json | tr -d "\n" |
    sed "s/\"finalizers\": \[[^]]\+\]/\"finalizers\": []/" |
    kubectl replace --raw "/api/v1/namespaces/$1/finalize" -f -; then
    success "Finalizers removed"
  else
    error "Failed"
    return 2
  fi
}

ipmi() {
  [[ -z "${IPMI_HOST}" || -z "${IPMI_USER}" || -z "${IPMI_CRED_FILE}" ]] &&
    {
      error "IPMI env vars not set"
      return 1
    }
  [[ $1 == "fan" ]] || {
    ipmitool -I lanplus -H "${IPMI_HOST}" -U "${IPMI_USER}" -f "${IPMI_CRED_FILE}" "$@"
    return
  }
  ipmitool -I lanplus -H "${IPMI_HOST}" -U "${IPMI_USER}" -f "${IPMI_CRED_FILE}" raw 0x30 0x30 0x01 0x00
  if [[ $# -eq 2 ]]; then
    local hex_speed
    hex_speed=$(printf '%x\n' "$2")
    ipmitool -I lanplus -H "${IPMI_HOST}" -U "${IPMI_USER}" -f "${IPMI_CRED_FILE}" raw 0x30 0x30 0x02 0xff "0x${hex_speed}"
  else
    error "Usage: ipmi fan <speed_0-255>"
    return 1
  fi
}

proxy() {
  local PROXY="${PROXY_ENDPOINT:-go,localhost}"
  env http_proxy="${PROXY}" https_proxy="${PROXY}" HTTP_PROXY="${PROXY}" HTTPS_PROXY="${PROXY}" \
    NO_PROXY="${PROXY}" no_proxy="${PROXY}" "$@"
}

rcode() {
  [[ $# -ne 2 ]] && {
    echo "Usage: rcode <ssh_host> <remote_path>"
    return 1
  }
  code --remote "ssh-remote+${1}" "${2}"
}

# Test minimal zsh prompt (without p10k)
zsh-minimal() {
  env ZSH_MINIMAL=1 zsh
}

# Git User Profile Management
gu() {
  local profile_file="${JSH}/configs/git/profiles.json"

  # Check if we're in a git repository
  if ! git rev-parse --git-dir > /dev/null 2>&1; then
    error "Not in a git repository"
    return 1
  fi

  # Check if jq is installed
  if ! command -v jq > /dev/null 2>&1; then
    error "jq is required but not installed. Install with: brew install jq"
    return 1
  fi

  # Check if config file exists
  if [[ ! -f "${profile_file}" ]]; then
    error "Git profiles config not found: ${profile_file}"
    info "Create it with the following structure:"
    cat << 'EXAMPLE'
{
  "profiles": {
    "personal": {
      "name": "Your Name",
      "email": "personal@example.com",
      "username": "personal-github"
    },
    "work": {
      "name": "Your Work Name",
      "email": "work@company.com",
      "username": "work-github"
    }
  }
}
EXAMPLE
    return 1
  fi

  # If no argument, show current config and available profiles
  if [[ $# -eq 0 ]]; then
    info "Current git configuration:"
    echo "  Name:     $(git config user.name || echo '<not set>')"
    echo "  Email:    $(git config user.email || echo '<not set>')"
    echo "  Username: $(git config github.user || echo '<not set>')"
    echo ""
    info "Available profiles:"
    jq -r '.profiles | keys[]' "${profile_file}" | sed 's/^/  - /'
    echo ""
    info "Usage: gu <profile_name>"
    return 0
  fi

  local profile_name="$1"

  # Extract profile data
  local name email username
  name=$(jq -r ".profiles.\"${profile_name}\".name // empty" "${profile_file}")
  email=$(jq -r ".profiles.\"${profile_name}\".email // empty" "${profile_file}")
  username=$(jq -r ".profiles.\"${profile_name}\".username // empty" "${profile_file}")

  # Check if profile exists
  if [[ -z "${name}" || -z "${email}" ]]; then
    error "Profile '${profile_name}' not found in ${profile_file}"
    info "Available profiles:"
    jq -r '.profiles | keys[]' "${profile_file}" | sed 's/^/  - /'
    return 1
  fi

  # Apply git config locally (repository-level)
  info "Configuring git user profile: ${profile_name}"
  git config user.name "${name}"
  git config user.email "${email}"

  # Set github.user if username is provided (useful for gh CLI and other tools)
  if [[ -n "${username}" ]]; then
    git config github.user "${username}"
  fi

  # Verify configuration
  success "Git profile '${profile_name}' applied successfully!"
  echo "  Name:     ${name}"
  echo "  Email:    ${email}"
  [[ -n "${username}" ]] && echo "  Username: ${username}"

  # Show scope
  info "Configuration is local to this repository: $(git rev-parse --show-toplevel)"
}

# Path deduplication (POSIX compliant using awk)
dedup_path() {
  if [ -n "$PATH" ]; then
    PATH=$(echo -n "$PATH" | awk -v RS=: -v ORS=: '!a[$0]++' | sed 's/:$//')
    export PATH
  fi
}
dedup_path

# Check for outdated Homebrew packages
if command -v brew > /dev/null 2>&1; then
  if command -v jsh > /dev/null 2>&1; then
    jsh brew check --quiet
  fi
fi

# Navigation: Search path for cd
export CDPATH=".:~:~/projects:~/.jsh"

# Safety: Prevent file overwrite on stdout redirection
# History Hygiene: Ignore specific commands
if [[ -n "$BASH_VERSION" ]]; then
  set -o noclobber
  export HISTIGNORE="&:[ ]*:exit:ls:bg:fg:history:clear"
elif [[ -n "$ZSH_VERSION" ]]; then
  setopt NO_CLOBBER
  export HISTORY_IGNORE="(ls|cd|pwd|exit|cd ..)"
fi

# Load local customizations
# shellcheck disable=SC1090
[[ -f "${JSH_CUSTOM}" ]] && source "${JSH_CUSTOM}"
