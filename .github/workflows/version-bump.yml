name: Release

# Runs on push to main (after PR merge).
# CI runs on PRs, so branch protection ensures CI passed before merge.
# This workflow handles builds (if needed) and version bumping/tagging.

on:
  push:
    branches:
      - main

permissions:
  contents: write

jobs:
  # Build fzf binaries when submodule changes
  build-fzf:
    name: Build fzf
    runs-on: ubuntu-latest
    if: "!contains(github.event.head_commit.message, '[skip ci]')"
    outputs:
      should_run: ${{ steps.check.outputs.should_run }}
    steps:
      - uses: actions/checkout@v6
        with:
          submodules: true
          fetch-depth: 2
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Check if fzf changed
        id: check
        run: |
          # Check if lib/fzf or .gitmodules changed in this push
          if git diff --name-only HEAD~1 HEAD | grep -qE '^(lib/fzf|\.gitmodules)'; then
            echo "should_run=true" >> $GITHUB_OUTPUT
            echo "fzf submodule changed, will build"
          else
            echo "should_run=false" >> $GITHUB_OUTPUT
            echo "fzf submodule unchanged, skipping build"
          fi

      - name: Setup Go
        if: steps.check.outputs.should_run == 'true'
        uses: actions/setup-go@v5
        with:
          go-version: 'stable'
          cache-dependency-path: lib/fzf/go.sum

      - name: Get fzf version
        if: steps.check.outputs.should_run == 'true'
        id: version
        run: |
          cd lib/fzf
          VERSION=$(git describe --tags --always)
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Building fzf $VERSION"

      - name: Build binaries
        if: steps.check.outputs.should_run == 'true'
        run: |
          cd lib/fzf

          # Build for all target platforms
          platforms=(
            "darwin/amd64"
            "darwin/arm64"
            "linux/amd64"
            "linux/arm64"
          )

          for platform in "${platforms[@]}"; do
            GOOS="${platform%/*}"
            GOARCH="${platform#*/}"
            output_dir="../../lib/bin/${GOOS}-${GOARCH}"
            output_name="fzf"

            echo "Building for $GOOS/$GOARCH..."
            mkdir -p "$output_dir"

            VERSION="${{ steps.version.outputs.version }}"
            REVISION=$(git rev-parse --short HEAD)
            LDFLAGS="-s -w -X main.version=${VERSION} -X main.revision=${REVISION}"

            CGO_ENABLED=0 GOOS=$GOOS GOARCH=$GOARCH go build \
              -ldflags="${LDFLAGS}" \
              -o "${output_dir}/${output_name}" \
              .

            echo "Built: ${output_dir}/${output_name}"
          done

      - name: Verify binaries
        if: steps.check.outputs.should_run == 'true'
        run: |
          echo "Built binaries:"
          find lib/bin -name "fzf" -exec ls -lh {} \;
          echo ""
          echo "Version check (native binary):"
          lib/bin/linux-amd64/fzf --version

      - name: Configure git
        if: steps.check.outputs.should_run == 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Commit binaries
        if: steps.check.outputs.should_run == 'true'
        run: |
          git add lib/bin/
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "chore: update fzf binaries to ${{ steps.version.outputs.version }} [skip ci]

          Built for: darwin-amd64, darwin-arm64, linux-amd64, linux-arm64"
            git push
          fi

  # Version bump and tag - only runs after builds succeed (or were skipped)
  version-bump:
    name: Version Bump
    runs-on: ubuntu-latest
    needs: [build-fzf]
    # Run if: not skip-ci AND (build-fzf succeeded OR was skipped because paths didn't match)
    if: |
      always() &&
      !contains(github.event.head_commit.message, '[skip ci]') &&
      (needs.build-fzf.result == 'success' || needs.build-fzf.result == 'skipped')

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Pull latest changes
        run: |
          # Pull any changes made by build-fzf job
          git pull --rebase origin main || true

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Get current version
        id: current_version
        run: |
          # Extract version from jsh script (line: VERSION="x.y.z")
          VERSION=$(grep -E '^VERSION="[0-9]+\.[0-9]+\.[0-9]+"' jsh | head -1 | sed 's/VERSION="//;s/"//')
          if [[ -z "$VERSION" ]]; then
            echo "Failed to extract version from jsh"
            exit 1
          fi
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "Current version: ${VERSION}"

      - name: Determine version bump type
        id: bump_type
        run: |
          # Get the last tag
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          echo "Last tag: ${LAST_TAG:-none}"

          # Get all commit messages since last tag (or all if no tags)
          if [[ -n "$LAST_TAG" ]]; then
            COMMITS=$(git log "${LAST_TAG}..HEAD" --pretty=format:"%s" 2>/dev/null || echo "")
          else
            COMMITS=$(git log --pretty=format:"%s" 2>/dev/null || echo "")
          fi

          echo "Analyzing commits since ${LAST_TAG:-beginning}:"
          echo "$COMMITS" | head -20

          # Analyze ALL commits to determine bump type
          BUMP="patch"
          HAS_FEAT=false

          while IFS= read -r msg; do
            [[ -z "$msg" ]] && continue

            # Check for breaking change indicators:
            # 1. type!: prefix (e.g., refactor!:, feat!:)
            # 2. BREAKING CHANGE in body
            if echo "$msg" | grep -qE '^[a-z]+!:' || echo "$msg" | grep -qi "BREAKING CHANGE"; then
              echo "  BREAKING: $msg"
              BUMP="major"
              break  # Major takes precedence, no need to check more
            fi

            # Check for features (only matters if not already major)
            if [[ "$BUMP" != "major" ]]; then
              TYPE=$(echo "$msg" | grep -oE '^[a-z]+' || echo "")
              if [[ "$TYPE" =~ ^(feat|feature|add|enhance|improvement)$ ]]; then
                echo "  FEATURE: $msg"
                HAS_FEAT=true
              fi
            fi
          done <<< "$COMMITS"

          # Set to minor if we found features but no breaking changes
          if [[ "$BUMP" != "major" && "$HAS_FEAT" == "true" ]]; then
            BUMP="minor"
          fi

          echo "bump=${BUMP}" >> $GITHUB_OUTPUT
          echo "Version bump type: ${BUMP}"

      - name: Calculate new version
        id: new_version
        run: |
          CURRENT="${{ steps.current_version.outputs.version }}"
          BUMP="${{ steps.bump_type.outputs.bump }}"

          # Split version into components
          IFS='.' read -r MAJOR MINOR PATCH <<< "${CURRENT}"

          # Bump the appropriate component
          case "${BUMP}" in
            major)
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            minor)
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            patch)
              PATCH=$((PATCH + 1))
              ;;
          esac

          NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"
          echo "version=${NEW_VERSION}" >> $GITHUB_OUTPUT
          echo "New version: ${NEW_VERSION}"

      - name: Update version in jsh
        run: |
          NEW_VERSION="${{ steps.new_version.outputs.version }}"

          # Update VERSION line in jsh script
          sed -i "s/^VERSION=\"[0-9]*\.[0-9]*\.[0-9]*\"/VERSION=\"${NEW_VERSION}\"/" jsh

          # Verify the update
          grep -E '^VERSION="' jsh
          echo "Updated jsh to version ${NEW_VERSION}"

      - name: Commit version bump
        run: |
          NEW_VERSION="${{ steps.new_version.outputs.version }}"
          BUMP_TYPE="${{ steps.bump_type.outputs.bump }}"

          git add jsh

          # Only commit if there are changes
          if git diff --staged --quiet; then
            echo "No version changes to commit"
          else
            git commit -m "chore: bump version to ${NEW_VERSION} (${BUMP_TYPE}) [skip ci]"
            git push
            echo "Version bumped to ${NEW_VERSION}"
          fi

      - name: Create Git tag
        run: |
          NEW_VERSION="${{ steps.new_version.outputs.version }}"

          # Check if tag already exists
          if git rev-parse "v${NEW_VERSION}" >/dev/null 2>&1; then
            echo "Tag v${NEW_VERSION} already exists, skipping"
          else
            git tag -a "v${NEW_VERSION}" -m "Release v${NEW_VERSION}"
            git push origin "v${NEW_VERSION}"
            echo "Created and pushed tag v${NEW_VERSION}"
          fi
