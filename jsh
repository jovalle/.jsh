#!/usr/bin/env bash
# This script was generated by bashly 0.8.4 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n"
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
jsh_usage() {
  if [[ -n $long_usage ]]; then
    printf "jsh - Dotfiles and environment management utility\n"
    echo

  else
    printf "jsh - Dotfiles and environment management utility\n"
    echo

  fi

  printf "Usage:\n"
  printf "  jsh [command]\n"
  printf "  jsh [command] --help | -h\n"
  printf "  jsh --version | -v\n"
  echo
  # :command.usage_commands
  printf "Commands:\n"
  echo "  init          Set up shell environment"
  echo "  install       Install packages"
  echo "  uninstall     Uninstall a package and remove from config"
  echo "  upgrade       Upgrade all packages (brew, zinit, system)"
  echo "  configure     Apply dotfiles, OS settings, and app configs"
  echo "  dotfiles      Manage dotfile symlinks"
  echo "  clean         Remove caches, temp files, old Homebrew versions"
  echo "  status        Show brew packages, services, symlinks, git status"
  echo "  doctor        Check for missing tools, broken symlinks, repo issues"
  echo "  deinit        Remove jsh symlinks and restore backups"
  echo "  brew          Homebrew wrapper (handles root delegation)"
  echo "  completions   Generate shell completion script"
  echo "  tools         Discover and manage optional development tools"
  echo "  sync          Sync jsh changes with remote repository"
  echo "  profile       Show current environment profile and configuration"
  echo "  plugins       Manage shell, vim, and tmux plugins"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    echo "  --version, -v"
    printf "    Show version number\n"
    echo

    # :command.usage_environment_variables
    printf "Environment Variables:\n"

    # :environment_variable.usage
    echo "  JSH_ROOT"
    printf "    Path to jsh repository root\n"
    echo

    # :environment_variable.usage
    echo "  BREW_USER"
    printf "    User to run Homebrew commands as (when running as root)\n"
    echo

  fi
}

# :command.usage
jsh_init_usage() {
  if [[ -n $long_usage ]]; then
    printf "jsh init - Set up shell environment\n"
    echo

  else
    printf "jsh init - Set up shell environment\n"
    echo

  fi

  printf "Usage:\n"
  printf "  jsh init [options]\n"
  printf "  jsh init --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_flags
    # :flag.usage
    echo "  --non-interactive, -y"
    printf "    Use defaults (zsh + full)\n"
    echo

    # :flag.usage
    echo "  --shell SHELL"
    printf "    Pre-select shell: zsh, bash, or skip\n"
    echo

    # :flag.usage
    echo "  --minimal"
    printf "    Lightweight setup, no plugins\n"
    echo

    # :flag.usage
    echo "  --full"
    printf "    Full setup with themes, plugins, completions\n"
    echo

    # :flag.usage
    echo "  --setup"
    printf "    Also run install + configure after init\n"
    echo

    # :flag.usage
    echo "  --no-install"
    printf "    Skip package installation\n"
    echo

    # :flag.usage
    echo "  --skip-brew"
    printf "    Skip Homebrew installation\n"
    echo

    # :flag.usage
    echo "  --dry-run"
    printf "    Preview changes without applying\n"
    echo

  fi
}

# :command.usage
jsh_install_usage() {
  if [[ -n $long_usage ]]; then
    printf "jsh install - Install packages\n"
    echo

  else
    printf "jsh install - Install packages\n"
    echo

  fi

  printf "Usage:\n"
  printf "  jsh install [PACKAGE] [options]\n"
  printf "  jsh install --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_flags
    # :flag.usage
    echo "  --brew"
    printf "    Install via Homebrew/Linuxbrew\n"
    echo

    # :flag.usage
    echo "  --gem"
    printf "    Install via Ruby gem\n"
    echo

    # :flag.usage
    echo "  --bun"
    printf "    Install via bun (JavaScript runtime)\n"
    echo

    # :flag.usage
    echo "  --npm"
    printf "    Install via npm (Node.js)\n"
    echo

    # :flag.usage
    echo "  --pip"
    printf "    Install via pip (Python)\n"
    echo

    # :flag.usage
    echo "  --cargo"
    printf "    Install via cargo (Rust)\n"
    echo

    # :flag.usage
    echo "  --apt"
    printf "    Install via apt (Debian/Ubuntu)\n"
    echo

    # :flag.usage
    echo "  --dnf"
    printf "    Install via dnf (Fedora/RHEL)\n"
    echo

    # :flag.usage
    echo "  --pacman"
    printf "    Install via pacman (Arch Linux)\n"
    echo

    # :flag.usage
    echo "  --yum"
    printf "    Install via yum (CentOS/RHEL)\n"
    echo

    # :flag.usage
    echo "  --zypper"
    printf "    Install via zypper (openSUSE)\n"
    echo

    # :flag.usage
    echo "  --no-progress"
    printf "    Disable TUI progress display\n"
    echo

    # :flag.usage
    echo "  --quiet, -q"
    printf "    Minimal output\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  PACKAGE"
    printf "    Package to install (omit to install all from config)\n"
    echo

  fi
}

# :command.usage
jsh_uninstall_usage() {
  if [[ -n $long_usage ]]; then
    printf "jsh uninstall - Uninstall a package and remove from config\n"
    echo

  else
    printf "jsh uninstall - Uninstall a package and remove from config\n"
    echo

  fi

  printf "Usage:\n"
  printf "  jsh uninstall PACKAGE\n"
  printf "  jsh uninstall --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  PACKAGE"
    printf "    Package to uninstall\n"
    echo

  fi
}

# :command.usage
jsh_upgrade_usage() {
  if [[ -n $long_usage ]]; then
    printf "jsh upgrade - Upgrade all packages (brew, zinit, system)\n"
    echo

  else
    printf "jsh upgrade - Upgrade all packages (brew, zinit, system)\n"
    echo

  fi

  printf "Alias: update\n"
  echo

  printf "Usage:\n"
  printf "  jsh upgrade [options]\n"
  printf "  jsh upgrade --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_flags
    # :flag.usage
    echo "  --no-progress"
    printf "    Disable TUI progress display\n"
    echo

    # :flag.usage
    echo "  --quiet, -q"
    printf "    Minimal output\n"
    echo

  fi
}

# :command.usage
jsh_configure_usage() {
  if [[ -n $long_usage ]]; then
    printf "jsh configure - Apply dotfiles, OS settings, and app configs\n"
    echo

  else
    printf "jsh configure - Apply dotfiles, OS settings, and app configs\n"
    echo

  fi

  printf "Usage:\n"
  printf "  jsh configure\n"
  printf "  jsh configure --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
jsh_dotfiles_usage() {
  if [[ -n $long_usage ]]; then
    printf "jsh dotfiles - Manage dotfile symlinks\n"
    echo

  else
    printf "jsh dotfiles - Manage dotfile symlinks\n"
    echo

  fi

  printf "Usage:\n"
  printf "  jsh dotfiles [options]\n"
  printf "  jsh dotfiles --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_flags
    # :flag.usage
    echo "  --status, -s"
    printf "    Show current symlink status\n"
    echo

    # :flag.usage
    echo "  --remove, -d"
    printf "    Remove dotfile symlinks\n"
    echo

    # :flag.usage
    echo "  --non-interactive, -y"
    printf "    Use defaults (auto-backup conflicts)\n"
    echo

  fi
}

# :command.usage
jsh_clean_usage() {
  if [[ -n $long_usage ]]; then
    printf "jsh clean - Remove caches, temp files, old Homebrew versions\n"
    echo

  else
    printf "jsh clean - Remove caches, temp files, old Homebrew versions\n"
    echo

  fi

  printf "Alias: cleanup\n"
  echo

  printf "Usage:\n"
  printf "  jsh clean\n"
  printf "  jsh clean --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
jsh_status_usage() {
  if [[ -n $long_usage ]]; then
    printf "jsh status - Show brew packages, services, symlinks, git status\n"
    echo

  else
    printf "jsh status - Show brew packages, services, symlinks, git status\n"
    echo

  fi

  printf "Usage:\n"
  printf "  jsh status\n"
  printf "  jsh status --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
jsh_doctor_usage() {
  if [[ -n $long_usage ]]; then
    printf "jsh doctor - Check for missing tools, broken symlinks, repo issues\n"
    echo

  else
    printf "jsh doctor - Check for missing tools, broken symlinks, repo issues\n"
    echo

  fi

  printf "Alias: check\n"
  echo

  printf "Usage:\n"
  printf "  jsh doctor\n"
  printf "  jsh doctor --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
jsh_deinit_usage() {
  if [[ -n $long_usage ]]; then
    printf "jsh deinit - Remove jsh symlinks and restore backups\n"
    echo

  else
    printf "jsh deinit - Remove jsh symlinks and restore backups\n"
    echo

  fi

  printf "Usage:\n"
  printf "  jsh deinit\n"
  printf "  jsh deinit --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
jsh_brew_usage() {
  if [[ -n $long_usage ]]; then
    printf "jsh brew - Homebrew wrapper (handles root delegation)\n"
    echo

  else
    printf "jsh brew - Homebrew wrapper (handles root delegation)\n"
    echo

  fi

  printf "Usage:\n"
  printf "  jsh brew [SUBCOMMAND] [options] [BREW_ARGS...]\n"
  printf "  jsh brew --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_flags
    # :flag.usage
    echo "  --quiet, -q"
    printf "    Silent mode (for check command)\n"
    echo

    # :flag.usage
    echo "  --force, -f"
    printf "    Force check even if run recently\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  SUBCOMMAND"
    printf "    Brew subcommand: setup, check, or any brew command\n"
    echo

    echo "  BREW_ARGS..."
    printf "    All arguments to pass through to brew\n"
    echo

  fi
}

# :command.usage
jsh_completions_usage() {
  if [[ -n $long_usage ]]; then
    printf "jsh completions - Generate shell completion script\n"
    echo

  else
    printf "jsh completions - Generate shell completion script\n"
    echo

  fi

  printf "Usage:\n"
  printf "  jsh completions [options]\n"
  printf "  jsh completions --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_flags
    # :flag.usage
    echo "  --install, -i"
    printf "    Install completions to shell config\n"
    echo

  fi
}

# :command.usage
jsh_tools_usage() {
  if [[ -n $long_usage ]]; then
    printf "jsh tools - Discover and manage optional development tools\n"
    echo

  else
    printf "jsh tools - Discover and manage optional development tools\n"
    echo

  fi

  printf "Usage:\n"
  printf "  jsh tools [ACTION] [options]\n"
  printf "  jsh tools --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_flags
    # :flag.usage
    echo "  --missing, -m"
    printf "    Show only missing tools\n"
    echo

    # :flag.usage
    echo "  --category, -c CATEGORY"
    printf "    Filter by category (shell, editor, dev, k8s, git)\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  ACTION"
    printf "    Action: list (default), check, install, recommend\n"
    printf "    Default: list\n"
    echo

  fi
}

# :command.usage
jsh_sync_usage() {
  if [[ -n $long_usage ]]; then
    printf "jsh sync - Sync jsh changes with remote repository\n"
    echo

  else
    printf "jsh sync - Sync jsh changes with remote repository\n"
    echo

  fi

  printf "Usage:\n"
  printf "  jsh sync [options]\n"
  printf "  jsh sync --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_flags
    # :flag.usage
    echo "  --pull, -p"
    printf "    Pull changes only (don't push)\n"
    echo

    # :flag.usage
    echo "  --push, -P"
    printf "    Push changes only (don't pull)\n"
    echo

    # :flag.usage
    echo "  --stash, -s"
    printf "    Stash local changes before syncing\n"
    echo

    # :flag.usage
    echo "  --force, -f"
    printf "    Force sync (may overwrite changes)\n"
    echo

  fi
}

# :command.usage
jsh_profile_usage() {
  if [[ -n $long_usage ]]; then
    printf "jsh profile - Show current environment profile and configuration\n"
    echo

  else
    printf "jsh profile - Show current environment profile and configuration\n"
    echo

  fi

  printf "Alias: env\n"
  echo

  printf "Usage:\n"
  printf "  jsh profile [options]\n"
  printf "  jsh profile --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_flags
    # :flag.usage
    echo "  --verbose, -v"
    printf "    Show detailed configuration\n"
    echo

    # :flag.usage
    echo "  --json"
    printf "    Output as JSON\n"
    echo

  fi
}

# :command.usage
jsh_plugins_usage() {
  if [[ -n $long_usage ]]; then
    printf "jsh plugins - Manage shell, vim, and tmux plugins\n"
    echo

  else
    printf "jsh plugins - Manage shell, vim, and tmux plugins\n"
    echo

  fi

  printf "Usage:\n"
  printf "  jsh plugins [ACTION] [options]\n"
  printf "  jsh plugins --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_flags
    # :flag.usage
    echo "  --vim"
    printf "    Manage vim plugins only\n"
    echo

    # :flag.usage
    echo "  --tmux"
    printf "    Manage tmux plugins only\n"
    echo

    # :flag.usage
    echo "  --shell"
    printf "    Manage shell plugins only (zinit)\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  ACTION"
    printf "    Action: list (default), install, update, check\n"
    printf "    Default: list\n"
    echo

  fi
}

# :command.normalize_input
normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for (( i=0 ; i < ${#flags} ; i++ )); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}
# :command.inspect_args
inspect_args() {
  readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
  if (( ${#args[@]} )); then
    echo args:
    for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
  else
    echo args: none
  fi

  if (( ${#other_args[@]} )); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi
}

# :command.user_lib
# src/lib/brew.sh
# Homebrew management functions for jsh

# ============================================================================
# Core Helper Functions
# ============================================================================

is_root() { [[ "${EUID:-$(id -u)}" -eq 0 ]]; }

check_brew() {
  if ! command -v brew &> /dev/null; then
    warn "Homebrew not found. Skipping brew-related tasks."
    return 1
  fi
  return 0
}

apply_brew_shellenv() {
  local brew_bin="$1"
  [[ -n "${brew_bin}" && -x "${brew_bin}" ]] || return 1

  local brew_env
  if brew_env="$("${brew_bin}" shellenv)"; then
    eval "${brew_env}"
    return 0
  fi
  return 1
}

# Check if a user exists on the system
user_exists() {
  local username="$1"
  if is_macos; then
    dscl . -read "/Users/${username}" &> /dev/null
  else
    id "${username}" &> /dev/null
  fi
}

# Load BREW_USER from .env if available
load_brew_user() {
  local root_dir
  root_dir="$(get_root_dir)"
  local env_file="${root_dir}/.env"
  if [[ -f "${env_file}" ]]; then
    # Source the env file to get BREW_USER
    # shellcheck source=/dev/null
    source "${env_file}"
  fi
  export BREW_USER="${BREW_USER:-}"
}

# Check if user is in admin/sudo group (idempotent check)
user_in_admin_group() {
  local username="$1"
  if is_macos; then
    dseditgroup -o checkmember -m "${username}" admin &> /dev/null
  else
    if getent group sudo &> /dev/null; then
      id -nG "${username}" 2> /dev/null | grep -qw sudo
    elif getent group wheel &> /dev/null; then
      id -nG "${username}" 2> /dev/null | grep -qw wheel
    else
      return 1
    fi
  fi
}

# Detect OS and set Homebrew path
detect_brew_path() {
  if is_macos; then
    # macOS - check both Apple Silicon and Intel paths
    if [[ -d "/opt/homebrew" ]]; then
      echo "/opt/homebrew"
    elif [[ -d "/usr/local/Homebrew" ]]; then
      echo "/usr/local"
    else
      echo ""
    fi
  elif is_linux || grep -qi microsoft /proc/version 2> /dev/null; then
    # Linux or WSL
    if [[ -d "/home/linuxbrew/.linuxbrew" ]]; then
      echo "/home/linuxbrew/.linuxbrew"
    else
      echo ""
    fi
  else
    echo ""
  fi
}

# Run a command as the brew user (for root delegation)
run_as_brew_user() {
  local brew_user="${BREW_USER:-}"

  if [[ -z "${brew_user}" ]]; then
    error "BREW_USER is not configured. Run 'jsh init' to set up brew delegation."
  fi

  if ! user_exists "${brew_user}"; then
    error "Brew user '${brew_user}' does not exist."
  fi

  local brew_user_home
  brew_user_home=$(eval echo "~${brew_user}")

  # Detect brew path and set up environment
  local brew_prefix
  brew_prefix=$(detect_brew_path)

  if [[ -n "${brew_prefix}" ]]; then
    # Run with brew environment properly configured
    sudo -u "${brew_user}" bash -c "cd '${brew_user_home}' && eval \"\$(${brew_prefix}/bin/brew shellenv)\" && \"\$@\"" -- "$@"
  else
    # Fallback to basic execution
    sudo -u "${brew_user}" bash -c "cd '${brew_user_home}' && \"\$@\"" -- "$@"
  fi
}

# Prompt for and create a standard user for brew delegation
# Args: default_user, non_interactive (true/false)
# Note: This function outputs the username to stdout for capture.
#       All info/status messages go to stderr to avoid corrupting the output.
create_brew_user() {
  local default_user="${1:-jay}"
  local non_interactive="${2:-false}"
  local username

  # In non-interactive mode, use default user directly
  if [[ "${non_interactive}" == "true" ]]; then
    username="${default_user}"
    info "Non-interactive mode: using user '${username}' for brew operations." >&2
  else
    echo "" >&2
    warn "Homebrew cannot be run as root." >&2
    info "A standard (non-root) user is required to install and manage Homebrew." >&2
    echo "" >&2

    # Prompt for username
    read -r -p "Enter username for brew operations [${default_user}]: " username
    username="${username:-${default_user}}"
  fi

  # Validate username
  if [[ ! "${username}" =~ ^[a-z_][a-z0-9_-]*$ ]]; then
    error "Invalid username. Use lowercase letters, numbers, underscores, and hyphens."
    return 1
  fi

  # Check if user already exists (idempotent)
  if user_exists "${username}"; then
    info "User '${username}' already exists." >&2

    # Ensure user is in admin/sudo group (idempotent)
    if ! user_in_admin_group "${username}"; then
      info "Adding '${username}' to admin/sudo group..." >&2
      if is_macos; then
        sudo dseditgroup -o edit -a "${username}" -t user admin 2> /dev/null || true
      else
        if getent group sudo &> /dev/null; then
          sudo usermod -aG sudo "${username}" 2> /dev/null || true
        elif getent group wheel &> /dev/null; then
          sudo usermod -aG wheel "${username}" 2> /dev/null || true
        fi
      fi
    fi

    if [[ "${non_interactive}" == "true" ]]; then
      echo "${username}"
      return 0
    fi

    if confirm "Use '${username}' for brew operations?"; then
      echo "${username}"
      return 0
    else
      return 1
    fi
  fi

  # Create the user
  info "Creating user '${username}'..." >&2

  if is_macos; then
    # macOS user creation
    local max_id
    max_id=$(dscl . -list /Users UniqueID | awk '{print $2}' | sort -n | tail -1)
    local new_id=$((max_id + 1))

    sudo dscl . -create "/Users/${username}"
    sudo dscl . -create "/Users/${username}" UserShell /bin/zsh
    sudo dscl . -create "/Users/${username}" RealName "${username}"
    sudo dscl . -create "/Users/${username}" UniqueID "${new_id}"
    sudo dscl . -create "/Users/${username}" PrimaryGroupID 20
    sudo dscl . -create "/Users/${username}" NFSHomeDirectory "/Users/${username}"

    sudo mkdir -p "/Users/${username}"
    sudo chown "${username}:staff" "/Users/${username}"

    # Set password (skip in non-interactive mode)
    if [[ "${non_interactive}" != "true" ]]; then
      info "Setting password for ${username}..." >&2
      sudo dscl . -passwd "/Users/${username}"
    else
      info "Skipping password setup in non-interactive mode." >&2
      info "Set password later with: sudo dscl . -passwd /Users/${username}" >&2
    fi

    # Add to admin group (idempotent)
    sudo dseditgroup -o edit -a "${username}" -t user admin 2> /dev/null || true
  else
    # Linux user creation
    if command -v useradd &> /dev/null; then
      sudo useradd -m -s /bin/bash "${username}"
    elif command -v adduser &> /dev/null; then
      sudo adduser --disabled-password --gecos "" "${username}"
    else
      error "No supported user creation tool found (useradd or adduser)"
      return 1
    fi

    # Set password (skip in non-interactive mode)
    if [[ "${non_interactive}" != "true" ]]; then
      info "Setting password for ${username}..." >&2
      sudo passwd "${username}"
    else
      info "Skipping password setup in non-interactive mode." >&2
      info "Set password later with: sudo passwd ${username}" >&2
    fi

    # Add to sudo/wheel group (idempotent)
    if getent group sudo &> /dev/null; then
      sudo usermod -aG sudo "${username}" 2> /dev/null || true
    elif getent group wheel &> /dev/null; then
      sudo usermod -aG wheel "${username}" 2> /dev/null || true
    fi
  fi

  if user_exists "${username}"; then
    success "User '${username}' created successfully." >&2
    echo "${username}"
    return 0
  else
    error "Failed to create user '${username}'"
    return 1
  fi
}

# Configure brew user delegation and save to .env
configure_brew_delegation() {
  local brew_user="$1"
  local root_dir
  root_dir="$(get_root_dir)"
  local env_file="${root_dir}/.env"

  if [[ -z "${brew_user}" ]]; then
    error "No brew user specified for delegation"
    return 1
  fi

  if [[ -f "${env_file}" ]]; then
    if grep -q "^BREW_USER=" "${env_file}"; then
      if is_macos; then
        sed -i '' "s/^BREW_USER=.*/BREW_USER=${brew_user}/" "${env_file}"
      else
        sed -i "s/^BREW_USER=.*/BREW_USER=${brew_user}/" "${env_file}"
      fi
    else
      echo "BREW_USER=${brew_user}" >> "${env_file}"
    fi
  else
    echo "BREW_USER=${brew_user}" > "${env_file}"
  fi

  export BREW_USER="${brew_user}"
  success "Brew delegation configured for user: ${brew_user}"
}

confirm() {
  local prompt="$1"
  local response
  read -r -n 1 -p "${prompt} (y/N): " response
  echo # Add newline after single character input
  case "${response}" in
    y | Y)
      return 0
      ;;
    *)
      return 1
      ;;
  esac
}

# Fix hostname resolution for sudo if needed
fix_hostname_resolution() {
  if is_linux; then
    local hostname
    hostname=$(cat /etc/hostname 2> /dev/null || hostname)

    if [[ -n "${hostname}" ]] && ! grep -q "127.0.0.1.*${hostname}" /etc/hosts 2> /dev/null; then
      info "Fixing hostname resolution in /etc/hosts..."
      # Add hostname to the first 127.0.0.1 line if not already present
      if grep -q "^127.0.0.1" /etc/hosts; then
        sudo sed -i "0,/^127.0.0.1/{s/127.0.0.1\s/127.0.0.1       ${hostname} /}" /etc/hosts
      else
        echo "127.0.0.1       ${hostname}" | sudo tee -a /etc/hosts > /dev/null
      fi
      success "Hostname '${hostname}' added to /etc/hosts"
    fi
  fi
}

# ============================================================================
# Setup Command
# ============================================================================

brew_setup() {
  # Fix hostname resolution to prevent sudo warnings
  fix_hostname_resolution

  # Load any existing BREW_USER configuration
  load_brew_user

  # Handle root user - need to delegate to a standard user
  if is_root; then
    warn "Running as root. Homebrew must be installed as a non-root user."
    echo ""

    # Check if BREW_USER is already configured and user exists
    if [[ -n "${BREW_USER:-}" ]] && user_exists "${BREW_USER}"; then
      info "Using configured brew user: ${BREW_USER}"
      # Ensure user is in admin group (idempotent)
      if ! user_in_admin_group "${BREW_USER}"; then
        info "Ensuring '${BREW_USER}' has admin/sudo access..."
        if is_macos; then
          sudo dseditgroup -o edit -a "${BREW_USER}" -t user admin 2> /dev/null || true
        else
          if getent group sudo &> /dev/null; then
            sudo usermod -aG sudo "${BREW_USER}" 2> /dev/null || true
          elif getent group wheel &> /dev/null; then
            sudo usermod -aG wheel "${BREW_USER}" 2> /dev/null || true
          fi
        fi
      fi
    elif [[ -n "${BREW_USER:-}" ]]; then
      # BREW_USER is set but user doesn't exist - create it (non-interactive)
      info "BREW_USER='${BREW_USER}' is configured but user does not exist."
      local brew_user
      brew_user=$(create_brew_user "${BREW_USER}" "true")
      if [[ -z "${brew_user}" ]]; then
        error "Failed to create configured brew user."
        return 1
      fi
      configure_brew_delegation "${brew_user}"
    else
      # Need to set up brew user delegation interactively
      if ! confirm "Would you like to configure a user for brew operations?"; then
        warn "Skipping brew setup. Homebrew requires a non-root user."
        return 1
      fi

      local brew_user
      brew_user=$(create_brew_user "jay" "false")

      if [[ -z "${brew_user}" ]]; then
        error "Brew user setup cancelled."
        return 1
      fi

      configure_brew_delegation "${brew_user}"
    fi

    # Check if brew is already installed
    local BREW_PREFIX
    BREW_PREFIX=$(detect_brew_path)

    if [[ -n "${BREW_PREFIX}" ]]; then
      success "Homebrew is already installed at: ${BREW_PREFIX}"
      info "Brew commands will be delegated to user: ${BREW_USER}"
      return 0
    fi

    # Install Homebrew as the brew user
    info "Installing Homebrew as user: ${BREW_USER}"
    echo ""

    # Prepare the linuxbrew directory with proper ownership
    if is_linux || grep -qi microsoft /proc/version 2> /dev/null; then
      if [[ ! -d "/home/linuxbrew" ]]; then
        info "Creating /home/linuxbrew directory..."
        mkdir -p /home/linuxbrew/.linuxbrew
        chown -R "${BREW_USER}:${BREW_USER}" /home/linuxbrew
      elif [[ ! -w "/home/linuxbrew/.linuxbrew" ]] || [[ "$(stat -c '%U' /home/linuxbrew 2> /dev/null)" != "${BREW_USER}" ]]; then
        info "Fixing ownership of /home/linuxbrew..."
        chown -R "${BREW_USER}:${BREW_USER}" /home/linuxbrew
      fi
    fi

    local install_script
    install_script="$(mktemp)"
    chmod 644 "${install_script}"

    if curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh -o "${install_script}"; then
      if sudo -u "${BREW_USER}" NONINTERACTIVE=1 /bin/bash "${install_script}"; then
        rm -f "${install_script}"
        success "Homebrew installed successfully for user: ${BREW_USER}"
        info ""
        info "To use brew commands as root, use: jsh brew <command>"
        info "The BREW_USER setting is saved in $(get_root_dir)/.env"
        return 0
      else
        rm -f "${install_script}"
        error "Failed to install Homebrew as user: ${BREW_USER}"
        return 1
      fi
    else
      error "Failed to download Homebrew install script."
      return 1
    fi
  fi

  # Non-root path - original behavior
  local BREW_PREFIX
  BREW_PREFIX=$(detect_brew_path)

  if [[ -n "${BREW_PREFIX}" ]]; then
    success "Homebrew is already installed at: ${BREW_PREFIX}"
    info "Configuring environment..."

    if apply_brew_shellenv "${BREW_PREFIX}/bin/brew"; then
      success "Homebrew environment configured"
      return 0
    else
      warn "Failed to configure Homebrew environment"
      return 1
    fi
  fi

  # Check for sudo access before attempting installation
  if ! sudo -n true 2> /dev/null; then
    error "Homebrew installation requires sudo access"
    info "Please ensure you have sudo permissions, or use an alternative installation method:"
    info "https://docs.brew.sh/Installation#alternative-installs"
    return 1
  fi

  info "Installing Homebrew/Linuxbrew..."
  echo ""

  # Run official install script
  /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"

  # Try to apply environment after installation
  BREW_PREFIX=$(detect_brew_path)
  if [[ -n "${BREW_PREFIX}" ]]; then
    if apply_brew_shellenv "${BREW_PREFIX}/bin/brew"; then
      success "Homebrew installation and configuration complete!"
      return 0
    fi
  fi

  warn "Homebrew installation complete, but environment could not be configured automatically"
  info "Please follow the instructions above to add Homebrew to your PATH"
  return 1
}

# ============================================================================
# Check Command - Helper Functions
# ============================================================================

# Extract package names from JSON config files
extract_packages_from_json() {
  local file="$1"
  if [[ ! -f "${file}" ]]; then
    echo ""
    return
  fi
  jq -r '.packages[]? // empty' "${file}" 2> /dev/null | sort -u
}

# Check if a package is available in Homebrew API
check_package_in_api() {
  local pkg="$1"
  local pkg_type="$2" # "formula" or "cask"

  local api_url=""
  if [[ "${pkg_type}" == "cask" ]]; then
    api_url="https://formulae.brew.sh/api/cask/${pkg}.json"
  else
    api_url="https://formulae.brew.sh/api/formula/${pkg}.json"
  fi

  # Use curl to check if the package exists in the API
  if curl -sf "${api_url}" &> /dev/null; then
    return 0
  else
    return 1
  fi
}

# Check if a package exists locally
check_package_locally() {
  local pkg="$1"
  local pkg_type="$2" # "formula" or "cask"

  if [[ "${pkg_type}" == "cask" ]]; then
    brew info --cask "${pkg}" &> /dev/null
    return $?
  else
    brew info --formula "${pkg}" &> /dev/null
    return $?
  fi
}

# Validate a specific package exists
validate_package() {
  local pkg="$1"
  local forced_platform="${2:-}" # Optional forced platform: 'linux' or 'darwin'

  info "Checking package: ${pkg}"

  # Determine which platform to check against
  local check_platform="${forced_platform}"
  if [[ -z "${check_platform}" ]]; then
    if is_macos; then
      check_platform="darwin"
    else
      check_platform="linux"
    fi
  fi

  # Try as formula first
  if check_package_locally "${pkg}" "formula"; then
    # On Linux, check if the formula has macOS-only requirements
    if [[ "${check_platform}" == "linux" ]]; then
      # Get the formula info and check for platform requirements
      local brew_info
      brew_info=$(brew info --formula "${pkg}" 2>&1 || echo "")

      if echo "${brew_info}" | grep -q "Required: macOS"; then
        error "Package '${pkg}' is not supported on Linux (macOS-only package)"
        return 1
      fi
    fi

    success "Package '${pkg}' is available as a formula"
    return 0
  fi

  # Try as cask on macOS
  if [[ "${check_platform}" == "darwin" ]]; then
    if check_package_locally "${pkg}" "cask"; then
      success "Package '${pkg}' is available as a cask"
      return 0
    fi
  fi

  # Check API with platform validation
  if check_package_in_api "${pkg}" "formula"; then
    # For Linux, double-check via API metadata
    if is_linux || grep -qi microsoft /proc/version 2> /dev/null; then
      # Fetch API metadata to check platform support
      local api_response
      api_response=$(curl -sf "https://formulae.brew.sh/api/formula/${pkg}.json" 2> /dev/null || echo "")

      if [[ -n "${api_response}" ]]; then
        # Check if the package has platform requirements
        local platforms
        platforms=$(echo "${api_response}" | jq -r '.platform | keys[]' 2> /dev/null || echo "")

        if [[ -n "${platforms}" ]]; then
          # If platform info exists, check if linux is in it
          if echo "${platforms}" | grep -q "linux"; then
            success "Package '${pkg}' exists in Homebrew repository and supports Linux"
            return 0
          else
            error "Package '${pkg}' is not supported on Linux (Darwin-only package)"
            return 1
          fi
        else
          # No platform info, assume it's cross-platform
          success "Package '${pkg}' exists in Homebrew repository"
          return 0
        fi
      fi
    else
      success "Package '${pkg}' exists in Homebrew repository"
      return 0
    fi
  fi

  if is_macos && check_package_in_api "${pkg}" "cask"; then
    success "Package '${pkg}' exists as a cask in Homebrew repository"
    return 0
  fi

  error "Package '${pkg}' not found in Homebrew repository"
  return 1
}

# Comprehensive check: outdated packages, invalid packages, unsupported platform packages
comprehensive_check() {
  local forced_platform="${1:-}"  # Optional forced platform: 'linux' or 'darwin'
  local quiet_mode="${2:-false}"  # Optional quiet mode
  local force_check="${3:-false}" # Optional force check
  local root_dir
  root_dir="$(get_root_dir)"

  local marker_file="${root_dir}/.brewcheck"

  if [[ "${force_check}" != "true" ]] && [[ -f "${marker_file}" ]]; then
    # Check if file is less than 24 hours old
    if [[ -n $(find "${marker_file}" -mtime -1 2> /dev/null) ]]; then
      if [[ "${quiet_mode}" != "true" ]]; then
        # Calculate relative time
        local now file_time elapsed_secs
        now=$(date +%s)
        if is_macos; then
          file_time=$(stat -f %m "${marker_file}")
        else
          file_time=$(stat -c %Y "${marker_file}")
        fi
        elapsed_secs=$((now - file_time))

        local time_ago
        if [[ ${elapsed_secs} -lt 60 ]]; then
          time_ago="just now"
        elif [[ ${elapsed_secs} -lt 3600 ]]; then
          time_ago="$((elapsed_secs / 60))m ago"
        else
          time_ago="$((elapsed_secs / 3600))h ago"
        fi
        info "â³ Brew check ran ${time_ago}. Skipping... (use --force to override)"
      fi
      return 0
    fi
  fi

  if [[ "${quiet_mode}" != "true" ]]; then
    info "ðŸ” Running comprehensive Homebrew check..."
    echo ""
  fi

  # Get current OS or use forced platform
  local current_os="${forced_platform}"
  if [[ -z "${current_os}" ]]; then
    if is_macos; then
      current_os="darwin"
    else
      current_os="linux"
    fi
  fi

  local issues_found=0

  # 1. Check for outdated packages (only on actual platform, not forced)
  if [[ -z "${1:-}" ]]; then
    [[ "${quiet_mode}" != "true" ]] && info "ðŸ“¦ Checking for outdated packages..."
    local outdated_count=0

    if outdated=$(brew outdated --quiet 2> /dev/null); then
      outdated_count=$(echo "${outdated}" | grep -c . 2> /dev/null || true)
      outdated_count=${outdated_count:-0}
      outdated_count=$((${outdated_count//[!0-9]/}))
      if [[ ${outdated_count} -gt 0 ]]; then
        if [[ "${quiet_mode}" != "true" ]]; then
          warn "Found ${outdated_count} outdated package(s):"
          echo "${outdated}" | while IFS= read -r pkg; do
            [[ -n "${pkg}" ]] && echo "  - ${pkg}"
          done
        fi
        ((issues_found++))
      else
        [[ "${quiet_mode}" != "true" ]] && success "All packages are up to date"
      fi
    fi
    [[ "${quiet_mode}" != "true" ]] && echo ""
  else
    [[ "${quiet_mode}" != "true" ]] && info "ðŸ“¦ Skipping outdated package check (forced platform mode)"
    [[ "${quiet_mode}" != "true" ]] && echo ""
  fi

  # Update marker file
  touch "${marker_file}"

  # Summary
  if [[ ${issues_found} -eq 0 ]]; then
    [[ "${quiet_mode}" != "true" ]] && success "All checks passed! No issues found."
    return 0
  else
    if [[ "${quiet_mode}" == "true" ]]; then
      echo "jsh: ${outdated_count} outdated brew package(s). Run 'jsh brew check' or 'brew upgrade'"
    else
      warn "Found ${issues_found} issue(s). Review the output above."
    fi
    return 1
  fi
}

brew_check() {
  # Check if brew is installed (handle root delegation)
  load_brew_user

  local brew_available=false
  if is_root; then
    # When root, check if brew path exists and BREW_USER is configured
    if [[ -n "${BREW_USER:-}" ]] && [[ -n "$(detect_brew_path)" ]]; then
      brew_available=true
    fi
  else
    if command -v brew &> /dev/null; then
      brew_available=true
    fi
  fi

  if [[ "${brew_available}" != "true" ]]; then
    warn "Homebrew is not installed. Run: jsh brew setup"
    return 1
  fi

  local forced_platform=""
  local quiet_mode=false
  local force_check=false
  local -a pkg_args
  pkg_args=()

  # Parse platform flags
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --linux)
        forced_platform="linux"
        shift
        ;;
      --darwin | --macos)
        forced_platform="darwin"
        shift
        ;;
      --quiet | -q)
        quiet_mode=true
        shift
        ;;
      --force | -f)
        force_check=true
        shift
        ;;
      --help | -h)
        info "Usage: jsh brew check [--quiet] [--force] [--linux|--darwin|--macos] [package]"
        info "  --quiet   Silent mode, only output if issues found"
        info "  --force   Force check even if run recently"
        info "  --linux   Force check as if on Linux platform"
        info "  --darwin  Force check as if on Darwin/macOS platform"
        info "  --macos   Alias for --darwin"
        return 0
        ;;
      -*)
        error "Unknown flag: $1"
        info "Usage: jsh brew check [--quiet] [--force] [--linux|--darwin|--macos] [package]"
        return 1
        ;;
      *)
        pkg_args+=("$1")
        shift
        ;;
    esac
  done

  # If a package name is provided, just validate that package
  if [[ ${#pkg_args[@]} -gt 0 ]]; then
    validate_package "${pkg_args[0]}" "${forced_platform}"
    return $?
  fi

  # Otherwise run comprehensive checks
  comprehensive_check "${forced_platform}" "${quiet_mode}" "${force_check}"
}

# ============================================================================
# Brew Wrapper Function (with root delegation)
# ============================================================================

# Helper function to run brew (handles root delegation)
run_brew() {
  load_brew_user

  if is_root; then
    if [[ -z "${BREW_USER:-}" ]]; then
      error "Running as root without configured brew user."
      info "Run: jsh brew setup"
      return 1
    fi

    if ! user_exists "${BREW_USER}"; then
      error "Brew user '${BREW_USER}' does not exist."
      info "Run: jsh brew setup"
      return 1
    fi

    # Use run_as_brew_user to properly setup environment
    run_as_brew_user brew "$@"
  else
    brew "$@"
  fi
}

# Wrapper for brew command that handles root delegation
brew_cmd() {
  load_brew_user

  if is_root; then
    if [[ -z "${BREW_USER:-}" ]]; then
      warn "Running as root without configured brew user."
      warn "Please run 'jsh brew setup' to configure brew delegation."
      return 1
    fi
    run_as_brew_user brew "$@"
  else
    brew "$@"
  fi
}

# Get the user's login shell
get_user_shell() {
  local user_shell
  if is_macos; then
    user_shell=$(dscl . -read ~/ UserShell 2> /dev/null | awk '{print $2}')
  else
    user_shell=$(getent passwd "$(whoami)" 2> /dev/null | cut -d: -f7)
  fi
  echo "${user_shell}"
}

# ============================================================================
# Upgrade Helpers (for TUI integration)
# ============================================================================

# Get list of outdated packages
# Returns: newline-separated list of package names
brew_get_outdated() {
  run_brew outdated --quiet 2> /dev/null || true
}

# Get count of outdated packages
# Returns: integer count
brew_get_outdated_count() {
  local outdated
  outdated=$(brew_get_outdated)
  if [[ -z "$outdated" ]]; then
    echo 0
  else
    echo "$outdated" | wc -l | tr -d ' '
  fi
}

# Run brew update with progress callback
# Arguments:
#   $1 - callback function name (receives: stage, message)
brew_update_with_progress() {
  local callback="${1:-}"

  [[ -n "$callback" ]] && "$callback" "start" "Updating Homebrew"

  if run_brew update 2>&1 | while IFS= read -r line; do
    # Parse update output for progress info
    if [[ "$line" == *"Fetching"* ]]; then
      local repo="${line#*Fetching }"
      [[ -n "$callback" ]] && "$callback" "item" "Fetching $repo"
    elif [[ "$line" == *"Updated"* ]]; then
      [[ -n "$callback" ]] && "$callback" "item" "$line"
    fi
  done; then
    [[ -n "$callback" ]] && "$callback" "done" "Update complete"
    return 0
  else
    [[ -n "$callback" ]] && "$callback" "fail" "Update failed"
    return 1
  fi
}

# Run brew upgrade with TUI progress
# This streams brew upgrade output and updates TUI progress for each package
brew_upgrade_with_tui() {
  local root_dir
  root_dir="$(get_root_dir)"

  # Source TUI if available and not already loaded
  # (Don't re-source - it resets state variables like _TUI_ENABLED)
  if ! declare -f tui_progress_start &> /dev/null; then
    if [[ -f "$root_dir/src/lib/tui.sh" ]]; then
      # shellcheck source=src/lib/tui.sh
      source "$root_dir/src/lib/tui.sh"
    fi
  fi

  # Check if TUI functions exist
  if ! declare -f tui_progress_start &> /dev/null; then
    # Fallback to simple execution
    log "Upgrading Homebrew packages..."
    run_brew update && run_brew upgrade
    return $?
  fi

  # Phase 1: Update
  tui_progress_start "Updating Homebrew" 0
  local update_output
  update_output=$(run_brew update 2>&1) || {
    tui_progress_fail "Update failed"
    tui_error "$update_output"
    return 1
  }
  # Show relevant update messages
  while IFS= read -r line; do
    if [[ "$line" == *"Fetching"* ]] || [[ "$line" == *"Updated"* ]]; then
      tui_log "${line:0:60}"
    fi
  done <<< "$update_output"
  tui_progress_complete "Homebrew updated"

  # Phase 2: Get outdated packages
  local outdated outdated_count
  outdated=$(brew_get_outdated)
  # Count non-empty lines, trim whitespace
  if [[ -z "$outdated" ]] || [[ "$outdated" == $'\n' ]]; then
    outdated_count=0
  else
    outdated_count=$(echo "$outdated" | grep -c . 2> /dev/null || echo 0)
    # Trim any whitespace/newlines from count
    outdated_count="${outdated_count//[$'\n\r\t ']/}"
    outdated_count="${outdated_count:-0}"
  fi

  if [[ "$outdated_count" -eq 0 ]]; then
    tui_log "All packages are up to date"
    return 0
  fi

  # Phase 3: Upgrade with progress
  tui_progress_start "Upgrading packages" "$outdated_count"

  local current=0
  local current_pkg=""
  local failed_packages=()
  local link_errors=()
  local upgrade_output_file="${TMPDIR:-/tmp}/brew_upgrade_$$"

  # Create the file before starting background process to avoid race condition
  : > "$upgrade_output_file"

  # Run upgrade and capture output to temp file for processing
  run_brew upgrade >> "$upgrade_output_file" 2>&1 &
  local brew_pid=$!

  # Process output in real-time
  local last_line=0
  while kill -0 "$brew_pid" 2> /dev/null; do
    # Read new lines from output file (use process substitution to avoid subshell)
    local current_line=0
    while IFS= read -r line; do
      ((current_line++)) || true
      # Skip lines we've already processed
      [[ "$current_line" -le "$last_line" ]] && continue

      # Detect package being upgraded (brew uses ==> prefix)
      if [[ "$line" =~ ^==\>\ Upgrading\ ([a-zA-Z0-9@._-]+) ]] ||
        [[ "$line" =~ ^Upgrading\ ([a-zA-Z0-9@._-]+) ]]; then
        current_pkg="${BASH_REMATCH[1]}"
        ((current++)) || true
        tui_progress_update "$current" "$current_pkg"
      elif [[ "$line" =~ ^==\>\ Pouring\ ([a-zA-Z0-9@._-]+) ]]; then
        current_pkg="${BASH_REMATCH[1]}"
        tui_progress_update "$current" "pouring $current_pkg"
      elif [[ "$line" =~ ^==\>\ Linking\ ([a-zA-Z0-9@._-]+) ]]; then
        tui_progress_update "$current" "linking ${BASH_REMATCH[1]}"
      fi
    done < "$upgrade_output_file" 2> /dev/null
    last_line="$current_line"
    sleep 0.1
  done

  # Process any remaining output after brew finishes
  while IFS= read -r line; do
    ((last_line++)) || true
    if [[ "$line" =~ ^==\>\ Upgrading\ ([a-zA-Z0-9@._-]+) ]] ||
      [[ "$line" =~ ^Upgrading\ ([a-zA-Z0-9@._-]+) ]]; then
      current_pkg="${BASH_REMATCH[1]}"
      ((current++)) || true
      tui_progress_update "$current" "$current_pkg"
    fi
  done < <(tail -n +"$((last_line + 1))" "$upgrade_output_file" 2> /dev/null)

  # Wait for brew to finish and get exit code
  wait "$brew_pid"
  local exit_code=$?

  # Process final output for errors
  if [[ -f "$upgrade_output_file" ]]; then
    local error_pkg=""

    while IFS= read -r line; do
      # Track current package context
      if [[ "$line" =~ ^==\>\ Upgrading\ ([a-zA-Z0-9@._-]+) ]] ||
        [[ "$line" =~ ^Upgrading\ ([a-zA-Z0-9@._-]+) ]]; then
        error_pkg="${BASH_REMATCH[1]}"
      fi

      # Detect brew link errors
      if [[ "$line" == *"brew link"* ]] || [[ "$line" == *"The \`brew link\`"* ]]; then
        if [[ -n "$error_pkg" ]]; then
          link_errors+=("$error_pkg: $line")
        else
          link_errors+=("$line")
        fi
      fi

      # Detect general errors
      if [[ "$line" == "Error:"* ]] || [[ "$line" == *"Error:"* ]]; then
        if [[ -n "$error_pkg" ]]; then
          failed_packages+=("$error_pkg")
        fi
        tui_error "$line"
      fi
    done < "$upgrade_output_file"

    rm -f "$upgrade_output_file"
  fi

  if [[ $exit_code -eq 0 ]] && [[ ${#link_errors[@]} -eq 0 ]]; then
    tui_progress_complete "Upgraded $outdated_count package(s)"
    return 0
  else
    # Report specific failures
    if [[ ${#link_errors[@]} -gt 0 ]]; then
      tui_progress_fail "The \`brew link\` step did not complete successfully"
      for err in "${link_errors[@]}"; do
        tui_error "$err"
      done
    fi

    if [[ ${#failed_packages[@]} -gt 0 ]]; then
      local unique_failed
      unique_failed=$(printf '%s\n' "${failed_packages[@]}" | sort -u | tr '\n' ', ' | sed 's/,$//')
      tui_error "Failed packages: $unique_failed"
    fi

    if [[ ${#link_errors[@]} -eq 0 ]] && [[ ${#failed_packages[@]} -eq 0 ]]; then
      tui_progress_fail "Some packages failed to upgrade (exit code: $exit_code)"
    fi

    return 1
  fi
}

# src/lib/colors.sh
# Common colors and output functions for jsh

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
BOLD='\033[1m'
RESET='\033[0m'

log() { echo -e "${BLUE}ðŸ”¹ $1${RESET}"; }
info() { echo -e "${CYAN}â„¹ï¸  $1${RESET}"; }
warn() { echo -e "${YELLOW}âš ï¸  $1${RESET}"; }
error() {
  echo -e "${RED}âŒ $1${RESET}"
  exit 1
}
success() { echo -e "${GREEN}âœ… $1${RESET}"; }
header() { echo -e "\n${BOLD}${BLUE}â–¶ $1${RESET}\n"; }

confirm() {
  local prompt="$1"
  local response
  read -n 1 -r -p "${prompt} (y/N): " response
  echo
  case "$response" in
    y | Y) return 0 ;;
    *) return 1 ;;
  esac
}

cmd_exists() { command -v "$1" &> /dev/null; }
is_macos() { [[ "$(uname -s)" == "Darwin" ]]; }
is_linux() { [[ "$(uname -s)" == "Linux" ]]; }
is_wsl() { grep -qi microsoft /proc/version 2> /dev/null; }
is_root() { [[ "${EUID:-$(id -u)}" -eq 0 ]]; }

# Get jsh root directory
get_root_dir() {
  if [[ -n "${JSH_ROOT:-}" ]]; then
    echo "$JSH_ROOT"
  else
    # When compiled by bashly, the script is at the repo root
    local script_path
    script_path="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    # Check if we're the compiled jsh script at root
    if [[ -f "$script_path/src/bashly.yml" ]]; then
      echo "$script_path"
    elif [[ -f "$script_path/../src/bashly.yml" ]]; then
      # We're in bin/
      dirname "$script_path"
    else
      # Fallback: look for .git directory
      local dir="$script_path"
      while [[ "$dir" != "/" ]]; do
        if [[ -d "$dir/.git" ]]; then
          echo "$dir"
          return
        fi
        dir="$(dirname "$dir")"
      done
      echo "$script_path"
    fi
  fi
}

# src/lib/dependencies.sh
# Dependency checking library for jsh
# Validates required tools/commands and reports missing ones with environment-specific guidance
#
# Usage:
#   source dependencies.sh
#   # Core dependencies auto-registered on source
#
#   # Check if a dependency is available
#   if has_dependency "jq"; then
#     # use jq
#   fi
#
#   # Require a dependency (error if missing)
#   require_dependency "git"
#
#   # Report all missing dependencies with install guidance
#   report_missing_dependencies

# Get the directory containing this script (resolve to absolute path)
_JSH_DEPS_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" > /dev/null 2>&1 && pwd)"

# Source environment detection if JSH_ENV not already set
if [[ -z "${JSH_ENV:-}" ]]; then
  # Try multiple locations for environment.sh (handles both dev and installed contexts)
  if [[ -f "${_JSH_DEPS_DIR}/environment.sh" ]]; then
    # shellcheck source=environment.sh
    source "${_JSH_DEPS_DIR}/environment.sh"
    get_jsh_env > /dev/null
  elif [[ -f "${_JSH_DEPS_DIR}/src/lib/environment.sh" ]]; then
    # shellcheck source=src/lib/environment.sh
    source "${_JSH_DEPS_DIR}/src/lib/environment.sh"
    get_jsh_env > /dev/null
  fi
  # If neither exists (fresh install), JSH_ENV stays unset - that's okay
fi

# Source colors for cmd_exists if not already available
if ! declare -f cmd_exists &> /dev/null; then
  if [[ -f "${_JSH_DEPS_DIR}/colors.sh" ]]; then
    # shellcheck source=colors.sh
    source "${_JSH_DEPS_DIR}/colors.sh"
  elif [[ -f "${_JSH_DEPS_DIR}/src/lib/colors.sh" ]]; then
    # shellcheck source=src/lib/colors.sh
    source "${_JSH_DEPS_DIR}/src/lib/colors.sh"
  fi
  # If neither exists, cmd_exists won't be available - callers should handle this
fi

# ============================================================================
# Internal State
# ============================================================================

# Associative array to store dependency metadata
# Key: dependency name
# Value: "check_cmd|required|guidance_macos_personal|guidance_macos_corporate|guidance_truenas|guidance_ssh_remote|guidance_linux_generic"
declare -gA _JSH_DEPS

# Track if core dependencies have been registered
_JSH_DEPS_INITIALIZED=""

# ============================================================================
# Registration Functions
# ============================================================================

# Register a dependency with its check command and install guidance
# Arguments:
#   $1 - name: Dependency identifier
#   $2 - check_cmd: Command/expression to check availability (eval'd)
#   $3 - required: "true" or "false"
#   $4 - guidance_macos_personal: Install instructions for personal macOS
#   $5 - guidance_macos_corporate: Install instructions for corporate macOS
#   $6 - guidance_truenas: Install instructions for TrueNAS
#   $7 - guidance_ssh_remote: Install instructions for SSH sessions
#   $8 - guidance_linux_generic: Install instructions for generic Linux
_register_dependency() {
  local name="$1"
  local check_cmd="$2"
  local required="$3"
  local guidance_macos_personal="${4:-}"
  local guidance_macos_corporate="${5:-}"
  local guidance_truenas="${6:-}"
  local guidance_ssh_remote="${7:-}"
  local guidance_linux_generic="${8:-}"

  # Store as pipe-delimited string
  _JSH_DEPS["$name"]="${check_cmd}|${required}|${guidance_macos_personal}|${guidance_macos_corporate}|${guidance_truenas}|${guidance_ssh_remote}|${guidance_linux_generic}"
}

# ============================================================================
# Check Functions
# ============================================================================

# Check if a single dependency is available
# Arguments:
#   $1 - name: Dependency name
# Returns: 0 if available, 1 if missing
check_dependency() {
  local name="$1"
  local dep_data="${_JSH_DEPS[$name]:-}"

  if [[ -z "$dep_data" ]]; then
    # Unknown dependency
    return 1
  fi

  local check_cmd
  check_cmd="${dep_data%%|*}"

  # Evaluate the check command
  if eval "$check_cmd" &> /dev/null; then
    return 0
  else
    return 1
  fi
}

# Check all registered dependencies
# Returns: Count of missing required dependencies
check_all_dependencies() {
  local missing_required=0
  local name

  for name in "${!_JSH_DEPS[@]}"; do
    local dep_data="${_JSH_DEPS[$name]}"
    local required
    required="$(echo "$dep_data" | cut -d'|' -f2)"

    if ! check_dependency "$name"; then
      if [[ "$required" == "true" ]]; then
        ((missing_required++))
      fi
    fi
  done

  echo "$missing_required"
  return "$missing_required"
}

# Get list of missing dependencies
# Arguments:
#   --required: Only list required dependencies
#   --optional: Only list optional dependencies
# Output: Newline-separated list of missing dependency names
get_missing_dependencies() {
  local filter="${1:-}"
  local name

  for name in "${!_JSH_DEPS[@]}"; do
    if ! check_dependency "$name"; then
      local dep_data="${_JSH_DEPS[$name]}"
      local required
      required="$(echo "$dep_data" | cut -d'|' -f2)"

      case "$filter" in
        --required)
          [[ "$required" == "true" ]] && echo "$name"
          ;;
        --optional)
          [[ "$required" == "false" ]] && echo "$name"
          ;;
        *)
          echo "$name"
          ;;
      esac
    fi
  done
}

# ============================================================================
# Reporting Functions
# ============================================================================

# Get install guidance for a dependency based on current environment
# Arguments:
#   $1 - name: Dependency name
# Output: Install guidance string
_get_guidance() {
  local name="$1"
  local dep_data="${_JSH_DEPS[$name]:-}"

  if [[ -z "$dep_data" ]]; then
    echo "Unknown dependency"
    return
  fi

  local guidance=""
  case "${JSH_ENV:-linux-generic}" in
    macos-personal)
      guidance="$(echo "$dep_data" | cut -d'|' -f3)"
      ;;
    macos-corporate)
      guidance="$(echo "$dep_data" | cut -d'|' -f4)"
      ;;
    truenas)
      guidance="$(echo "$dep_data" | cut -d'|' -f5)"
      ;;
    ssh-remote)
      guidance="$(echo "$dep_data" | cut -d'|' -f6)"
      ;;
    linux-generic | *)
      guidance="$(echo "$dep_data" | cut -d'|' -f7)"
      ;;
  esac

  # Fall back to linux-generic guidance if specific guidance is empty
  if [[ -z "$guidance" ]]; then
    guidance="$(echo "$dep_data" | cut -d'|' -f7)"
  fi

  # Final fallback
  if [[ -z "$guidance" ]]; then
    guidance="Install $name"
  fi

  echo "$guidance"
}

# Report missing dependencies with install guidance
# Arguments:
#   --quiet: Suppress output
# Returns: 0 if no required deps missing, 1 otherwise
report_missing_dependencies() {
  local quiet=""
  [[ "${1:-}" == "--quiet" ]] && quiet="true"

  local missing_required=0
  local missing_optional=0
  local name
  local output=""

  for name in "${!_JSH_DEPS[@]}"; do
    if ! check_dependency "$name"; then
      local dep_data="${_JSH_DEPS[$name]}"
      local required
      required="$(echo "$dep_data" | cut -d'|' -f2)"
      local guidance
      guidance="$(_get_guidance "$name")"

      if [[ "$required" == "true" ]]; then
        ((missing_required++))
        output+="  [REQUIRED] $name: $guidance\n"
      else
        ((missing_optional++))
        output+="  [optional] $name: $guidance\n"
      fi
    fi
  done

  if [[ -z "$quiet" ]] && [[ -n "$output" ]]; then
    echo "Missing dependencies:"
    echo -e "$output"

    if [[ "$missing_required" -gt 0 ]]; then
      echo "($missing_required required, $missing_optional optional)"
    else
      echo "($missing_optional optional)"
    fi
  fi

  [[ "$missing_required" -eq 0 ]]
}

# ============================================================================
# Predicate Helpers
# ============================================================================

# Boolean check if dependency is available
# Arguments:
#   $1 - name: Dependency name
# Returns: 0 if available, 1 if missing
has_dependency() {
  check_dependency "$1"
}

# Check and error if dependency is missing
# Arguments:
#   $1 - name: Dependency name
# Returns: 0 if available, exits with error if missing
require_dependency() {
  local name="$1"

  if ! check_dependency "$name"; then
    local guidance
    guidance="$(_get_guidance "$name")"
    # Use error function if available, otherwise echo and return 1
    if declare -f error &> /dev/null; then
      error "Required dependency missing: $name. $guidance"
    else
      echo "Error: Required dependency missing: $name. $guidance" >&2
      return 1
    fi
  fi
  return 0
}

# ============================================================================
# Core Dependencies
# ============================================================================

# Register jsh's core dependencies
_register_core_dependencies() {
  # Prevent double registration
  [[ -n "$_JSH_DEPS_INITIALIZED" ]] && return 0
  _JSH_DEPS_INITIALIZED="true"

  # Critical: bash 4.2+
  _register_dependency "bash" \
    '[[ "${BASH_VERSINFO[0]}" -gt 4 ]] || { [[ "${BASH_VERSINFO[0]}" -eq 4 ]] && [[ "${BASH_VERSINFO[1]}" -ge 2 ]]; }' \
    "true" \
    "brew install bash (then add to /etc/shells)" \
    "Request bash 4.2+ from IT, or install manually" \
    "bash 4.2+ typically pre-installed on TrueNAS SCALE" \
    "Upgrade bash on remote host" \
    "apt install bash / dnf install bash"

  # Critical: jq
  _register_dependency "jq" \
    'cmd_exists jq' \
    "true" \
    "brew install jq" \
    "Request jq from IT, or download from https://jqlang.github.io/jq/" \
    "apt install jq (if delegate has permissions)" \
    "Install jq on remote host" \
    "apt install jq / dnf install jq"

  # Optional: brew
  _register_dependency "brew" \
    'cmd_exists brew' \
    "false" \
    "Install Homebrew: https://brew.sh" \
    "Homebrew may require IT approval" \
    "Not available on TrueNAS SCALE" \
    "Not applicable for SSH sessions" \
    "Install Linuxbrew: https://brew.sh"

  # Optional: fzf
  _register_dependency "fzf" \
    'cmd_exists fzf' \
    "false" \
    "brew install fzf" \
    "Use bundled fzf at ~/.jsh/.fzf/" \
    "Use bundled fzf at ~/.jsh/.fzf/" \
    "Feature unavailable in SSH sessions (use bundled)" \
    "apt install fzf / brew install fzf"

  # Optional: git
  _register_dependency "git" \
    'cmd_exists git' \
    "false" \
    "brew install git" \
    "Request git from IT, or use Xcode Command Line Tools" \
    "apt install git (if delegate has permissions)" \
    "Install git on remote host" \
    "apt install git / dnf install git"

  # Optional: zinit (zsh-only)
  _register_dependency "zinit" \
    '[[ -d "${ZINIT[HOME_DIR]:-$HOME/.local/share/zinit/zinit.git}" ]] || [[ -d "$HOME/.zinit" ]]' \
    "false" \
    "Installed automatically when using zsh with jsh" \
    "Installed automatically when using zsh with jsh" \
    "Not applicable (bash-only on TrueNAS)" \
    "Not applicable for SSH sessions" \
    "Installed automatically when using zsh with jsh"
}

# ============================================================================
# Auto-initialization
# ============================================================================

# Register core dependencies when this file is sourced
_register_core_dependencies

# src/lib/environment.sh
# Environment detection library for jsh
# Detects runtime environment type for graceful degradation and environment-specific behavior
#
# Environment types:
#   - macos-personal:   macOS with full admin access, no corporate signals
#   - macos-corporate:  macOS with restrictions (MDM, proxy, restricted paths)
#   - truenas:          TrueNAS SCALE appliance (Debian-based, read-only system)
#   - ssh-remote:       Remote SSH session (any OS, detected via SSH_* vars)
#   - linux-generic:    Linux fallback when no specific environment detected

# Cache configuration
_JSH_ENV_CACHE_DIR="${HOME}/.cache/jsh"
_JSH_ENV_CACHE_FILE="${_JSH_ENV_CACHE_DIR}/environment"
_JSH_ENV_CACHE_TTL=3600 # 1 hour in seconds

# ============================================================================
# Detection Predicates
# ============================================================================

# Check if running in an SSH session
# Returns: 0 (true) if SSH session, 1 (false) otherwise
is_ssh_session() {
  # Check common SSH environment variables
  [[ -n "${SSH_CLIENT:-}" ]] && return 0
  [[ -n "${SSH_TTY:-}" ]] && return 0
  [[ -n "${SSH_CONNECTION:-}" ]] && return 0
  return 1
}

# Check if running on TrueNAS SCALE
# Returns: 0 (true) if TrueNAS, 1 (false) otherwise
is_truenas() {
  # Check for TrueNAS directory
  [[ -d "/usr/share/truenas" ]] && return 0

  # Check /etc/version for TrueNAS or SCALE string
  if [[ -f "/etc/version" ]]; then
    grep -qiE "(truenas|scale)" "/etc/version" 2> /dev/null && return 0
  fi

  return 1
}

# Check for corporate macOS environment
# Returns: 0 (true) if corporate macOS, 1 (false) otherwise
is_macos_corporate() {
  # Must be macOS first
  [[ "$(uname -s)" != "Darwin" ]] && return 1

  # Check for MDM profiles directory with content
  if [[ -d "/var/db/ConfigurationProfiles" ]]; then
    # Check if it's non-empty (has enrolled profiles)
    local profile_count
    profile_count=$(find "/var/db/ConfigurationProfiles" -maxdepth 2 -type f 2> /dev/null | wc -l | tr -d ' ')
    [[ "${profile_count}" -gt 0 ]] && return 0
  fi

  # Check for corporate hostname patterns
  local hostname
  hostname="$(hostname 2> /dev/null || echo '')"
  if [[ -n "${hostname}" ]]; then
    # Common corporate patterns: .corp., .internal., -mac suffix
    [[ "${hostname}" == *".corp."* ]] && return 0
    [[ "${hostname}" == *".internal."* ]] && return 0
    [[ "${hostname}" == *"-mac" ]] && return 0
  fi

  # Check for proxy environment variables (often set by corporate networks)
  [[ -n "${http_proxy:-}" ]] && return 0
  [[ -n "${https_proxy:-}" ]] && return 0
  [[ -n "${HTTP_PROXY:-}" ]] && return 0
  [[ -n "${HTTPS_PROXY:-}" ]] && return 0

  # Check if /usr/local is restricted (common in corporate environments)
  if [[ -d "/usr/local" ]] && [[ ! -w "/usr/local" ]]; then
    return 0
  fi

  return 1
}

# Check for personal macOS environment
# Returns: 0 (true) if personal macOS, 1 (false) otherwise
is_macos_personal() {
  # Must be macOS
  [[ "$(uname -s)" != "Darwin" ]] && return 1

  # Personal means macOS without corporate indicators
  is_macos_corporate && return 1

  return 0
}

# ============================================================================
# Main Detection Function
# ============================================================================

# Detect the current environment type
# Priority order: ssh-remote > truenas > macos-corporate > macos-personal > linux-generic
# Sets JSH_ENV and exports it
detect_environment() {
  local env_type=""

  # SSH detection runs first because you can SSH into any environment type
  # This takes precedence to ensure remote sessions behave appropriately
  if is_ssh_session; then
    env_type="ssh-remote"
  elif is_truenas; then
    env_type="truenas"
  elif [[ "$(uname -s)" == "Darwin" ]]; then
    if is_macos_corporate; then
      env_type="macos-corporate"
    else
      env_type="macos-personal"
    fi
  elif [[ "$(uname -s)" == "Linux" ]]; then
    env_type="linux-generic"
  else
    # Unknown OS fallback
    env_type="linux-generic"
  fi

  JSH_ENV="${env_type}"
  export JSH_ENV
}

# ============================================================================
# Caching Wrapper
# ============================================================================

# Check if cache is valid
# Returns: 0 if cache is valid, 1 if cache should be refreshed
_is_cache_valid() {
  local cache_file="${_JSH_ENV_CACHE_FILE}"
  local mtime_file="${cache_file}.mtime"

  # Cache file must exist
  [[ ! -f "${cache_file}" ]] && return 1
  [[ ! -f "${mtime_file}" ]] && return 1

  # Cache must not be empty
  [[ ! -s "${cache_file}" ]] && return 1

  # Check TTL
  local cached_mtime current_time
  cached_mtime=$(cat "${mtime_file}" 2> /dev/null || echo "0")
  current_time=$(date +%s)

  if ((current_time - cached_mtime >= _JSH_ENV_CACHE_TTL)); then
    return 1
  fi

  return 0
}

# Write cache
_write_cache() {
  local env_type="$1"

  mkdir -p "${_JSH_ENV_CACHE_DIR}"
  echo "${env_type}" > "${_JSH_ENV_CACHE_FILE}"
  date +%s > "${_JSH_ENV_CACHE_FILE}.mtime"
}

# Read cache
_read_cache() {
  cat "${_JSH_ENV_CACHE_FILE}" 2> /dev/null
}

# Get JSH environment with caching
# This is the primary entry point for shell startup
get_jsh_env() {
  if _is_cache_valid; then
    JSH_ENV=$(_read_cache)
    export JSH_ENV
  else
    detect_environment
    _write_cache "${JSH_ENV}"
  fi

  # Return the environment type for callers that want it
  echo "${JSH_ENV}"
}

# Force re-detection (bypasses cache)
refresh_jsh_env() {
  detect_environment
  _write_cache "${JSH_ENV}"
  echo "${JSH_ENV}"
}

# Clear the environment cache
clear_jsh_env_cache() {
  rm -f "${_JSH_ENV_CACHE_FILE}" "${_JSH_ENV_CACHE_FILE}.mtime" 2> /dev/null
}

# src/lib/git.sh
# Git helper functions for jsh
# Provides utilities for git operations with graceful fallbacks

# Git clone helper that forces HTTPS even if user has SSH URL rewriting configured
# This handles environments where SSH is not available (containers, restricted systems)
#
# Usage: git_clone_https <url> <destination>
#
# Returns: 0 on success, 1 on failure
git_clone_https() {
  local url="$1"
  local dest="$2"

  # Validate arguments
  if [[ -z "$url" || -z "$dest" ]]; then
    echo "Usage: git_clone_https <url> <destination>" >&2
    return 1
  fi

  # First try normal clone (works if HTTPS is properly configured)
  if git clone "$url" "$dest" 2> /dev/null; then
    return 0
  fi

  # If that fails, force HTTPS by disabling common SSH rewrites
  # This handles cases where user has url.<base>.insteadOf configured
  if declare -f log &> /dev/null; then
    log "Retrying with forced HTTPS..."
  fi

  # shellcheck disable=SC2140  # Git config syntax requires this quoting pattern
  if git -c 'url.https://github.com/.insteadOf=git@github.com:' \
    -c 'url.https://github.com/.insteadOf=ssh://git@github.com/' \
    -c 'url.https://gitlab.com/.insteadOf=git@gitlab.com:' \
    -c 'url.https://bitbucket.org/.insteadOf=git@bitbucket.org:' \
    clone "$url" "$dest" 2> /dev/null; then
    return 0
  fi

  # Final attempt: disable SSH entirely for this operation
  GIT_SSH_COMMAND="false" git clone "$url" "$dest" 2> /dev/null
}

# Update a git repository, falling back to HTTPS if SSH fails
# Usage: git_pull_https <repo_path>
git_pull_https() {
  local repo_path="$1"

  if [[ -z "$repo_path" || ! -d "$repo_path" ]]; then
    return 1
  fi

  # First try normal pull
  if git -C "$repo_path" pull 2> /dev/null; then
    return 0
  fi

  # Force HTTPS
  # shellcheck disable=SC2140  # Git config syntax requires this quoting pattern
  git -C "$repo_path" \
    -c 'url.https://github.com/.insteadOf=git@github.com:' \
    -c 'url.https://github.com/.insteadOf=ssh://git@github.com/' \
    pull 2> /dev/null
}

# src/lib/graceful.sh
# Graceful degradation library for jsh
# Provides safe helpers for sourcing, eval, and completion loading
# that gracefully skip unavailable features without errors
#
# Requires: Bash 4.2+
# Dependencies: Optionally uses has_dependency from dependencies.sh
#
# Usage:
#   source graceful.sh
#   _jsh_try_source "$HOME/.local/config"        # Skip if missing
#   _jsh_try_eval "direnv" "direnv hook bash"    # Skip if command missing
#   _jsh_try_completion "kubectl" "eval"         # Load completion if available
#   _jsh_with_timeout 2 "slow_command"           # Run with timeout

# Get the directory containing this script
_JSH_GRACEFUL_DIR="${_JSH_GRACEFUL_DIR:-$(cd "$(dirname "${BASH_SOURCE[0]}")" > /dev/null 2>&1 && pwd)}"

# ============================================================================
# Debug Logging
# ============================================================================

# Debug logging - only outputs when JSH_DEBUG=1
# Arguments:
#   $@ - Message to log (all arguments joined)
# Output: Writes to stderr when JSH_DEBUG=1, otherwise silent
_jsh_debug() {
  [[ "${JSH_DEBUG:-}" == "1" ]] || return 0
  echo "[jsh:debug] $*" >&2
}

# ============================================================================
# Safe Sourcing
# ============================================================================

# Safely source a file with fallback
# Arguments:
#   $1 - File path to source
#   $2 - Optional fallback value/command on failure
# Returns: 0 on success, 1 if skipped
_jsh_try_source() {
  local file="$1"
  local fallback="${2:-}"

  # Check if file exists and is readable
  if [[ ! -f "$file" ]]; then
    _jsh_debug "skip source: file not found: $file"
    [[ -n "$fallback" ]] && eval "$fallback"
    return 1
  fi

  if [[ ! -r "$file" ]]; then
    _jsh_debug "skip source: file not readable: $file"
    [[ -n "$fallback" ]] && eval "$fallback"
    return 1
  fi

  # Attempt to source the file
  # shellcheck disable=SC1090
  if source "$file"; then
    _jsh_debug "sourced: $file"
    return 0
  else
    _jsh_debug "source failed: $file"
    [[ -n "$fallback" ]] && eval "$fallback"
    return 1
  fi
}

# ============================================================================
# Safe Eval
# ============================================================================

# Safely eval a command if dependency exists
# Arguments:
#   $1 - Command name to check for
#   $2 - Expression to eval if command exists
# Returns: 0 on success, 1 if skipped
_jsh_try_eval() {
  local cmd="$1"
  local expr="$2"

  # Check if command exists using command -v (fast, builtin)
  if ! command -v "$cmd" &> /dev/null; then
    _jsh_debug "skip eval: command not found: $cmd"
    return 1
  fi

  # Attempt to eval the expression
  if eval "$expr"; then
    _jsh_debug "eval success: $cmd"
    return 0
  else
    _jsh_debug "eval failed: $cmd"
    return 1
  fi
}

# ============================================================================
# Safe Completion Loading
# ============================================================================

# Safely load shell completions for a command
# Handles both eval and source patterns
# Arguments:
#   $1 - Command name to check for
#   $2 - Load method: "eval" or "source"
#   $3 - Completion expression (for eval) or file path (for source)
#        If not provided, attempts common patterns
#   $4 - Optional shell name (defaults to current shell)
# Returns: 0 on success, 1 if skipped
_jsh_try_completion() {
  local cmd="$1"
  local method="${2:-eval}"
  local completion_arg="${3:-}"
  local shell="${4:-${SH:-bash}}"

  # Check if command exists
  if ! command -v "$cmd" &> /dev/null; then
    _jsh_debug "skip completion: command not found: $cmd"
    return 1
  fi

  case "$method" in
    eval)
      # If no expression provided, try common patterns
      if [[ -z "$completion_arg" ]]; then
        completion_arg="$cmd completion $shell"
      fi

      # Try to eval the completion command
      local completion_output
      if completion_output=$(eval "$completion_arg" 2> /dev/null); then
        if eval "$completion_output" 2> /dev/null; then
          _jsh_debug "completion loaded (eval): $cmd"
          return 0
        fi
      fi

      _jsh_debug "completion failed (eval): $cmd"
      return 1
      ;;

    source)
      # Source a completion file directly
      if [[ -n "$completion_arg" ]] && [[ -f "$completion_arg" ]] && [[ -r "$completion_arg" ]]; then
        # shellcheck disable=SC1090
        if source "$completion_arg"; then
          _jsh_debug "completion loaded (source): $cmd from $completion_arg"
          return 0
        fi
      fi

      _jsh_debug "completion failed (source): $cmd"
      return 1
      ;;

    *)
      _jsh_debug "completion: unknown method: $method"
      return 1
      ;;
  esac
}

# ============================================================================
# Timeout Execution
# ============================================================================

# Execute a command with timeout
# Arguments:
#   $1 - Timeout in seconds (default: 2)
#   $@ - Command and arguments to execute
# Returns: Command exit status, or 124 on timeout
_jsh_with_timeout() {
  local timeout_secs="${1:-2}"
  shift

  # Check if there's something to run
  if [[ $# -eq 0 ]]; then
    _jsh_debug "timeout: no command provided"
    return 1
  fi

  # Use timeout command if available (GNU coreutils)
  if command -v timeout &> /dev/null; then
    timeout "$timeout_secs" "$@"
    local exit_status=$?
    if [[ $exit_status -eq 124 ]]; then
      _jsh_debug "timeout: command timed out after ${timeout_secs}s: $*"
    fi
    return $exit_status
  fi

  # Use gtimeout (Homebrew coreutils on macOS)
  if command -v gtimeout &> /dev/null; then
    gtimeout "$timeout_secs" "$@"
    local exit_status=$?
    if [[ $exit_status -eq 124 ]]; then
      _jsh_debug "timeout: command timed out after ${timeout_secs}s: $*"
    fi
    return $exit_status
  fi

  # Fallback: run without timeout (log warning in debug mode)
  _jsh_debug "timeout: no timeout command available, running without limit: $*"
  "$@"
}

# ============================================================================
# Missing Dependencies Tracking
# ============================================================================

# Array to track missing dependencies during completion loading
declare -ga _JSH_MISSING_DEPS=()

# Track a missing dependency
# Arguments:
#   $1 - Command name
#   $2 - Optional category (e.g., "completion", "tool")
_jsh_track_missing() {
  local cmd="$1"
  local category="${2:-tool}"

  # Add to missing list if not already there
  local existing
  for existing in "${_JSH_MISSING_DEPS[@]}"; do
    [[ "$existing" == "$cmd" ]] && return 0
  done

  _JSH_MISSING_DEPS+=("$cmd")
  _jsh_debug "missing" "Tracked missing $category: $cmd"
}

# Report all tracked missing dependencies with install guidance
# Should be called at end of completion loading
_jsh_report_missing() {
  [[ ${#_JSH_MISSING_DEPS[@]} -eq 0 ]] && return 0

  local pkg_manager=""
  local install_cmd=""

  # Detect package manager
  if command -v brew &> /dev/null; then
    pkg_manager="brew"
    install_cmd="brew install"
  elif command -v apt &> /dev/null; then
    pkg_manager="apt"
    install_cmd="sudo apt install"
  elif command -v dnf &> /dev/null; then
    pkg_manager="dnf"
    install_cmd="sudo dnf install"
  elif command -v pacman &> /dev/null; then
    pkg_manager="pacman"
    install_cmd="sudo pacman -S"
  fi

  # Print warning
  echo ""
  echo -e "\033[33mâš ï¸  Some optional tools are missing:\033[0m"
  for cmd in "${_JSH_MISSING_DEPS[@]}"; do
    echo "   â€¢ $cmd"
  done

  # Suggest installation
  if [[ -n "$install_cmd" ]]; then
    echo ""
    echo -e "\033[34mâ„¹ï¸  Install with:\033[0m $install_cmd ${_JSH_MISSING_DEPS[*]}"
  fi

  # Suggest jsh tools if available
  if command -v jsh &> /dev/null; then
    echo -e "\033[34mâ„¹ï¸  Or run:\033[0m jsh tools install"
  fi
  echo ""

  # Clear the list
  _JSH_MISSING_DEPS=()
}

# ============================================================================
# Auto-source dependencies if needed (lazy load)
# ============================================================================

# Ensure has_dependency is available (for scripts that need it)
# This is lazy-loaded to avoid sourcing dependencies.sh unnecessarily
_jsh_ensure_has_dependency() {
  if ! declare -f has_dependency &> /dev/null; then
    if [[ -f "${_JSH_GRACEFUL_DIR}/dependencies.sh" ]]; then
      # shellcheck source=dependencies.sh
      source "${_JSH_GRACEFUL_DIR}/dependencies.sh"
      _jsh_debug "lazy loaded: dependencies.sh"
    else
      _jsh_debug "dependencies.sh not found, has_dependency unavailable"
      return 1
    fi
  fi
  return 0
}

# src/lib/packages.sh
# Package management functions for jsh

# Load packages from JSON file into stdout (one per line)
load_packages_from_json() {
  local json_file="$1"
  if [[ ! -f "$json_file" ]]; then
    return 1
  fi

  if command -v jq &> /dev/null; then
    jq -r '.[]' "$json_file" 2> /dev/null
  else
    grep -o '"[^"]*"' "$json_file" | tr -d '"'
  fi
}

# Add a package to a JSON array file (sorted, no duplicates)
add_package_to_json() {
  local json_file="$1"
  local package="$2"

  if [[ -z "$json_file" || -z "$package" ]]; then
    error "Usage: add_package_to_json <json_file> <package>"
  fi

  if ! command -v jq &> /dev/null; then
    error "jq is required for JSON manipulation"
  fi

  if [[ ! -f "$json_file" ]]; then
    echo "[]" > "$json_file"
  fi

  if jq -e --arg pkg "$package" 'index($pkg) != null' "$json_file" > /dev/null 2>&1; then
    info "Package '$package' already in $(basename "$json_file")"
    return 0
  fi

  local temp_file
  temp_file=$(mktemp)
  if jq --arg pkg "$package" '. + [$pkg] | sort' "$json_file" > "$temp_file"; then
    mv "$temp_file" "$json_file"
    success "Added '$package' to $(basename "$json_file")"
    return 0
  else
    rm -f "$temp_file"
    error "Failed to add package to $json_file"
  fi
}

# Remove a package from a JSON array file
remove_package_from_json() {
  local json_file="$1"
  local package="$2"

  if [[ -z "$json_file" || -z "$package" ]]; then
    error "Usage: remove_package_from_json <json_file> <package>"
  fi

  if ! command -v jq &> /dev/null; then
    error "jq is required for JSON manipulation"
  fi

  if [[ ! -f "$json_file" ]]; then
    warn "Config file does not exist: $json_file"
    return 1
  fi

  if ! jq -e --arg pkg "$package" 'index($pkg) != null' "$json_file" > /dev/null 2>&1; then
    info "Package '$package' not found in $(basename "$json_file")"
    return 1
  fi

  local temp_file
  temp_file=$(mktemp)
  if jq --arg pkg "$package" 'map(select(. != $pkg))' "$json_file" > "$temp_file"; then
    mv "$temp_file" "$json_file"
    success "Removed '$package' from $(basename "$json_file")"
    return 0
  else
    rm -f "$temp_file"
    error "Failed to remove package from $json_file"
  fi
}

# Search for linuxbrew equivalent
search_linuxbrew_package() {
  local package="$1"
  local root_dir
  root_dir="$(get_root_dir)"
  local linux_formulae_file="$root_dir/configs/linux/formulae.json"

  local search_results
  search_results=$(brew search "$package" 2> /dev/null | grep -v "^==" | grep -v "^$" || true)

  if [[ -z "$search_results" ]]; then
    log "No linuxbrew equivalent found for '$package'"
    return 0
  fi

  local matches=()
  while IFS= read -r line; do
    [[ -n "$line" ]] && matches+=("$line")
  done <<< "$search_results"

  local match_count=${#matches[@]}

  if [[ $match_count -eq 0 ]]; then
    log "No linuxbrew equivalent found for '$package'"
    return 0
  elif [[ $match_count -eq 1 ]]; then
    local linux_package="${matches[0]}"
    info "Found linuxbrew equivalent: $linux_package"
    add_package_to_json "$linux_formulae_file" "$linux_package"
  else
    echo ""
    info "Multiple linuxbrew matches found for '$package':"
    local i=1
    for match in "${matches[@]}"; do
      echo "  $i) $match"
      ((i++))
    done
    echo "  0) Skip"
    echo ""

    local selection
    read -r -p "Select package number [0-$match_count]: " selection

    if [[ "$selection" =~ ^[0-9]+$ ]] && [[ "$selection" -ge 1 ]] && [[ "$selection" -le "$match_count" ]]; then
      local selected_package="${matches[$((selection - 1))]}"
      info "Adding linuxbrew package: $selected_package"
      add_package_to_json "$linux_formulae_file" "$selected_package"
    fi
  fi
}

# Prompt for winget package ID
prompt_winget_package() {
  local package="$1"
  local root_dir
  root_dir="$(get_root_dir)"
  local winget_file="$root_dir/configs/windows/winget.json"

  echo ""
  info "Enter the winget package ID for '$package' (or press Enter to skip):"
  info "Hint: Search at https://winget.run or https://winstall.app"
  echo ""

  local winget_id
  read -r -p "Winget package ID: " winget_id

  if [[ -n "$winget_id" ]]; then
    info "Adding winget package: $winget_id"
    add_package_to_json "$winget_file" "$winget_id"
  fi
}

# Search for cross-platform equivalents
search_cross_platform_packages() {
  local package="$1"
  [[ -z "$package" ]] && return 0

  log "Searching for cross-platform package equivalents..."
  search_linuxbrew_package "$package"
  prompt_winget_package "$package"
}

# Update package manager cache
update_package_cache() {
  if is_linux; then
    if command -v apt-get &> /dev/null; then
      sudo apt-get update
    elif command -v dnf &> /dev/null; then
      sudo dnf check-update || true
    elif command -v yum &> /dev/null; then
      sudo yum check-update || true
    elif command -v pacman &> /dev/null; then
      sudo pacman -Sy
    elif command -v apk &> /dev/null; then
      sudo apk update
    elif command -v zypper &> /dev/null; then
      sudo zypper refresh
    fi
  fi
}

# Ensure Homebrew is installed
# Arguments:
#   $1 - non_interactive: "true" to skip prompts (default: "false")
# Returns: 0 if brew is available, 1 if installation failed
ensure_brew() {
  local non_interactive="${1:-false}"

  # Already installed
  if command -v brew &> /dev/null; then
    return 0
  fi

  log "Homebrew not found, attempting to install..."

  # Set non-interactive mode for Homebrew installer
  if [[ "$non_interactive" == "true" ]]; then
    export NONINTERACTIVE=1
  fi

  # Install Homebrew
  if is_macos || is_linux; then
    if ! /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"; then
      warn "Failed to install Homebrew"
      return 1
    fi

    # Add brew to PATH for the current session
    if is_macos; then
      if [[ -f /opt/homebrew/bin/brew ]]; then
        eval "$(/opt/homebrew/bin/brew shellenv)"
      elif [[ -f /usr/local/bin/brew ]]; then
        eval "$(/usr/local/bin/brew shellenv)"
      fi
    elif is_linux; then
      if [[ -f /home/linuxbrew/.linuxbrew/bin/brew ]]; then
        eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)"
      elif [[ -f "$HOME/.linuxbrew/bin/brew" ]]; then
        eval "$("$HOME/.linuxbrew/bin/brew" shellenv)"
      fi
    fi

    # Verify installation
    if command -v brew &> /dev/null; then
      success "Homebrew installed successfully"
      return 0
    else
      warn "Homebrew installed but not in PATH"
      return 1
    fi
  else
    warn "Homebrew installation not supported on this platform"
    return 1
  fi
}

# Install a package using the system package manager
install_package() {
  local package="$1"

  if is_macos; then
    if command -v brew &> /dev/null; then
      brew install "$package"
    else
      warn "No package manager available on macOS"
      return 1
    fi
  elif is_linux; then
    if command -v apt-get &> /dev/null; then
      sudo apt-get install -y "$package"
    elif command -v dnf &> /dev/null; then
      sudo dnf install -y "$package"
    elif command -v yum &> /dev/null; then
      sudo yum install -y "$package"
    elif command -v pacman &> /dev/null; then
      sudo pacman -S --noconfirm "$package"
    elif command -v apk &> /dev/null; then
      sudo apk add "$package"
    elif command -v zypper &> /dev/null; then
      sudo zypper install -y "$package"
    else
      warn "No supported package manager found"
      return 1
    fi
  else
    warn "Unsupported operating system"
    return 1
  fi
}

# Upgrade all packages
upgrade_packages() {
  if is_macos; then
    if command -v brew &> /dev/null; then
      brew update && brew upgrade
    fi
  elif is_linux; then
    if command -v apt-get &> /dev/null; then
      sudo apt-get update && sudo apt-get upgrade -y
    elif command -v dnf &> /dev/null; then
      sudo dnf upgrade -y
    elif command -v yum &> /dev/null; then
      sudo yum update -y
    elif command -v pacman &> /dev/null; then
      sudo pacman -Syu --noconfirm
    elif command -v apk &> /dev/null; then
      sudo apk upgrade
    elif command -v zypper &> /dev/null; then
      sudo zypper update -y
    fi
  fi
}

# src/lib/profiler.sh
#!/usr/bin/env bash
# Shell initialization profiling library (bash/zsh compatible)
# Usage:
#   source /path/to/profiler.sh
#   profile_init
#   profile_start "section_name" "description"
#   # ... code to profile ...
#   profile_end "section_name"
#   profile_report

# Enable profiling only if JSH_PROFILE is set
: "${JSH_PROFILE:=0}"

# Profiling data storage - file-based for shell compatibility
# Using files avoids associative array issues across bash/zsh versions
_PROFILE_DIR="${HOME}/.cache/jsh/profile/current"
_PROFILE_TOTAL_START=0
_PROFILE_ENABLED=0

# Initialize profiling
profile_init() {
  if [[ "${JSH_PROFILE}" != "1" ]]; then
    return 0
  fi

  _PROFILE_ENABLED=1

  # Clean up any previous profile run
  rm -rf "${_PROFILE_DIR}" 2> /dev/null
  mkdir -p "${_PROFILE_DIR}"

  _PROFILE_TOTAL_START=$(get_time_ms)
  echo "${_PROFILE_TOTAL_START}" > "${_PROFILE_DIR}/_total_start"
  : > "${_PROFILE_DIR}/_order" # Create empty order file
}

# Get current time in milliseconds
get_time_ms() {
  if [[ "$(uname -s)" == "Darwin" ]]; then
    # macOS
    python3 -c 'import time; print(int(time.time() * 1000))'
  else
    # Linux
    date +%s%3N
  fi
}

# Start profiling a section
profile_start() {
  [[ "${_PROFILE_ENABLED}" != "1" ]] && [[ ! -d "${_PROFILE_DIR}" ]] && return 0

  local section_name="$1"
  local description="${2:-$section_name}"

  # Store start time and description in files
  get_time_ms > "${_PROFILE_DIR}/${section_name}.start"
  echo "${description}" > "${_PROFILE_DIR}/${section_name}.desc"

  # Track order of sections
  if ! grep -qx "${section_name}" "${_PROFILE_DIR}/_order" 2> /dev/null; then
    echo "${section_name}" >> "${_PROFILE_DIR}/_order"
  fi
}

# End profiling a section
profile_end() {
  [[ "${_PROFILE_ENABLED}" != "1" ]] && [[ ! -d "${_PROFILE_DIR}" ]] && return 0

  local section_name="$1"

  if [[ ! -f "${_PROFILE_DIR}/${section_name}.start" ]]; then
    echo "Warning: profile_end called for '$section_name' without matching profile_start" >&2
    return 1
  fi

  get_time_ms > "${_PROFILE_DIR}/${section_name}.end"
}

# Get duration for a section in milliseconds
profile_duration() {
  local section_name="$1"
  local start_file="${_PROFILE_DIR}/${section_name}.start"
  local end_file="${_PROFILE_DIR}/${section_name}.end"

  if [[ ! -f "${start_file}" ]] || [[ ! -f "${end_file}" ]]; then
    echo "0"
    return 1
  fi

  local start end
  start=$(cat "${start_file}")
  end=$(cat "${end_file}")
  echo $((end - start))
}

# Generate profiling report
profile_report() {
  [[ ! -d "${_PROFILE_DIR}" ]] && return 0

  local total_end total_start total_duration
  total_end=$(get_time_ms)
  total_start=$(cat "${_PROFILE_DIR}/_total_start" 2> /dev/null || echo "$total_end")
  total_duration=$((total_end - total_start))

  # Output format
  local output_format="${JSH_PROFILE_FORMAT:-table}"
  local output_file="${JSH_PROFILE_OUTPUT:-}"

  # Generate report
  local report=""
  report+="=== Shell Initialization Profile ===\n"
  report+="\n"
  report+="Date: $(date '+%Y-%m-%d %H:%M:%S')\n"
  report+="Total Duration: ${total_duration} ms\n"
  report+="\n"

  if [[ "$output_format" == "json" ]]; then
    profile_report_json
    return
  fi

  # Table format (default) - use actual newlines for compatibility
  {
    echo "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”"
    echo "â”‚ Section                                 â”‚ Time (ms)â”‚ % Total â”‚"
    echo "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤"

    local accumulated_time=0 duration description percentage
    while IFS= read -r section || [[ -n "$section" ]]; do
      [[ -z "$section" ]] && continue
      # Skip wrapper sections (they contain other sections, would double-count)
      [[ "$section" == *"_total" ]] && continue

      duration=$(profile_duration "$section")
      description=$(cat "${_PROFILE_DIR}/${section}.desc" 2> /dev/null || echo "$section")
      percentage=0

      if [[ "$total_duration" -gt 0 ]]; then
        percentage=$((duration * 100 / total_duration))
      fi

      accumulated_time=$((accumulated_time + duration))

      # Truncate description if too long
      if [[ ${#description} -gt 39 ]]; then
        description="${description:0:36}..."
      fi

      printf "â”‚ %-39s â”‚ %8d â”‚ %6d%% â”‚\n" "$description" "$duration" "$percentage"
    done < "${_PROFILE_DIR}/_order"

    # Calculate unaccounted time
    local unaccounted=$((total_duration - accumulated_time))
    local unaccounted_pct=0
    if [[ "$total_duration" -gt 0 ]] && [[ "$unaccounted" -gt 0 ]]; then
      unaccounted_pct=$((unaccounted * 100 / total_duration))
      printf "â”‚ %-39s â”‚ %8d â”‚ %6d%% â”‚\n" "(other: keybindings, options, etc.)" "$unaccounted" "$unaccounted_pct"
    fi

    echo "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤"
    printf "â”‚ %-39s â”‚ %8d â”‚ %6d%% â”‚\n" "TOTAL (wall-clock)" "$total_duration" "100"
    echo "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜"

    # Top 5 slowest sections
    echo ""
    echo "=== Top 5 Slowest Sections ==="

    # Build sorted list from files
    local sorted_output="" count=0
    while IFS= read -r section || [[ -n "$section" ]]; do
      [[ -z "$section" ]] && continue
      # Skip wrapper sections
      [[ "$section" == *"_total" ]] && continue
      duration=$(profile_duration "$section")
      sorted_output+="${duration}|${section}"$'\n'
    done < "${_PROFILE_DIR}/_order"

    # Sort by duration (descending) and show top 5
    count=0
    echo "$sorted_output" | sort -t'|' -k1 -rn | head -5 | while IFS='|' read -r dur sec; do
      [[ -z "$sec" ]] && continue
      description=$(cat "${_PROFILE_DIR}/${sec}.desc" 2> /dev/null || echo "$sec")
      printf "%2d. %-40s %6d ms\n" $((count + 1)) "$description" "$dur"
      count=$((count + 1))
    done
  } >&2
}

# Generate JSON format report
profile_report_json() {
  local total_end total_duration
  total_end=$(get_time_ms)
  total_duration=$((total_end - _PROFILE_TOTAL_START))
  local output_file="${JSH_PROFILE_OUTPUT:-}"

  local json="{\n"
  json+="  \"timestamp\": \"$(date -u '+%Y-%m-%dT%H:%M:%SZ')\",\n"
  json+="  \"total_duration_ms\": $total_duration,\n"
  json+="  \"sections\": [\n"

  local first=1 section duration description percentage
  while IFS= read -r section || [[ -n "$section" ]]; do
    [[ -z "$section" ]] && continue
    duration=$(profile_duration "$section")
    description=$(cat "${_PROFILE_DIR}/${section}.desc" 2> /dev/null || echo "$section")
    percentage=0

    if [[ "$total_duration" -gt 0 ]]; then
      percentage=$((duration * 100 / total_duration))
    fi

    if [[ $first -eq 0 ]]; then
      json+=",\n"
    fi
    first=0

    json+="    {\n"
    json+="      \"name\": \"$section\",\n"
    json+="      \"description\": \"$description\",\n"
    json+="      \"duration_ms\": $duration,\n"
    json+="      \"percentage\": $percentage\n"
    json+="    }"
  done < "${_PROFILE_DIR}/_order"

  json+="\n  ]\n"
  json+="}\n"

  if [[ -n "$output_file" ]]; then
    echo -e "$json" > "$output_file"
    echo "Profile report saved to: $output_file" >&2
  else
    echo -e "$json"
  fi
}

# Save profile data for comparison
profile_save() {
  [[ "${_PROFILE_ENABLED}" != "1" ]] && return 0

  local profile_name="${1:-$(date '+%Y%m%d_%H%M%S')}"
  local profile_dir="${HOME}/.cache/jsh/profile"
  local profile_file="${profile_dir}/${profile_name}.json"

  mkdir -p "$profile_dir"

  # Save as JSON
  JSH_PROFILE_OUTPUT="$profile_file" JSH_PROFILE_FORMAT="json" profile_report > /dev/null

  echo "Profile saved: $profile_file" >&2
}

# Compare two profiles
profile_compare() {
  local profile1="$1"
  local profile2="$2"

  if [[ ! -f "$profile1" ]] || [[ ! -f "$profile2" ]]; then
    echo "Error: Profile files not found" >&2
    return 1
  fi

  echo "=== Profile Comparison ===" >&2
  echo "Profile 1: $(basename "$profile1")" >&2
  echo "Profile 2: $(basename "$profile2")" >&2
  echo >&2

  # This is a placeholder for comparison logic
  # Would require jq or python to parse JSON and compare
  echo "Comparison feature requires jq - coming soon" >&2
}

# Convenience function to profile a command
profile_command() {
  [[ "${_PROFILE_ENABLED}" != "1" ]] && {
    "$@"
    return $?
  }

  local section_name="$1"
  shift

  profile_start "$section_name" "$section_name"
  "$@"
  local exit_code=$?
  profile_end "$section_name"

  return $exit_code
}

# Export functions for use in shell configs
if [[ "${BASH_SOURCE[0]}" != "${0}" ]]; then
  # Being sourced
  export -f profile_init profile_start profile_end profile_report 2> /dev/null || true
  export -f profile_save profile_compare profile_command 2> /dev/null || true
fi

# src/lib/projects.sh
# projects.sh - Project directory navigation and status
#
# Provides two functions:
#   project <name>  - cd to a project directory by name (zoxide-like)
#   projects        - List all projects with git status summaries
#
# Configuration:
#   JSH_PROJECTS - Comma-separated list of paths to scan for projects
#                  Supports glob patterns for directories containing projects
#                  and direct paths for individual projects
#
#   Default: "~/.jsh,~/projects/*"
#
# Examples:
#   JSH_PROJECTS="~/.jsh,~/projects/*,~/work/*,/opt/myproject"
#
# Git status format (zsh-style):
#   ~/.jsh    main *9 !9 ?18
#   - * = staged changes
#   - ! = unstaged changes
#   - ? = untracked files

# shellcheck disable=SC2034

# =============================================================================
# Configuration
# =============================================================================

# Ensure essential paths are available (script may load before PATH is configured)
[[ ":$PATH:" != *":/bin:"* ]] && PATH="/bin:$PATH"
[[ ":$PATH:" != *":/usr/bin:"* ]] && PATH="/usr/bin:$PATH"
[[ ":$PATH:" != *":/usr/local/bin:"* ]] && PATH="/usr/local/bin:$PATH"
[[ -d /opt/homebrew/bin && ":$PATH:" != *":/opt/homebrew/bin:"* ]] && PATH="/opt/homebrew/bin:$PATH"

# Default project paths if JSH_PROJECTS not set
_PROJECTS_DEFAULT_PATHS="${HOME}/.jsh,${HOME}/projects/*"

# Remote projects config file
_PROJECTS_REMOTE_CONFIG="${JSH_HOME:-${HOME}/.jsh}/configs/projects/remote.json"

# Portable lowercase conversion (works in both bash and zsh)
_projects_lowercase() {
  printf '%s' "$1" | /usr/bin/tr '[:upper:]' '[:lower:]'
}

# =============================================================================
# Helper Functions
# =============================================================================

# Expand a path pattern to actual directories
# Arguments:
#   $1 - Path pattern (may contain ~ and *)
# Output: List of directories, one per line
_projects_expand_path() {
  local pattern="$1"

  # Expand ~ to $HOME
  pattern="${pattern/#\~/$HOME}"

  # If pattern contains *, expand it
  if [[ "$pattern" == *"*"* ]]; then
    # Use eval for portable glob expansion (works in both bash and zsh)
    # shellcheck disable=SC2034  # expanded is used within eval
    local expanded
    eval "for expanded in $pattern; do [[ -d \"\$expanded\" ]] && printf '%s\n' \"\$expanded\"; done" 2>/dev/null
  else
    # Direct path - just check if it exists
    [[ -d "$pattern" ]] && printf '%s\n' "$pattern"
  fi
}

# Get all project directories from JSH_PROJECTS
# Output: List of project directories, one per line
_projects_get_all() {
  local paths="${JSH_PROJECTS:-$_PROJECTS_DEFAULT_PATHS}"
  local path

  # Split on comma using parameter substitution (portable between bash and zsh)
  # Use literal newline for compatibility
  local newline='
'
  local paths_newline="${paths//,/${newline}}"

  while IFS= read -r path; do
    # Skip empty entries
    [[ -z "$path" ]] && continue

    # Trim whitespace
    path="${path#"${path%%[![:space:]]*}"}"
    path="${path%"${path##*[![:space:]]}"}"

    _projects_expand_path "$path"
  done <<< "$paths_newline"
}

# Get git status summary for a directory (with color codes)
# Arguments:
#   $1 - Directory path
#   $2 - If "color", output with ANSI color codes
# Output: Status string like "main *2 !3 ?5" or empty if not a git repo
_projects_git_status() {
  local dir="$1"
  local use_color="${2:-}"

  # Check if it's a git repo
  if [[ ! -d "$dir/.git" ]] && ! git -C "$dir" rev-parse --git-dir &>/dev/null; then
    return
  fi

  local branch staged unstaged untracked git_status=""

  # Color codes (only used if use_color is set)
  local C_CYAN="" C_GREEN="" C_YELLOW="" C_RED="" C_RESET=""
  if [[ "$use_color" == "color" ]]; then
    C_CYAN=$'\033[36m'
    C_GREEN=$'\033[32m'
    C_YELLOW=$'\033[33m'
    C_RED=$'\033[31m'
    C_RESET=$'\033[0m'
  fi

  # Get branch name
  branch=$(git -C "$dir" branch --show-current 2>/dev/null)
  [[ -z "$branch" ]] && branch=$(git -C "$dir" rev-parse --short HEAD 2>/dev/null || echo "unknown")

  # Color main/master/develop branches cyan
  if [[ "$branch" == "main" || "$branch" == "master" || "$branch" == "develop" ]]; then
    git_status="${C_CYAN}${branch}${C_RESET}"
  else
    git_status="$branch"
  fi

  # Count staged changes (green)
  staged=$(git -C "$dir" diff --cached --numstat 2>/dev/null | wc -l | tr -d ' ')
  [[ "$staged" -gt 0 ]] && git_status+=" ${C_GREEN}*${staged}${C_RESET}"

  # Count unstaged changes (yellow)
  unstaged=$(git -C "$dir" diff --numstat 2>/dev/null | wc -l | tr -d ' ')
  [[ "$unstaged" -gt 0 ]] && git_status+=" ${C_YELLOW}!${unstaged}${C_RESET}"

  # Count untracked files (red)
  untracked=$(git -C "$dir" ls-files --others --exclude-standard 2>/dev/null | wc -l | tr -d ' ')
  [[ "$untracked" -gt 0 ]] && git_status+=" ${C_RED}?${untracked}${C_RESET}"

  printf '%s\n' "$git_status"
}

# Get display name for a project (shortened path)
# Arguments:
#   $1 - Full path
# Output: Shortened display path (e.g., ~/.jsh instead of /Users/jay/.jsh)
_projects_display_name() {
  local path="$1"

  # Replace $HOME with ~ using parameter substitution (portable)
  if [[ "$path" == "$HOME"* ]]; then
    printf '%s\n' "~${path#$HOME}"
  else
    printf '%s\n' "$path"
  fi
}

# =============================================================================
# Remote Project Functions
# =============================================================================

# Get remote project info from config
# Arguments:
#   $1 - Project name
# Output: JSON object with host and path, or empty if not found
_projects_get_remote() {
  local name="$1"

  if [[ ! -f "$_PROJECTS_REMOTE_CONFIG" ]]; then
    return 1
  fi

  jq -r --arg name "$name" '.remotes[$name] // empty' "$_PROJECTS_REMOTE_CONFIG" 2>/dev/null
}

# List all remote projects
# Output: Project names, one per line
_projects_list_remotes() {
  if [[ ! -f "$_PROJECTS_REMOTE_CONFIG" ]]; then
    return 0
  fi

  jq -r '.remotes | keys[]' "$_PROJECTS_REMOTE_CONFIG" 2>/dev/null
}

# Open a remote project in VS Code
# Arguments:
#   $1 - Project name
# Returns: 0 on success, 1 on failure
_projects_open_remote() {
  local name="$1"
  local remote_info host remote_path description

  remote_info="$(_projects_get_remote "$name")"

  if [[ -z "$remote_info" ]]; then
    printf '%s\n' "No remote project found: $name" >&2
    printf '%s\n' "" >&2
    printf '%s\n' "Available remote projects:" >&2
    _projects_list_remotes | while read -r proj; do
      printf '%s\n' "  $proj" >&2
    done
    return 1
  fi

  host=$(printf '%s' "$remote_info" | jq -r '.host')
  remote_path=$(printf '%s' "$remote_info" | jq -r '.path')
  description=$(printf '%s' "$remote_info" | jq -r '.description // empty')

  if [[ -z "$host" ]] || [[ -z "$remote_path" ]]; then
    printf '%s\n' "Invalid remote project config for: $name" >&2
    return 1
  fi

  # Open in VS Code Remote SSH
  local C_CYAN=$'\033[36m' C_DIM=$'\033[2m' C_RESET=$'\033[0m'
  printf '%b\n' "Opening remote: ${C_CYAN}${name}${C_RESET} (${host}:${remote_path})"
  [[ -n "$description" ]] && printf '%b\n' "  ${C_DIM}${description}${C_RESET}"

  code --remote "ssh-remote+${host}" "$remote_path"
}

# =============================================================================
# Main Functions
# =============================================================================

# project - cd to a project directory by name
# Usage: project [-c] [-l] [-r] <name>
#   -c  Open in VS Code after navigating
#   -l  List all projects (runs `projects`)
#   -r  Open remote project in VS Code Remote SSH
# If multiple matches, prompts for selection
project() {
  local open_code=false
  local open_remote=false

  # Parse flags
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -l|--list)
        projects
        return $?
        ;;
      -c|--code)
        open_code=true
        shift
        ;;
      -r|--remote)
        open_remote=true
        shift
        ;;
      -h|--help)
        printf '%s\n' "Usage: project [-c] [-l] [-r] <name>"
        printf '%s\n' ""
        printf '%s\n' "Navigate to a project directory by name."
        printf '%s\n' ""
        printf '%s\n' "Options:"
        printf '%s\n' "  -c, --code    Open in VS Code after navigating"
        printf '%s\n' "  -l, --list    List all projects (runs 'projects')"
        printf '%s\n' "  -r, --remote  Open remote project in VS Code Remote SSH"
        printf '%s\n' ""
        printf '%s\n' "Configure paths with \$JSH_PROJECTS (comma-separated)."
        printf '%s\n' ""
        printf '%s\n' "Current search paths:"
        local paths="${JSH_PROJECTS:-$_PROJECTS_DEFAULT_PATHS}"
        local IFS=','
        local path
        for path in $paths; do
          path="${path#"${path%%[![:space:]]*}"}"
          path="${path%"${path##*[![:space:]]}"}"
          printf '%s\n' "  $path"
        done
        printf '%s\n' ""
        printf '%s\n' "Remote projects (from $_PROJECTS_REMOTE_CONFIG):"
        if [[ -f "$_PROJECTS_REMOTE_CONFIG" ]]; then
          jq -r '.remotes | to_entries[] | "  \(.key): \(.value.host):\(.value.path)"' "$_PROJECTS_REMOTE_CONFIG" 2>/dev/null || \
            printf '%s\n' "  (jq not available)"
        else
          printf '%s\n' "  (none configured)"
        fi
        return 0
        ;;
      -*)
        printf '%s\n' "Unknown option: $1" >&2
        printf '%s\n' "Usage: project [-c] [-r] <name>" >&2
        return 1
        ;;
      *)
        break
        ;;
    esac
  done

  if [[ $# -eq 0 ]]; then
    printf '%s\n' "Usage: project [-c] [-r] <name>"
    printf '%s\n' "Use 'project --help' for more information."
    return 0
  fi

  # Handle remote project mode
  if [[ "$open_remote" == true ]]; then
    _projects_open_remote "$1"
    return $?
  fi

  local name="$1"
  local matches=()
  local dir basename

  # Find all matching projects
  while IFS= read -r dir; do
    [[ -z "$dir" ]] && continue
    basename="${dir##*/}"

    # Case-insensitive match (also match without leading dot)
    local basename_nodot="${basename#.}"
    local name_lower basename_lower basename_nodot_lower
    name_lower="$(_projects_lowercase "$name")"
    basename_lower="$(_projects_lowercase "$basename")"
    basename_nodot_lower="$(_projects_lowercase "$basename_nodot")"

    if [[ "$basename_lower" == "$name_lower" ]] || [[ "$basename_nodot_lower" == "$name_lower" ]]; then
      matches+=("$dir")
    fi
  done < <(_projects_get_all)

  case ${#matches[@]} in
    0)
      printf '%s\n' "No project found matching: $name" >&2
      printf '%s\n' "" >&2
      printf '%s\n' "Available projects:" >&2
      while IFS= read -r dir; do
        [[ -z "$dir" ]] && continue
        printf '%s\n' "  ${dir##*/}" >&2
      done < <(_projects_get_all | sort -u)
      return 1
      ;;
    1)
      # Use ${matches[1]} for zsh compatibility (1-indexed)
      # bash will still work because matches[1] exists after appending one element
      local target="${matches[1]:-${matches[0]}}"
      local C_CYAN=$'\033[36m' C_RESET=$'\033[0m'
      cd "$target" || return 1
      printf '%b\n' "${C_CYAN}$(_projects_display_name "$target")${C_RESET}"
      [[ "$open_code" == true ]] && code .
      ;;
    *)
      local C_CYAN=$'\033[36m' C_YELLOW=$'\033[33m' C_RESET=$'\033[0m'
      printf '%s\n' "Multiple projects match '$name':"
      local i=1
      for dir in "${matches[@]}"; do
        printf '%b\n' "  ${C_YELLOW}$i)${C_RESET} ${C_CYAN}$(_projects_display_name "$dir")${C_RESET}"
        ((i++))
      done
      printf '%s\n' ""

      # Prompt for selection
      local selection
      read -r -p "Select (1-${#matches[@]}): " selection

      if [[ "$selection" =~ ^[0-9]+$ ]] && [[ "$selection" -ge 1 ]] && [[ "$selection" -le ${#matches[@]} ]]; then
        # In zsh, selection can be used directly (1-indexed)
        # In bash, we need selection for 0-indexed, but ${matches[@]} iteration uses the right elements
        local idx="$selection"
        # Try zsh index first, fall back to bash index
        local selected="${matches[$idx]:-${matches[$((idx-1))]}}"
        cd "$selected" || return 1
        printf '%b\n' "${C_CYAN}$(_projects_display_name "$selected")${C_RESET}"
        [[ "$open_code" == true ]] && code .
      else
        printf '%s\n' "Invalid selection" >&2
        return 1
      fi
      ;;
  esac
}

# Truncate a path in the middle if too long
# Arguments:
#   $1 - Path string
#   $2 - Max length
# Output: Truncated path with ... in middle if needed
_projects_truncate_path() {
  local input_path="$1"
  local max_len="${2:-40}"
  local len=${#input_path}

  if [[ $len -le $max_len ]]; then
    printf '%s' "$input_path"
    return
  fi

  # Keep first part and last part, add ... in middle
  local keep=$(( (max_len - 3) / 2 ))
  local first="${input_path:0:$keep}"
  local last="${input_path: -$keep}"
  printf '%s' "${first}...${last}"
}

# projects - List all projects with git status
# Displays a table with project paths and git status summaries
# Shows a fixed footer with scanning progress
projects() {
  # Collect all project directories first
  local all_dirs=()
  local dir

  while IFS= read -r dir; do
    [[ -z "$dir" ]] && continue
    all_dirs+=("$dir")
  done < <(_projects_get_all)

  local total=${#all_dirs[@]}

  if [[ $total -eq 0 ]]; then
    printf '%s\n' "No projects found."
    printf '%s\n' ""
    printf '%s\n' "Configure paths with \$JSH_PROJECTS (comma-separated)."
    printf '%s\n' "Current: ${JSH_PROJECTS:-$_PROJECTS_DEFAULT_PATHS}"
    return 0
  fi

  # Determine if we can use TUI mode (interactive terminal)
  local use_tui=false
  local term_width

  if [[ -t 1 ]] && [[ -z "${JSH_NO_TUI:-}" ]]; then
    use_tui=true
    term_width=$(tput cols 2>/dev/null || printf '%s' 80)
  else
    term_width=80
  fi

  # ANSI color codes
  local CYAN=$'\033[36m'
  local GREEN=$'\033[32m'
  local YELLOW=$'\033[33m'
  local RED=$'\033[31m'
  local BLUE=$'\033[34m'
  local MAGENTA=$'\033[35m'
  local BOLD=$'\033[1m'
  local DIM=$'\033[2m'
  local RESET=$'\033[0m'

  # Calculate column widths - cap based on terminal width
  local max_path_len=40
  local status_col_width=25

  # Adjust for narrow terminals
  if [[ $term_width -lt 80 ]]; then
    max_path_len=$(( term_width - status_col_width - 5 ))
    [[ $max_path_len -lt 20 ]] && max_path_len=20
  fi

  # Results array
  local results=()
  local current=0

  if [[ "$use_tui" == true ]]; then
    # Clear screen and hide cursor
    tput clear
    tput civis  # Hide cursor

    # Set up cleanup trap (INT/TERM for Ctrl+C)
    trap 'tput cnorm' INT TERM
  fi

  # Process each project
  for dir in "${all_dirs[@]}"; do
    ((current++))

    local display_name truncated_name
    display_name="$(_projects_display_name "$dir")"
    truncated_name="$(_projects_truncate_path "$display_name" "$max_path_len")"

    # Update progress at bottom of screen
    if [[ "$use_tui" == true ]]; then
      # Use escape sequence with high row number (clamps to actual bottom)
      printf '\033[999;1H\033[K%b' "${DIM}Scanning ${current}/${total}: ${truncated_name}${RESET}"
    fi

    # Get git status with colors
    local git_status padded_name
    git_status="$(_projects_git_status "$dir" "color")"

    # Format the result with colored path
    padded_name="$(printf "%-${max_path_len}s" "$truncated_name")"

    if [[ -n "$git_status" ]]; then
      results+=("${CYAN}${padded_name}${RESET}  ${git_status}")
    else
      results+=("${DIM}${padded_name}${RESET}  ${DIM}â”€${RESET}")
    fi
  done

  # Clear screen and print results
  if [[ "$use_tui" == true ]]; then
    tput clear  # Clear screen (moves cursor to top)
  fi

  # Print legend/key
  printf '%b\n' "${DIM}Key: ${GREEN}*${RESET}${DIM}staged ${YELLOW}!${RESET}${DIM}modified ${RED}?${RESET}${DIM}untracked${RESET}"
  printf '%s\n' ""

  # Print header
  local header_project header_status
  header_project="$(printf "%-${max_path_len}s" "PROJECT")"
  header_status="STATUS"
  printf '%b\n' "${BOLD}${header_project}  ${header_status}${RESET}"
  printf '%*s\n' "$((max_path_len + status_col_width))" '' | /usr/bin/tr ' ' 'â”€'

  # Print results (already colorized)
  for line in "${results[@]}"; do
    printf '%b\n' "$line"
  done

  # Print summary footer
  printf '%*s\n' "$((max_path_len + status_col_width))" '' | /usr/bin/tr ' ' 'â”€'
  printf '%b\n' "${DIM}${total} projects${RESET}  ${DIM}Key: ${GREEN}*${RESET}${DIM}staged ${YELLOW}!${RESET}${DIM}modified ${RED}?${RESET}${DIM}untracked${RESET}"

  if [[ "$use_tui" == true ]]; then
    # Show cursor and reset trap
    printf '\033[?25h'
    trap - INT TERM
  fi
}

# =============================================================================
# Completion Support
# =============================================================================

# Completion function for project command
_project_completions() {
  local cur="${COMP_WORDS[COMP_CWORD]}"
  local prev="${COMP_WORDS[COMP_CWORD-1]}"
  local projects=()
  local dir

  # Check if completing after -r/--remote flag
  if [[ "$prev" == "-r" ]] || [[ "$prev" == "--remote" ]]; then
    # Complete with remote project names
    while IFS= read -r proj; do
      [[ -z "$proj" ]] && continue
      projects+=("$proj")
    done < <(_projects_list_remotes)
  else
    # Complete with local project names
    while IFS= read -r dir; do
      [[ -z "$dir" ]] && continue
      projects+=("${dir##*/}")
    done < <(_projects_get_all)
  fi

  # shellcheck disable=SC2207
  COMPREPLY=($(compgen -W "${projects[*]}" -- "$cur"))
}

# Alias for quick access
alias p='project'

# Register completion for bash
if [[ -n "${BASH_VERSION:-}" ]]; then
  complete -F _project_completions project
  complete -F _project_completions p
fi

# Register completion for zsh (contains zsh-specific syntax, excluded from shfmt)
if [[ -n "${ZSH_VERSION:-}" ]]; then
  # Zsh completion
  _project_zsh_completions() {
    local projects=()
    local dir
    local -a words
    # shellcheck disable=SC2206,SC2296  # Zsh-specific syntax
    words=(${(s: :)BUFFER})

    # Check if completing after -r/--remote flag
    if [[ "${words[-1]}" == "-r" ]] || [[ "${words[-1]}" == "--remote" ]] || \
       [[ "${words[-2]}" == "-r" ]] || [[ "${words[-2]}" == "--remote" ]]; then
      # Complete with remote project names
      while IFS= read -r proj; do
        [[ -z "$proj" ]] && continue
        projects+=("$proj")
      done < <(_projects_list_remotes)
    else
      # Complete with local project names
      while IFS= read -r dir; do
        [[ -z "$dir" ]] && continue
        projects+=("${dir##*/}")
      done < <(_projects_get_all)
    fi

    _describe 'project' projects
  }

  # Only set up if compdef exists
  if (( ${+functions[compdef]} )); then
    compdef _project_zsh_completions project
    compdef _project_zsh_completions p
  fi
fi

# src/lib/ssh.sh
# SSH portability library for jsh
# Provides bundle/inject functionality for portable SSH sessions
#
# This library enables "jssh" - SSH with your shell config.
# It creates a minimal jsh config bundle, encodes it, and injects it
# into remote SSH sessions via command substitution.
#
# Requires: Bash 4.2+
# Dependencies: tar, base64 (on local system)
# Remote needs: bash, base64, tar (ubiquitous)
#
# Usage:
#   source ssh.sh
#   _jsh_ssh_bundle           # Returns base64-encoded config payload
#   _jsh_ssh_inject_command host [ssh_args...]  # Echoes full SSH command

# Get the directory containing this script
_JSH_SSH_DIR="${_JSH_SSH_DIR:-$(cd "$(dirname "${BASH_SOURCE[0]}")" > /dev/null 2>&1 && pwd)}"

# Load graceful.sh for _jsh_debug if not already loaded
if ! declare -f _jsh_debug &> /dev/null; then
  if [[ -f "${_JSH_SSH_DIR}/graceful.sh" ]]; then
    # shellcheck source=graceful.sh
    source "${_JSH_SSH_DIR}/graceful.sh"
  else
    # Minimal fallback if graceful.sh unavailable
    _jsh_debug() { [[ "${JSH_DEBUG:-}" == "1" ]] && echo "[jsh:debug] $*" >&2; }
  fi
fi

# ============================================================================
# Dependency Check
# ============================================================================

# Check if required dependencies exist on local system
# Returns: 0 if all deps available, 1 with error message if missing
_jsh_ssh_check_deps() {
  local missing=()

  if ! command -v tar &> /dev/null; then
    missing+=("tar")
  fi

  if ! command -v base64 &> /dev/null; then
    missing+=("base64")
  fi

  if [[ ${#missing[@]} -gt 0 ]]; then
    echo "Missing required dependencies: ${missing[*]}" >&2
    return 1
  fi

  _jsh_debug "ssh: all dependencies available"
  return 0
}

# ============================================================================
# Configuration Path
# ============================================================================

# Get path to minimal SSH config file
# Returns: Path to .jshrc.ssh (or empty if not found)
_jsh_ssh_get_minimal_config() {
  local jsh_root="${JSH:-${HOME}/.jsh}"
  local config_path="${jsh_root}/dotfiles/.jshrc.ssh"

  if [[ -f "${config_path}" ]]; then
    echo "${config_path}"
    return 0
  fi

  _jsh_debug "ssh: minimal config not found at ${config_path}"
  return 1
}

# ============================================================================
# Bundle Creation
# ============================================================================

# Maximum payload size (64KB is safe for ARG_MAX on most systems)
_JSH_SSH_MAX_PAYLOAD_SIZE=65536

# Create base64-encoded tarball of minimal SSH config
# Returns: Base64 encoded payload string (stdout)
# Errors: Returns 1 if config missing, 2 if payload too large
_jsh_ssh_bundle() {
  local config_path

  # Check dependencies first
  if ! _jsh_ssh_check_deps; then
    return 1
  fi

  # Get minimal config path
  config_path=$(_jsh_ssh_get_minimal_config)
  if [[ -z "${config_path}" ]]; then
    echo "Error: Minimal SSH config not found. Expected: ${JSH:-${HOME}/.jsh}/dotfiles/.jshrc.ssh" >&2
    return 1
  fi

  _jsh_debug "ssh: bundling config from ${config_path}"

  # Create tarball and encode
  # Use gzip for smaller payload, base64 for safe transmission
  local payload
  payload=$(tar -czf - -C "$(dirname "${config_path}")" "$(basename "${config_path}")" 2> /dev/null | base64)

  if [[ -z "${payload}" ]]; then
    echo "Error: Failed to create bundle" >&2
    return 1
  fi

  # Validate size
  local payload_size=${#payload}
  if [[ ${payload_size} -gt ${_JSH_SSH_MAX_PAYLOAD_SIZE} ]]; then
    echo "Error: Payload size (${payload_size} bytes) exceeds maximum (${_JSH_SSH_MAX_PAYLOAD_SIZE} bytes)" >&2
    return 2
  fi

  _jsh_debug "ssh: bundle created, size=${payload_size} bytes"

  # Output the payload
  echo "${payload}"
  return 0
}

# ============================================================================
# SSH Command Construction
# ============================================================================

# Build SSH command with embedded jsh config payload
# Arguments:
#   $1 - Remote host (required)
#   $@ - Additional SSH arguments (optional)
# Returns: Echoes full SSH command to execute
_jsh_ssh_inject_command() {
  if [[ $# -lt 1 ]]; then
    echo "Usage: _jsh_ssh_inject_command <host> [ssh_args...]" >&2
    return 1
  fi

  local host="$1"
  shift
  local ssh_args=("$@")

  # Generate payload
  local payload
  payload=$(_jsh_ssh_bundle)
  if [[ $? -ne 0 ]]; then
    return 1
  fi

  # Construct remote command
  # This command:
  # 1. Creates temp directory for jsh config
  # 2. Decodes and extracts the payload
  # 3. Sets up cleanup trap on exit
  # 4. Sources the config
  # 5. Starts interactive bash
  local remote_script
  remote_script='
JSHHOME=$(mktemp -d)
export JSHHOME
trap "rm -rf \"$JSHHOME\"" EXIT
echo "$JSH_PAYLOAD" | base64 -d | tar xzf - -C "$JSHHOME"
bash --rcfile "$JSHHOME/.jshrc.ssh"
'

  # Build the SSH command
  # Note: Using single quotes around remote command, double quotes around payload
  local ssh_cmd="ssh"

  # Add any additional SSH arguments
  if [[ ${#ssh_args[@]} -gt 0 ]]; then
    ssh_cmd+=" ${ssh_args[*]}"
  fi

  # Add -t for interactive TTY
  ssh_cmd+=" -t"

  # Add host and remote command
  # The payload is exported as JSH_PAYLOAD, then bash executes our setup script
  ssh_cmd+=" ${host} 'export JSH_PAYLOAD=\"${payload}\"; bash -c '\''${remote_script}'\''"

  _jsh_debug "ssh: built inject command for host=${host}"

  echo "${ssh_cmd}"
  return 0
}

# ============================================================================
# Documentation: Cleanup
# ============================================================================

# Remote cleanup happens automatically via EXIT trap set in _jsh_ssh_inject_command.
# The trap `rm -rf "$JSHHOME"` removes the temporary directory containing:
# - .jshrc.ssh (the extracted config)
# - Any other files that were in the bundle
#
# This ensures no jsh artifacts are left on the remote system after disconnect.
# The trap fires on:
# - Normal shell exit (exit, logout, Ctrl-D)
# - Shell termination via signal (Ctrl-C, etc.)
# - Connection drop (SSH timeout, network failure)
_jsh_ssh_cleanup_remote() {
  echo "Remote cleanup is handled automatically via EXIT trap."
  echo "Temp directory (\$JSHHOME) is removed when the SSH session ends."
}

# src/lib/tui.sh
# TUI Progress Display Library for jsh
#
# Provides cargo-style progress displays with:
# - Scrolling log region (top)
# - Fixed status bar (bottom) with progress bar, count, current item, elapsed time
#
# Environment Variables:
#   JSH_NO_TUI=1     - Disable TUI, use simple line output
#   JSH_FORCE_TUI=1  - Force TUI even in non-interactive mode (testing)
#   JSH_DEBUG_TUI=1  - Debug TUI operations
#
# Usage:
#   source "$root_dir/src/lib/tui.sh"
#   tui_init || true  # OK if fails, uses fallback
#   tui_progress_start "Installing packages" 10
#   for pkg in "${packages[@]}"; do
#     tui_progress_next "$pkg"
#     # ... install ...
#   done
#   tui_progress_complete

# shellcheck disable=SC2034

# =============================================================================
# State Variables
# =============================================================================

_TUI_ENABLED=""         # Whether TUI mode is active
_TUI_SCROLLING_TOP=1    # Top line of scrolling region
_TUI_SCROLLING_BOTTOM=0 # Bottom line of scrolling region
_TUI_STATUS_LINE=0      # Line number for status bar
_TUI_TERM_HEIGHT=0      # Terminal height
_TUI_TERM_WIDTH=0       # Terminal width

# Progress state
_TUI_OPERATION=""    # Current operation name
_TUI_CURRENT=0       # Current item number
_TUI_TOTAL=0         # Total items (0 = indeterminate/spinner)
_TUI_CURRENT_ITEM="" # Name of current item being processed
_TUI_START_TIME=0    # Epoch timestamp when operation started

# Spinner state
_TUI_SPINNER_IDX=0 # Current spinner frame index

# Background animation state
_TUI_ANIM_PID=""  # PID of background animation process
_TUI_ANIM_FIFO="" # FIFO for state communication

# =============================================================================
# Terminal Control Sequences
# =============================================================================

# These are set during tui_init based on terminal capabilities
_TUI_SAVE_CURSOR=""
_TUI_RESTORE_CURSOR=""
_TUI_HIDE_CURSOR=""
_TUI_SHOW_CURSOR=""

# =============================================================================
# Capability Detection
# =============================================================================

# Check if terminal supports TUI features
# Returns: 0 if supported, 1 if not
tui_is_supported() {
  # Already determined?
  if [[ "${_TUI_SUPPORTED:-}" == "1" ]]; then
    return 0
  elif [[ "${_TUI_SUPPORTED:-}" == "0" ]]; then
    return 1
  fi

  # Check for forced disable
  if [[ -n "${JSH_NO_TUI:-}" ]]; then
    _TUI_SUPPORTED=0
    return 1
  fi

  # Must be interactive terminal (unless forced)
  if [[ ! -t 1 ]] && [[ -z "${JSH_FORCE_TUI:-}" ]]; then
    _TUI_SUPPORTED=0
    return 1
  fi

  # Check TERM is set and not dumb
  if [[ -z "${TERM:-}" ]] || [[ "$TERM" == "dumb" ]]; then
    _TUI_SUPPORTED=0
    return 1
  fi

  # Check for tput availability
  if ! command -v tput &> /dev/null; then
    _TUI_SUPPORTED=0
    return 1
  fi

  # Check required tput capabilities
  if ! tput lines &> /dev/null || ! tput cols &> /dev/null; then
    _TUI_SUPPORTED=0
    return 1
  fi

  # Check for scrolling region support (csr capability)
  # Note: Not all terminals support this, fall back to simpler approach if not
  if ! tput csr 0 10 &> /dev/null 2>&1; then
    # Try ANSI escape directly
    if ! printf '\033[1;10r' &> /dev/null 2>&1; then
      _TUI_SUPPORTED=0
      return 1
    fi
    # Reset scrolling region
    printf '\033[r' > /dev/null 2>&1
  else
    # Reset scrolling region
    tput csr 0 "$(tput lines)" > /dev/null 2>&1
  fi

  _TUI_SUPPORTED=1
  return 0
}

# =============================================================================
# Initialization and Cleanup
# =============================================================================

# Initialize TUI mode with scrolling region
# Arguments:
#   $1 - status_lines: Number of lines to reserve for status bar (default: 1)
# Returns: 0 on success, 1 if TUI not supported (falls back to simple mode)
tui_init() {
  local status_lines="${1:-1}"

  # Check if TUI should be enabled
  if ! tui_is_supported; then
    _TUI_ENABLED=""
    [[ -n "${JSH_DEBUG_TUI:-}" ]] && echo "[tui:debug] TUI not supported, using fallback" >&2
    return 1
  fi

  # Set up terminal control sequences
  _TUI_HIDE_CURSOR=$(tput civis 2> /dev/null || printf '\033[?25l')
  _TUI_SHOW_CURSOR=$(tput cnorm 2> /dev/null || printf '\033[?25h')

  # Get terminal dimensions
  local size_output
  if size_output=$(stty size 2> /dev/null) && [[ -n "$size_output" ]]; then
    _TUI_TERM_HEIGHT="${size_output%% *}"
    _TUI_TERM_WIDTH="${size_output##* }"
  else
    _TUI_TERM_HEIGHT=$(tput lines 2> /dev/null || echo 24)
    _TUI_TERM_WIDTH=$(tput cols 2> /dev/null || echo 80)
  fi

  # Ensure we have valid numbers
  [[ "$_TUI_TERM_HEIGHT" =~ ^[0-9]+$ ]] || _TUI_TERM_HEIGHT=24
  [[ "$_TUI_TERM_WIDTH" =~ ^[0-9]+$ ]] || _TUI_TERM_WIDTH=80

  # Hide cursor during TUI operations
  printf '%b' "$_TUI_HIDE_CURSOR"

  # Calculate regions (all 1-indexed for ANSI)
  # We'll use the bottom of the current viewport for the status bar
  # Scrolling region: rows 1 to (height - status_lines)
  # Status bar: last row (height)
  _TUI_SCROLLING_TOP=1
  _TUI_SCROLLING_BOTTOM=$((_TUI_TERM_HEIGHT - status_lines))
  _TUI_STATUS_LINE=$_TUI_TERM_HEIGHT

  # Push existing content up and create space for our TUI
  # Print enough newlines to ensure we have a clean working area
  local i
  for ((i = 0; i < _TUI_TERM_HEIGHT; i++)); do
    printf '\n'
  done

  # Move to top of screen
  printf '\033[H'

  # Set up scrolling region using ANSI DECSTBM (1-indexed)
  # This makes the status bar line fixed while content above scrolls
  printf '\033[%d;%dr' "$_TUI_SCROLLING_TOP" "$_TUI_SCROLLING_BOTTOM"

  # Move cursor to top of scrolling region
  printf '\033[%d;1H' "$_TUI_SCROLLING_TOP"

  # Draw initial empty status bar at the fixed bottom position
  _tui_draw_status_bar

  # Set trap for cleanup
  trap 'tui_cleanup' EXIT INT TERM

  _TUI_ENABLED=1
  [[ -n "${JSH_DEBUG_TUI:-}" ]] && echo "[tui:debug] TUI initialized: ${_TUI_TERM_WIDTH}x${_TUI_TERM_HEIGHT}, scroll region ${_TUI_SCROLLING_TOP}-${_TUI_SCROLLING_BOTTOM}, status at row ${_TUI_STATUS_LINE}" >&2
  return 0
}

# Cleanup TUI mode and restore terminal
tui_cleanup() {
  # Remove trap to prevent recursion
  trap - EXIT INT TERM

  # Stop background animation
  _tui_anim_stop

  if [[ -n "$_TUI_ENABLED" ]]; then
    # Get current cursor row before resetting (this is where content ended)
    # Use escape sequence to query, with fallback
    local cursor_row=""
    if read -rs -t0.1 -d'R' -p $'\033[6n' cursor_pos 2> /dev/null; then
      cursor_row="${cursor_pos#*[}"
      cursor_row="${cursor_row%;*}"
    fi

    # Reset scrolling region to full terminal
    printf '\033[r'

    # Clear the status bar line (move there, clear, move back)
    printf '\033[%d;1H\033[2K' "$_TUI_STATUS_LINE"

    # Return to content position (or stay at bottom-1 if query failed)
    if [[ -n "$cursor_row" && "$cursor_row" =~ ^[0-9]+$ ]]; then
      printf '\033[%d;1H' "$cursor_row"
    else
      printf '\033[%d;1H' "$_TUI_SCROLLING_BOTTOM"
    fi

    # Show cursor
    printf '%b' "$_TUI_SHOW_CURSOR"

    _TUI_ENABLED=""
    [[ -n "${JSH_DEBUG_TUI:-}" ]] && echo "[tui:debug] TUI cleanup complete" >&2
  fi

  # Reset state
  _TUI_OPERATION=""
  _TUI_CURRENT=0
  _TUI_TOTAL=0
  _TUI_CURRENT_ITEM=""
  _TUI_START_TIME=0
}

# =============================================================================
# Progress Bar Rendering
# =============================================================================

# Draw a progress bar
# Arguments:
#   $1 - current: Current value
#   $2 - total: Total value
#   $3 - width: Bar width in characters (default: 20)
# Output: Progress bar string like "â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘"
_tui_progress_bar() {
  local current=$1
  local total=$2
  local width=${3:-20}

  if [[ $total -eq 0 ]]; then
    # Empty bar for indeterminate
    printf '%*s' "$width" "" | tr ' ' 'â–‘'
    return
  fi

  # Clamp current to valid range before calculation
  [[ $current -lt 0 ]] && current=0
  [[ $current -gt $total ]] && current=$total

  local filled=$((current * width / total))
  local empty=$((width - filled))

  # Clamp values (safety check)
  [[ $filled -gt $width ]] && filled=$width
  [[ $filled -lt 0 ]] && filled=0
  [[ $empty -lt 0 ]] && empty=0

  local bar=""
  if [[ $filled -gt 0 ]]; then
    bar+=$(printf '%*s' "$filled" "" | tr ' ' 'â–ˆ')
  fi
  if [[ $empty -gt 0 ]]; then
    bar+=$(printf '%*s' "$empty" "" | tr ' ' 'â–‘')
  fi

  printf '%s' "$bar"
}

# Get spinner character for current frame
_tui_spinner_char() {
  local spinner_chars='â ‹â ™â ¹â ¸â ¼â ´â ¦â §â ‡â '
  local len=${#spinner_chars}
  local idx=$((_TUI_SPINNER_IDX % len))
  printf '%s' "${spinner_chars:$idx:1}"
}

# Advance spinner to next frame
_tui_spinner_advance() {
  _TUI_SPINNER_IDX=$((_TUI_SPINNER_IDX + 1))
}

# =============================================================================
# Background Animation
# =============================================================================

# Start background animation loop
# This runs a subprocess that periodically redraws the status bar
# to keep the spinner animated and timer updated
_tui_anim_start() {
  [[ -z "$_TUI_ENABLED" ]] && return 0
  [[ -n "$_TUI_ANIM_PID" ]] && return 0 # Already running

  # Create state file for communication (faster than FIFO for reads)
  _TUI_ANIM_FIFO="${TMPDIR:-/tmp}/tui_state_$$"

  # Write initial state
  _tui_anim_write_state

  # Start background animation loop
  (
    local spinner_chars='â ‹â ™â ¹â ¸â ¼â ´â ¦â §â ‡â '
    local spinner_len=${#spinner_chars}
    local idx=0
    local interval=0.1 # 100ms refresh rate

    while true; do
      # Check if state file still exists (signals shutdown)
      [[ ! -f "$_TUI_ANIM_FIFO" ]] && break

      # Read current state
      local operation="" total=0 current=0 item="" start_time=0 term_width=80 status_line=1 scroll_bottom=1
      if [[ -f "$_TUI_ANIM_FIFO" ]]; then
        # shellcheck disable=SC1090
        source "$_TUI_ANIM_FIFO" 2> /dev/null || true
      fi

      # Skip if no operation
      [[ -z "$operation" ]] && {
        sleep "$interval"
        continue
      }

      # Build status line
      local spinner="${spinner_chars:$((idx % spinner_len)):1}"
      idx=$((idx + 1))

      local status=""
      local elapsed="" eta=""

      # Calculate times
      if [[ "$start_time" -gt 0 ]]; then
        local now elapsed_secs
        now=$(date +%s)
        elapsed_secs=$((now - start_time))

        # Format elapsed time
        if [[ $elapsed_secs -ge 60 ]]; then
          elapsed="$((elapsed_secs / 60))m$((elapsed_secs % 60))s"
        else
          elapsed="${elapsed_secs}s"
        fi

        # Calculate ETA if we have progress
        if [[ "$total" -gt 0 ]] && [[ "$current" -gt 0 ]]; then
          local avg_per_item=$((elapsed_secs * 100 / current)) # centiseconds
          local remaining_items=$((total - current))
          local eta_secs=$((remaining_items * avg_per_item / 100))
          if [[ $eta_secs -ge 60 ]]; then
            eta="~$((eta_secs / 60))m$((eta_secs % 60))s remaining"
          elif [[ $eta_secs -gt 0 ]]; then
            eta="~${eta_secs}s remaining"
          fi
        fi
      fi

      # Build the status string with ANSI codes
      # Operation name (cyan)
      status="\033[36m${operation}\033[0m "

      # Progress bar or spinner
      if [[ "$total" -gt 0 ]]; then
        # Determinate progress bar
        local bar_width=20
        local filled=$((current * bar_width / total))
        [[ $filled -gt $bar_width ]] && filled=$bar_width
        [[ $filled -lt 0 ]] && filled=0
        local empty=$((bar_width - filled))

        local bar=""
        [[ $filled -gt 0 ]] && bar+=$(printf '%*s' "$filled" "" | tr ' ' 'â–ˆ')
        [[ $empty -gt 0 ]] && bar+=$(printf '%*s' "$empty" "" | tr ' ' 'â–‘')
        status+="[${bar}] ${current}/${total}"
      else
        # Indeterminate spinner
        status+="[$spinner] "
      fi

      # Current item (bold)
      if [[ -n "$item" ]]; then
        status+=" \033[1m${item}\033[0m"
      fi

      # Time display (yellow) - show ETA if available, otherwise elapsed
      if [[ -n "$eta" ]]; then
        status+=" \033[33m(${eta})\033[0m"
      elif [[ -n "$elapsed" ]]; then
        status+=" \033[33m(${elapsed})\033[0m"
      fi

      # Draw status bar - position cursor to scroll_bottom after to avoid race with main process
      printf '\033[%d;1H' "$status_line"   # Move to status line
      printf '\033[2K'                     # Clear line
      printf '%b' "$status"                # Print status
      printf '\033[%d;1H' "$scroll_bottom" # Return to scroll region bottom

      sleep "$interval"
    done
  ) &
  _TUI_ANIM_PID=$!

  [[ -n "${JSH_DEBUG_TUI:-}" ]] && echo "[tui:debug] Animation started with PID $_TUI_ANIM_PID" >&2
}

# Write current state to file for animation process
_tui_anim_write_state() {
  [[ -z "$_TUI_ANIM_FIFO" ]] && return 0

  cat > "$_TUI_ANIM_FIFO" << EOF
operation="$_TUI_OPERATION"
total=$_TUI_TOTAL
current=$_TUI_CURRENT
item="$_TUI_CURRENT_ITEM"
start_time=$_TUI_START_TIME
term_width=$_TUI_TERM_WIDTH
status_line=$_TUI_STATUS_LINE
scroll_bottom=$_TUI_SCROLLING_BOTTOM
EOF
}

# Stop background animation
_tui_anim_stop() {
  if [[ -n "$_TUI_ANIM_PID" ]]; then
    # Remove state file first (signals the loop to exit)
    [[ -n "$_TUI_ANIM_FIFO" ]] && rm -f "$_TUI_ANIM_FIFO"

    # Kill the process if still running
    kill "$_TUI_ANIM_PID" 2> /dev/null || true
    wait "$_TUI_ANIM_PID" 2> /dev/null || true

    [[ -n "${JSH_DEBUG_TUI:-}" ]] && echo "[tui:debug] Animation stopped" >&2
    _TUI_ANIM_PID=""
    _TUI_ANIM_FIFO=""
  fi
}

# =============================================================================
# Status Bar Rendering
# =============================================================================

# Draw the status bar at the fixed bottom position
_tui_draw_status_bar() {
  if [[ -z "$_TUI_ENABLED" ]]; then
    return 0
  fi

  # Save cursor position (ESC 7 = DECSC)
  printf '\0337'

  # Move to status line (1-indexed)
  printf '\033[%d;1H' "$_TUI_STATUS_LINE"

  # Clear the line
  printf '\033[2K'

  # Build status content if we have an active operation
  if [[ -n "$_TUI_OPERATION" ]]; then
    local status=""
    local bar_width=20
    local elapsed=""

    # Calculate elapsed time
    if [[ "$_TUI_START_TIME" -gt 0 ]]; then
      local now elapsed_secs
      now=$(date +%s)
      elapsed_secs=$((now - _TUI_START_TIME))
      if [[ $elapsed_secs -ge 60 ]]; then
        elapsed="$((elapsed_secs / 60))m$((elapsed_secs % 60))s"
      else
        elapsed="${elapsed_secs}s"
      fi
    fi

    # Operation name (cyan)
    status="${CYAN}${_TUI_OPERATION}${RESET} "

    # Progress bar or spinner
    if [[ "$_TUI_TOTAL" -gt 0 ]]; then
      # Determinate progress bar
      local bar
      bar=$(_tui_progress_bar "$_TUI_CURRENT" "$_TUI_TOTAL" "$bar_width")
      status+="[${bar}] "
      status+="${_TUI_CURRENT}/${_TUI_TOTAL}"
    else
      # Indeterminate spinner
      _tui_spinner_advance
      local spinner
      spinner=$(_tui_spinner_char)
      status+="[$spinner] "
    fi

    # Current item (bold)
    if [[ -n "$_TUI_CURRENT_ITEM" ]]; then
      status+=" ${BOLD}${_TUI_CURRENT_ITEM}${RESET}"
    fi

    # Elapsed time (yellow)
    if [[ -n "$elapsed" ]]; then
      status+=" ${YELLOW}(${elapsed})${RESET}"
    fi

    # Print the status
    printf '%b' "$status"
  fi

  # Restore cursor position (using ESC 8 which is more reliable)
  printf '\0338'
}

# Clear the status bar area (alias for backward compatibility)
_tui_clear_status_area() {
  if [[ -z "$_TUI_ENABLED" ]]; then
    return 0
  fi

  printf '\0337'                          # Save cursor (ESC 7)
  printf '\033[%d;1H' "$_TUI_STATUS_LINE" # Move to status line
  printf '\033[2K'                        # Clear line
  printf '\0338'                          # Restore cursor (ESC 8)
}

# Render the status bar (alias for _tui_draw_status_bar)
_tui_render_status() {
  _tui_draw_status_bar
}

# =============================================================================
# Single-Process Animated Command Runner
# =============================================================================

# Run a command with animated progress (single-process, no race conditions)
# Arguments:
#   $1 - command to run (will be eval'd)
# Output lines are displayed in scroll region, status bar animates
# Returns: exit code of the command
tui_run_animated() {
  local cmd="$1"
  local output_file="${TMPDIR:-/tmp}/tui_output_$$"
  local pid_file="${TMPDIR:-/tmp}/tui_pid_$$"
  local interval=0.1
  local spinner_chars='â ‹â ™â ¹â ¸â ¼â ´â ¦â §â ‡â '
  local spinner_len=${#spinner_chars}
  local lines_read=0

  # Fallback if TUI not enabled
  if [[ -z "$_TUI_ENABLED" ]]; then
    eval "$cmd"
    return $?
  fi

  # Start command in background, capture output
  : > "$output_file"
  (
    eval "$cmd" > "$output_file" 2>&1
    echo $? > "$pid_file"
  ) &

  # Poll for output while command runs
  while true; do
    # Check if command finished
    if [[ -f "$pid_file" ]]; then
      # Process any remaining output
      local line
      tail -n +$((lines_read + 1)) "$output_file" 2> /dev/null | while IFS= read -r line; do
        [[ -n "$line" ]] && echo -e "${BLUE}[*]${RESET} $line"
      done
      break
    fi

    # Read new lines from output file
    local new_lines
    new_lines=$(tail -n +$((lines_read + 1)) "$output_file" 2> /dev/null)
    if [[ -n "$new_lines" ]]; then
      local line
      while IFS= read -r line; do
        [[ -n "$line" ]] && echo -e "${BLUE}[*]${RESET} $line"
        ((lines_read++))
      done <<< "$new_lines"
    fi

    # Update spinner and redraw status bar
    _tui_spinner_advance
    _tui_draw_status_bar

    sleep "$interval"
  done

  # Get exit code
  local exit_code=0
  [[ -f "$pid_file" ]] && exit_code=$(cat "$pid_file")

  # Cleanup
  rm -f "$output_file" "$pid_file"

  # Final status bar update
  _tui_draw_status_bar

  return "${exit_code:-0}"
}

# =============================================================================
# Progress Management
# =============================================================================

# Start a new progress operation
# Arguments:
#   $1 - operation: Name of the operation (e.g., "Installing packages")
#   $2 - total: Total number of items (0 for indeterminate)
tui_progress_start() {
  local operation="$1"
  local total="${2:-0}"

  _TUI_OPERATION="$operation"
  _TUI_TOTAL="$total"
  _TUI_CURRENT=0
  _TUI_CURRENT_ITEM=""
  _TUI_START_TIME=$(date +%s)
  _TUI_SPINNER_IDX=0

  if [[ -z "$_TUI_ENABLED" ]]; then
    # Fallback: use header
    header "$operation"
    return 0
  fi

  # Background animation disabled - causes issues with log output display
  # _tui_anim_start

  _tui_render_status
}

# Update progress to next item
# Arguments:
#   $1 - item_name: Name of current item
tui_progress_next() {
  local item="${1:-}"

  _TUI_CURRENT=$((_TUI_CURRENT + 1))
  _TUI_CURRENT_ITEM="$item"

  if [[ -z "$_TUI_ENABLED" ]]; then
    # Fallback: log with count
    if [[ "$_TUI_TOTAL" -gt 0 ]]; then
      log "[$_TUI_CURRENT/$_TUI_TOTAL] $item"
    else
      log "$item"
    fi
    return 0
  fi

  # Update state for background animation
  _tui_anim_write_state

  _tui_render_status
}

# Update progress with specific count
# Arguments:
#   $1 - current: Current item number
#   $2 - item_name: Name of current item (optional)
tui_progress_update() {
  local current="$1"
  local item="${2:-}"

  _TUI_CURRENT="$current"
  [[ -n "$item" ]] && _TUI_CURRENT_ITEM="$item"

  if [[ -z "$_TUI_ENABLED" ]]; then
    # Fallback: log with count
    if [[ "$_TUI_TOTAL" -gt 0 ]]; then
      log "[$_TUI_CURRENT/$_TUI_TOTAL] ${item:-processing...}"
    else
      log "${item:-processing...}"
    fi
    return 0
  fi

  # Update state for background animation
  _tui_anim_write_state

  _tui_render_status
}

# Mark progress as complete
# Arguments:
#   $1 - message: Completion message (optional)
tui_progress_complete() {
  local message="${1:-}"

  # Stop background animation first
  _tui_anim_stop

  if [[ -z "$_TUI_ENABLED" ]]; then
    # Fallback: success message
    if [[ -n "$message" ]]; then
      success "$message"
    elif [[ -n "$_TUI_OPERATION" ]]; then
      success "${_TUI_OPERATION} complete"
    fi
  else
    # Clear status and show completion in scroll area
    _tui_clear_status_area
    if [[ -n "$message" ]]; then
      tui_success "$message"
    elif [[ -n "$_TUI_OPERATION" ]]; then
      tui_success "${_TUI_OPERATION} complete"
    fi
  fi

  # Reset progress state
  _TUI_OPERATION=""
  _TUI_CURRENT=0
  _TUI_TOTAL=0
  _TUI_CURRENT_ITEM=""
  _TUI_START_TIME=0
}

# Mark progress as failed
# Arguments:
#   $1 - message: Error message (optional)
tui_progress_fail() {
  local message="${1:-}"

  # Stop background animation first
  _tui_anim_stop

  if [[ -z "$_TUI_ENABLED" ]]; then
    # Fallback: error message (but don't exit)
    if [[ -n "$message" ]]; then
      warn "$message"
    elif [[ -n "$_TUI_OPERATION" ]]; then
      warn "${_TUI_OPERATION} failed"
    fi
  else
    # Clear status and show failure in scroll area
    _tui_clear_status_area
    if [[ -n "$message" ]]; then
      tui_warn "$message"
    elif [[ -n "$_TUI_OPERATION" ]]; then
      tui_warn "${_TUI_OPERATION} failed"
    fi
  fi

  # Reset progress state
  _TUI_OPERATION=""
  _TUI_CURRENT=0
  _TUI_TOTAL=0
  _TUI_CURRENT_ITEM=""
  _TUI_START_TIME=0
}

# =============================================================================
# Output Functions (scroll-aware)
# =============================================================================

# Log message to scrolling region
tui_log() {
  if [[ -z "$_TUI_ENABLED" ]]; then
    log "$@"
    return
  fi

  # Print message (will scroll within region)
  echo -e "${BLUE}[*]${RESET} $*"

  # Refresh status bar
  _tui_render_status
}

# Success message to scrolling region
tui_success() {
  if [[ -z "$_TUI_ENABLED" ]]; then
    success "$@"
    return
  fi

  echo -e "${GREEN}[âœ“]${RESET} $*"
  _tui_render_status
}

# Warning message to scrolling region
tui_warn() {
  if [[ -z "$_TUI_ENABLED" ]]; then
    warn "$@"
    return
  fi

  echo -e "${YELLOW}[!]${RESET} $*"
  _tui_render_status
}

# Error message to scrolling region (does NOT exit)
tui_error() {
  if [[ -z "$_TUI_ENABLED" ]]; then
    # Note: Using warn instead of error to avoid exit
    echo -e "${RED}[âœ—] $*${RESET}"
    return
  fi

  echo -e "${RED}[âœ—]${RESET} $*"
  _tui_render_status
}

# Info message to scrolling region
tui_info() {
  if [[ -z "$_TUI_ENABLED" ]]; then
    info "$@"
    return
  fi

  echo -e "${CYAN}[i]${RESET} $*"
  _tui_render_status
}

# :command.command_functions
# :command.function
jsh_init_command() {
  # src/init_command.sh
  root_dir="$(get_root_dir)"

  # Parse flags
  install_packages=true
  skip_brew=false
  dry_run=false
  interactive=true
  target_shell=""
  setup_type=""
  run_setup=false

  [[ "${args[--non - interactive]}" ]] && interactive=false
  [[ "${args[--shell]}" ]] && target_shell="${args[--shell]}"
  [[ "${args[--minimal]}" ]] && setup_type="minimal"
  [[ "${args[--full]}" ]] && setup_type="full"
  [[ "${args[--setup]}" ]] && run_setup=true
  [[ "${args[--no - install]}" ]] && install_packages=false
  [[ "${args[--skip - brew]}" ]] && skip_brew=true
  [[ "${args[--dry - run]}" ]] && dry_run=true

  header "Initializing jsh environment"

  # Interactive prompts
  if [[ "$interactive" == "true" ]]; then
    echo ""
    info "Welcome to jsh! Let's configure your shell environment."
    echo ""

    # Shell selection
    if [[ -z "$target_shell" ]]; then
      echo -e "${BOLD}Shell Selection:${RESET}"
      echo "  1) zsh   (recommended)"
      echo "  2) bash  (traditional)"
      echo "  3) skip  (keep current: $(basename "$SHELL"))"
      echo ""
      read -r -p "Choose your shell (1-3) [1]: " shell_choice
      echo ""

      case "$shell_choice" in
        1 | "") target_shell="zsh" ;;
        2) target_shell="bash" ;;
        3) target_shell="skip" ;;
        *) target_shell="zsh" ;;
      esac
    fi

    # Setup type selection
    if [[ -z "$setup_type" ]]; then
      echo -e "${BOLD}Setup Type:${RESET}"
      echo "  1) Minimal  - Core tools only"
      echo "  2) Full     - Themes, plugins, completions"
      echo ""
      read -r -p "Choose setup type (1-2) [2]: " setup_choice
      echo ""

      case "$setup_choice" in
        1) setup_type="minimal" ;;
        2 | "") setup_type="full" ;;
        *) setup_type="full" ;;
      esac
    fi

    # Package installation confirmation
    if [[ "$install_packages" == "true" ]]; then
      echo -e "${BOLD}Package Installation:${RESET}"
      info "This will install Homebrew and essential tools."
      echo ""

      if ! confirm "Proceed with package installation?"; then
        install_packages=false
        skip_brew=true
      fi
    fi
  else
    # Non-interactive defaults
    [[ -z "$target_shell" ]] && target_shell="zsh"
    [[ -z "$setup_type" ]] && setup_type="full"
  fi

  if [[ "$setup_type" == "minimal" ]]; then
    export ZSH_MINIMAL=1
    info "Minimal setup selected"
    echo ""
  fi

  header "Starting initialization"

  # 1. Git Submodules
  if [[ -f "$root_dir/.gitmodules" ]]; then
    log "Initializing git submodules..."
    if [[ "$dry_run" == "false" ]]; then
      # Check if .git directory is writable (handles read-only mounts)
      if [[ -d "$root_dir/.git" ]] && [[ ! -w "$root_dir/.git" ]]; then
        warn "Git directory is read-only, skipping submodule initialization"
      elif ! git -C "$root_dir" submodule update --init --recursive 2> /dev/null; then
        warn "Could not initialize submodules (read-only filesystem?)"
      fi
    fi
  fi

  # 2. Install fzf
  if [[ -f "$root_dir/.fzf/install" && ! -f "$root_dir/.fzf/bin/fzf" ]]; then
    log "Installing fzf..."
    if [[ "$dry_run" == "false" ]]; then
      "$root_dir/.fzf/install" --bin
      export PATH="$root_dir/.fzf/bin:$PATH"
    fi
  fi

  # 3. Homebrew
  if [[ "$install_packages" == "true" && "$skip_brew" == "false" ]]; then
    if [[ "$dry_run" == "false" ]]; then
      non_interactive_flag="false"
      [[ "$interactive" == "false" ]] && non_interactive_flag="true"
      if ! ensure_brew "$non_interactive_flag"; then
        warn "Continuing without Homebrew..."
      fi
    fi
  fi

  # 4. Basic Tools
  if [[ "$install_packages" == "true" ]]; then
    log "Installing basic tools..."
    basic_tools=(curl jq make python timeout vim)
    if command -v brew &> /dev/null; then
      for tool in "${basic_tools[@]}"; do
        if ! command -v "$tool" &> /dev/null; then
          log "Installing $tool..."
          pkg="$tool"
          [[ "$tool" == "timeout" ]] && pkg="coreutils"
          if [[ "$dry_run" == "false" ]]; then
            brew install "$pkg" || warn "Failed to install $tool"
          fi
        fi
      done
    fi
  fi

  # 5. Shell Setup
  if [[ "$install_packages" == "true" && "$target_shell" != "skip" ]]; then
    log "Configuring shell: $target_shell"

    if ! command -v "$target_shell" &> /dev/null; then
      log "$target_shell not found, installing..."
      if [[ "$dry_run" == "false" ]]; then
        install_package "$target_shell" || true
      fi
    fi

    if command -v "$target_shell" &> /dev/null; then
      current_shell=$(get_user_shell)

      if [[ "$current_shell" != *"$target_shell"* ]]; then
        shell_path=$(command -v "$target_shell")

        if ! grep -q "^$shell_path$" /etc/shells 2> /dev/null; then
          log "Adding $shell_path to /etc/shells..."
          if [[ "$dry_run" == "false" ]]; then
            echo "$shell_path" | sudo tee -a /etc/shells > /dev/null
          fi
        fi

        log "Changing default shell to $target_shell..."
        if [[ "$dry_run" == "false" ]]; then
          chsh -s "$shell_path" || warn "Failed to change shell"
        fi
      else
        info "Shell is already $target_shell"
      fi
    fi
  fi

  # 6. Link dotfiles
  if [[ "$dry_run" == "false" ]]; then
    if [[ "$interactive" == "false" ]]; then
      "$0" dotfiles -y
    else
      "$0" dotfiles
    fi
  fi

  # 7. Zinit installation
  if [[ "$install_packages" == "true" && "$dry_run" == "false" && "$target_shell" == "zsh" ]]; then
    zinit_home="${XDG_DATA_HOME:-${HOME}/.local/share}/zinit/zinit.git"

    if [[ "$setup_type" == "full" && ! -d "${zinit_home}" ]]; then
      if [[ "$interactive" == "true" ]]; then
        echo ""
        info "Zinit enables themes, syntax highlighting, and auto-suggestions."
        echo ""

        if confirm "Install zinit and plugins?"; then
          log "Installing zinit..."
          mkdir -p "${zinit_home%/*}"
          git_clone_https "https://github.com/zdharma-continuum/zinit.git" "${zinit_home}" || warn "Failed to install zinit"
        fi
      else
        log "Installing zinit..."
        mkdir -p "${zinit_home%/*}"
        git_clone_https "https://github.com/zdharma-continuum/zinit.git" "${zinit_home}" || warn "Failed to install zinit"
      fi
    fi
  fi

  # 8. TPM (Tmux Plugin Manager) installation
  if [[ "$install_packages" == "true" && "$dry_run" == "false" ]]; then
    tpm_home="${HOME}/.tmux/plugins/tpm"

    if [[ "$setup_type" == "full" && ! -d "${tpm_home}" ]]; then
      if [[ "$interactive" == "true" ]]; then
        echo ""
        info "TPM enables tmux plugins for session restore, vim navigation, etc."
        echo ""

        if confirm "Install tmux plugin manager?"; then
          log "Installing TPM..."
          mkdir -p "${tpm_home%/*}"
          git_clone_https "https://github.com/tmux-plugins/tpm.git" "${tpm_home}" || warn "Failed to install TPM"
          info "Run prefix + I in tmux to install plugins"
        fi
      else
        log "Installing TPM..."
        mkdir -p "${tpm_home%/*}"
        git_clone_https "https://github.com/tmux-plugins/tpm.git" "${tpm_home}" || warn "Failed to install TPM"
      fi
    fi
  fi

  # 9. Run setup if requested
  if [[ "$run_setup" == "true" && "$dry_run" == "false" ]]; then
    header "Running full setup"
    "$0" install
    "$0" configure
  fi

  success "Initialization complete!"

  echo ""
  info "Summary:"
  info "  Shell:      $target_shell"
  info "  Setup type: $setup_type"
  info "  Packages:   $(if [[ "$install_packages" == "true" ]]; then echo "installed"; else echo "skipped"; fi)"
  info "  Full setup: $(if [[ "$run_setup" == "true" ]]; then echo "yes"; else echo "no"; fi)"
  echo ""

  if [[ "$dry_run" == "false" && "$target_shell" != "skip" ]]; then
    if [[ "$interactive" == "false" ]]; then
      log "Starting $target_shell session..."
      exec "$target_shell"
    else
      info "To activate your new shell, run: exec $target_shell"
      echo ""
      if confirm "Start new $target_shell session now?"; then
        exec "$target_shell"
      fi
    fi
  fi

}

# :command.function
jsh_install_command() {
  # src/install_command.sh
  # jsh install - Package installation command
  #
  # Usage:
  #   jsh install                  - Install all packages from config files
  #   jsh install <package>        - Install a single package (auto-detect package manager)
  #   jsh install <package> --brew - Install via specific package manager
  #
  # Behavior:
  #   - Single package: Uses Homebrew/Linuxbrew by default, or specified package manager
  #   - Bulk install: Uses config JSONs (system package managers + brew formulae)
  #   - Root delegation: When running as root, delegates brew commands to BREW_USER
  #
  # Environment Variables:
  #   - BREW_USER: User to run Homebrew as when executing as root (loaded from .env)

  root_dir="$(get_root_dir)"
  package="${args[package]:-}"

  # Source TUI library if available
  # shellcheck source=src/lib/tui.sh
  [[ -f "$root_dir/src/lib/tui.sh" ]] && source "$root_dir/src/lib/tui.sh"

  # Check flags (bashly populates ${args[--flag]})
  use_tui=true
  if [[ -n "${args[--no - progress]:-}" ]] || [[ -n "${args[--quiet]:-}" ]]; then
    use_tui=false
  fi

  # Initialize TUI if available and enabled
  if [[ "$use_tui" == "true" ]] && declare -f tui_init &> /dev/null; then
    tui_init || use_tui=false
  fi

  # Helper function for TUI-aware logging
  _install_log() {
    if [[ "$use_tui" == "true" ]] && declare -f tui_log &> /dev/null; then
      tui_log "$@"
    else
      log "$@"
    fi
  }

  _install_success() {
    if [[ "$use_tui" == "true" ]] && declare -f tui_success &> /dev/null; then
      tui_success "$@"
    else
      success "$@"
    fi
  }

  # Determine which package manager to use based on flags
  detect_package_manager() {
    [[ "${args[--brew]}" ]] && echo "brew" && return
    [[ "${args[--gem]}" ]] && echo "gem" && return
    [[ "${args[--bun]}" ]] && echo "bun" && return
    [[ "${args[--npm]}" ]] && echo "npm" && return
    [[ "${args[--pip]}" ]] && echo "pip" && return
    [[ "${args[--cargo]}" ]] && echo "cargo" && return
    [[ "${args[--apt]}" ]] && echo "apt" && return
    [[ "${args[--dnf]}" ]] && echo "dnf" && return
    [[ "${args[--pacman]}" ]] && echo "pacman" && return
    [[ "${args[--yum]}" ]] && echo "yum" && return
    [[ "${args[--zypper]}" ]] && echo "zypper" && return
    echo "auto"
  }

  # Install a package via specified package manager
  install_via_package_manager() {
    local pkg="$1"
    local pm="$2"

    case "$pm" in
      brew)
        if is_macos; then
          # Try cask first, then formula
          if brew_cmd install --cask "$pkg" 2> /dev/null; then
            success "Installed cask: $pkg"
            add_package_to_json "$root_dir/configs/macos/casks.json" "$pkg"
            return 0
          elif brew_cmd install "$pkg" 2> /dev/null; then
            success "Installed formula: $pkg"
            add_package_to_json "$root_dir/configs/macos/formulae.json" "$pkg"
            return 0
          fi
        else
          if brew_cmd install "$pkg" 2> /dev/null; then
            success "Installed via brew: $pkg"
            add_package_to_json "$root_dir/configs/linux/formulae.json" "$pkg"
            return 0
          fi
        fi
        return 1
        ;;
      gem)
        if command -v gem &> /dev/null; then
          gem install "$pkg" && success "Installed gem: $pkg" && return 0
        else
          error "gem not found. Install Ruby first."
        fi
        return 1
        ;;
      bun)
        if command -v bun &> /dev/null; then
          if bun install -g "$pkg"; then
            success "Installed bun package: $pkg"
            add_package_to_json "$root_dir/configs/npm.json" "$pkg"
            return 0
          fi
        else
          error "bun not found. Install from https://bun.sh"
        fi
        return 1
        ;;
      npm)
        if command -v npm &> /dev/null; then
          if npm install -g "$pkg"; then
            success "Installed npm package: $pkg"
            add_package_to_json "$root_dir/configs/npm.json" "$pkg"
            return 0
          fi
        else
          error "npm not found. Install Node.js first."
        fi
        return 1
        ;;
      pip)
        if command -v pip3 &> /dev/null; then
          pip3 install --user "$pkg" && success "Installed pip package: $pkg" && return 0
        elif command -v pip &> /dev/null; then
          pip install --user "$pkg" && success "Installed pip package: $pkg" && return 0
        else
          error "pip not found. Install Python first."
        fi
        return 1
        ;;
      cargo)
        if command -v cargo &> /dev/null; then
          cargo install "$pkg" && success "Installed cargo package: $pkg" && return 0
        else
          error "cargo not found. Install Rust first."
        fi
        return 1
        ;;
      apt)
        if command -v apt-get &> /dev/null; then
          sudo apt-get install -y "$pkg" && success "Installed apt package: $pkg" && return 0
        else
          error "apt-get not found."
        fi
        return 1
        ;;
      dnf)
        if command -v dnf &> /dev/null; then
          sudo dnf install -y "$pkg" && success "Installed dnf package: $pkg" && return 0
        else
          error "dnf not found."
        fi
        return 1
        ;;
      pacman)
        if command -v pacman &> /dev/null; then
          sudo pacman -S --noconfirm "$pkg" && success "Installed pacman package: $pkg" && return 0
        else
          error "pacman not found."
        fi
        return 1
        ;;
      yum)
        if command -v yum &> /dev/null; then
          sudo yum install -y "$pkg" && success "Installed yum package: $pkg" && return 0
        else
          error "yum not found."
        fi
        return 1
        ;;
      zypper)
        if command -v zypper &> /dev/null; then
          sudo zypper install -y "$pkg" && success "Installed zypper package: $pkg" && return 0
        else
          error "zypper not found."
        fi
        return 1
        ;;
      *)
        error "Unknown package manager: $pm"
        return 1
        ;;
    esac
  }

  if [[ -z "$package" ]]; then
    # Install all packages from config (brew + system packages)
    header "Installing packages"

    if is_linux; then
      # Install Linux system packages from config
      # Note: These are managed via system package managers (apt, dnf, pacman)
      _install_log "Updating package cache..."
      update_package_cache

      # Determine package manager
      packages=()
      if command -v apt-get &> /dev/null; then
        while IFS= read -r line; do
          [[ -n "$line" ]] && packages+=("$line")
        done < <(load_packages_from_json "$root_dir/configs/linux/apt.json")
      elif command -v dnf &> /dev/null; then
        while IFS= read -r line; do
          [[ -n "$line" ]] && packages+=("$line")
        done < <(load_packages_from_json "$root_dir/configs/linux/dnf.json")
      elif command -v pacman &> /dev/null; then
        while IFS= read -r line; do
          [[ -n "$line" ]] && packages+=("$line")
        done < <(load_packages_from_json "$root_dir/configs/linux/pacman.json")
      fi

      if [[ ${#packages[@]} -gt 0 ]]; then
        if [[ "$use_tui" == "true" ]] && declare -f tui_progress_start &> /dev/null; then
          tui_progress_start "Installing system packages" "${#packages[@]}"
          local i=0
          for pkg in "${packages[@]}"; do
            ((i++))
            tui_progress_next "$pkg"
            install_package "$pkg" || warn "Failed to install $pkg"
          done
          tui_progress_complete "System packages installed"
        else
          for pkg in "${packages[@]}"; do
            install_package "$pkg" || warn "Failed to install $pkg"
          done
        fi
      fi
    fi

    if is_macos && check_brew; then
      # Install casks
      casks=()
      while IFS= read -r line; do
        [[ -n "$line" ]] && casks+=("$line")
      done < <(load_packages_from_json "$root_dir/configs/macos/casks.json")

      if [[ ${#casks[@]} -gt 0 ]]; then
        if [[ "$use_tui" == "true" ]] && declare -f tui_progress_start &> /dev/null; then
          tui_progress_start "Installing casks" "${#casks[@]}"
          local i=0
          for cask in "${casks[@]}"; do
            ((i++))
            tui_progress_next "$cask"
            brew install --force --cask "$cask" || warn "Failed to install cask: $cask"
          done
          tui_progress_complete "Casks installed"
        else
          _install_log "Installing Casks..."
          for cask in "${casks[@]}"; do
            brew install --force --cask "$cask" || warn "Failed to install cask: $cask"
          done
        fi
      fi
    fi

    if check_brew; then
      # Install formulae
      formulae=()
      if is_macos; then
        while IFS= read -r line; do
          [[ -n "$line" ]] && formulae+=("$line")
        done < <(load_packages_from_json "$root_dir/configs/macos/formulae.json")
      else
        while IFS= read -r line; do
          [[ -n "$line" ]] && formulae+=("$line")
        done < <(load_packages_from_json "$root_dir/configs/linux/formulae.json")
      fi

      if [[ ${#formulae[@]} -gt 0 ]]; then
        if [[ "$use_tui" == "true" ]] && declare -f tui_progress_start &> /dev/null; then
          tui_progress_start "Installing formulae" "${#formulae[@]}"
          local i=0
          for formula in "${formulae[@]}"; do
            ((i++))
            tui_progress_next "$formula"
            brew install --force "$formula" || warn "Failed to install formula: $formula"
          done
          tui_progress_complete "Formulae installed"
        else
          _install_log "Installing Formulae..."
          for formula in "${formulae[@]}"; do
            brew install --force "$formula" || warn "Failed to install formula: $formula"
          done
        fi
      fi

      # Start services
      services=()
      if is_macos; then
        while IFS= read -r line; do
          [[ -n "$line" ]] && services+=("$line")
        done < <(load_packages_from_json "$root_dir/configs/macos/services.json")
      else
        while IFS= read -r line; do
          [[ -n "$line" ]] && services+=("$line")
        done < <(load_packages_from_json "$root_dir/configs/linux/services.json")
      fi

      if [[ ${#services[@]} -gt 0 ]]; then
        if [[ "$use_tui" == "true" ]] && declare -f tui_progress_start &> /dev/null; then
          tui_progress_start "Starting services" "${#services[@]}"
          local i=0
          for svc in "${services[@]}"; do
            ((i++))
            tui_progress_next "$svc"
            brew services start "$svc" || warn "Failed to start service: $svc"
          done
          tui_progress_complete "Services started"
        else
          _install_log "Starting Services..."
          for svc in "${services[@]}"; do
            brew services start "$svc" || warn "Failed to start service: $svc"
          done
        fi
      fi
    fi

    # Install npm/bun packages from config
    npm_packages=()
    if [[ -f "$root_dir/configs/npm.json" ]]; then
      while IFS= read -r line; do
        [[ -n "$line" ]] && npm_packages+=("$line")
      done < <(load_packages_from_json "$root_dir/configs/npm.json")
    fi

    if [[ ${#npm_packages[@]} -gt 0 ]]; then
      # Prefer bun if available, fall back to npm
      if command -v bun &> /dev/null; then
        pkg_cmd="bun"
        pkg_install="bun install -g"
      elif command -v npm &> /dev/null; then
        pkg_cmd="npm"
        pkg_install="npm install -g"
      else
        pkg_cmd=""
      fi

      if [[ -n "$pkg_cmd" ]]; then
        if [[ "$use_tui" == "true" ]] && declare -f tui_progress_start &> /dev/null; then
          tui_progress_start "Installing $pkg_cmd packages" "${#npm_packages[@]}"
          for pkg in "${npm_packages[@]}"; do
            tui_progress_next "$pkg"
            $pkg_install "$pkg" || warn "Failed to install $pkg"
          done
          tui_progress_complete "${pkg_cmd^} packages installed"
        else
          _install_log "Installing $pkg_cmd packages..."
          for pkg in "${npm_packages[@]}"; do
            $pkg_install "$pkg" || warn "Failed to install $pkg"
          done
        fi
      fi
    fi

    # Install cargo packages from config
    if command -v cargo &> /dev/null && [[ -f "$root_dir/configs/cargo.json" ]]; then
      # Count cargo packages
      local cargo_count=0
      if command -v jq &> /dev/null; then
        cargo_count=$(jq 'length' "$root_dir/configs/cargo.json" 2> /dev/null || echo 0)
      fi

      if [[ "$cargo_count" -gt 0 ]]; then
        if [[ "$use_tui" == "true" ]] && declare -f tui_progress_start &> /dev/null; then
          tui_progress_start "Installing cargo packages" "$cargo_count"

          # Parse and install each cargo package
          while IFS= read -r pkg_json; do
            [[ -z "$pkg_json" ]] && continue

            local git_url features pkg_name install_cmd
            git_url=$(echo "$pkg_json" | jq -r '.git // empty')
            features=$(echo "$pkg_json" | jq -r '.features // [] | join(",")')

            if [[ -n "$git_url" ]]; then
              pkg_name=$(basename "$git_url" .git)
              tui_progress_next "$pkg_name"

              install_cmd="cargo install --git $git_url"
              [[ -n "$features" ]] && install_cmd+=" --features $features"

              eval "$install_cmd" || warn "Failed to install $pkg_name"
            fi
          done < <(jq -c '.[]' "$root_dir/configs/cargo.json" 2> /dev/null)

          tui_progress_complete "Cargo packages installed"
        else
          _install_log "Installing cargo packages..."
          while IFS= read -r pkg_json; do
            [[ -z "$pkg_json" ]] && continue

            local git_url features install_cmd
            git_url=$(echo "$pkg_json" | jq -r '.git // empty')
            features=$(echo "$pkg_json" | jq -r '.features // [] | join(",")')

            if [[ -n "$git_url" ]]; then
              install_cmd="cargo install --git $git_url"
              [[ -n "$features" ]] && install_cmd+=" --features $features"

              eval "$install_cmd" || warn "Failed to install from $git_url"
            fi
          done < <(jq -c '.[]' "$root_dir/configs/cargo.json" 2> /dev/null)
        fi
      fi
    fi

    # Cleanup TUI
    if [[ "$use_tui" == "true" ]] && declare -f tui_cleanup &> /dev/null; then
      tui_cleanup
    fi

    _install_success "Package installation complete"
  else
    # Install single package
    header "Installing package: $package"

    # Detect package manager
    pm=$(detect_package_manager)

    if [[ "$pm" == "auto" ]]; then
      # Auto-detect: prefer brew on both platforms
      if is_macos; then
        if ! check_brew; then
          error "Homebrew is required on macOS for auto-install"
          exit 1
        fi
        pm="brew"
      elif is_linux; then
        if ! check_brew; then
          error "Homebrew/Linuxbrew is required for auto-install. Run 'jsh init' to install it."
          exit 1
        fi
        pm="brew"
      else
        error "Unsupported operating system"
        exit 1
      fi
    fi

    # Start TUI spinner for single package install
    if [[ "$use_tui" == "true" ]] && declare -f tui_progress_start &> /dev/null; then
      tui_progress_start "Installing $package" 0
      tui_progress_update 0 "$package via $pm"
    fi

    # Install via specified package manager
    if install_via_package_manager "$package" "$pm"; then
      # Package installed successfully - don't search for cross-platform equivalents
      if [[ "$use_tui" == "true" ]] && declare -f tui_progress_complete &> /dev/null; then
        tui_progress_complete "Installed $package"
        tui_cleanup
      fi
      _install_success "Installation complete"
    else
      if [[ "$use_tui" == "true" ]] && declare -f tui_cleanup &> /dev/null; then
        tui_cleanup
      fi
      error "Failed to install '$package' via $pm"
      # Only search for alternatives if installation failed
      search_cross_platform_packages "$package"
      exit 1
    fi
  fi

}

# :command.function
jsh_uninstall_command() {
  # src/uninstall_command.sh
  root_dir="$(get_root_dir)"
  package="${args[package]}"

  header "Uninstalling package: $package"

  found=false

  if is_macos; then
    if ! check_brew; then
      error "Homebrew is required on macOS"
    fi

    # Check if it's a cask
    casks_file="$root_dir/configs/macos/casks.json"
    if [[ -f "$casks_file" ]] && jq -e --arg pkg "$package" 'index($pkg) != null' "$casks_file" > /dev/null 2>&1; then
      log "Uninstalling cask: $package"
      brew_cmd uninstall --cask "$package" 2> /dev/null || warn "Failed to uninstall cask"
      remove_package_from_json "$casks_file" "$package"
      found=true
    fi

    # Check if it's a formula
    formulae_file="$root_dir/configs/macos/formulae.json"
    if [[ -f "$formulae_file" ]] && jq -e --arg pkg "$package" 'index($pkg) != null' "$formulae_file" > /dev/null 2>&1; then
      log "Uninstalling formula: $package"
      brew_cmd uninstall "$package" 2> /dev/null || warn "Failed to uninstall formula"
      remove_package_from_json "$formulae_file" "$package"
      found=true
    fi

    # If not found in config, try to uninstall anyway
    if [[ "$found" == "false" ]]; then
      log "Package not in config files, attempting uninstall..."
      if brew_cmd uninstall --cask "$package" 2> /dev/null; then
        success "Uninstalled cask: $package"
      elif brew_cmd uninstall "$package" 2> /dev/null; then
        success "Uninstalled formula: $package"
      else
        error "Package '$package' not found or failed to uninstall"
      fi
    fi

  elif is_linux; then
    # Check brew formulae first
    formulae_file="$root_dir/configs/linux/formulae.json"
    if [[ -f "$formulae_file" ]] && jq -e --arg pkg "$package" 'index($pkg) != null' "$formulae_file" > /dev/null 2>&1; then
      log "Uninstalling brew formula: $package"
      brew_cmd uninstall "$package" 2> /dev/null || warn "Failed to uninstall via brew"
      remove_package_from_json "$formulae_file" "$package"
      found=true
    fi

    # Check system package manager configs
    config_files=(
      "apt:$root_dir/configs/linux/apt.json"
      "dnf:$root_dir/configs/linux/dnf.json"
      "pacman:$root_dir/configs/linux/pacman.json"
    )

    for entry in "${config_files[@]}"; do
      pm="${entry%%:*}"
      config_file="${entry#*:}"

      if [[ -f "$config_file" ]] && jq -e --arg pkg "$package" 'index($pkg) != null' "$config_file" > /dev/null 2>&1; then
        log "Found in $pm config, uninstalling..."
        case "$pm" in
          apt) sudo apt-get remove -y "$package" 2> /dev/null || warn "apt remove failed" ;;
          dnf) sudo dnf remove -y "$package" 2> /dev/null || warn "dnf remove failed" ;;
          pacman) sudo pacman -Rs --noconfirm "$package" 2> /dev/null || warn "pacman remove failed" ;;
        esac
        remove_package_from_json "$config_file" "$package"
        found=true
      fi
    done

    # If not found in config, try to uninstall anyway
    if [[ "$found" == "false" ]]; then
      log "Package not in config files, attempting uninstall..."
      if command -v brew &> /dev/null && brew_cmd uninstall "$package" 2> /dev/null; then
        success "Uninstalled via brew: $package"
      elif command -v apt-get &> /dev/null && sudo apt-get remove -y "$package" 2> /dev/null; then
        success "Uninstalled via apt: $package"
      elif command -v dnf &> /dev/null && sudo dnf remove -y "$package" 2> /dev/null; then
        success "Uninstalled via dnf: $package"
      elif command -v pacman &> /dev/null && sudo pacman -Rs --noconfirm "$package" 2> /dev/null; then
        success "Uninstalled via pacman: $package"
      else
        error "Package '$package' not found or failed to uninstall"
      fi
    fi
  else
    error "Unsupported operating system"
  fi

  if [[ "$found" == "true" ]]; then
    success "Uninstalled: $package"
  fi

}

# :command.function
jsh_upgrade_command() {
  # src/upgrade_command.sh
  root_dir="$(get_root_dir)"

  # Source required libraries
  # shellcheck source=src/lib/tui.sh
  [[ -f "$root_dir/src/lib/tui.sh" ]] && source "$root_dir/src/lib/tui.sh"
  # shellcheck source=src/lib/brew.sh
  [[ -f "$root_dir/src/lib/brew.sh" ]] && source "$root_dir/src/lib/brew.sh"

  # Check flags (bashly populates ${args[--flag]})
  use_tui=true
  if [[ -n "${args[--no - progress]:-}" ]] || [[ -n "${args[--quiet]:-}" ]]; then
    use_tui=false
  fi

  # Initialize TUI if available and enabled
  if [[ "$use_tui" == "true" ]] && declare -f tui_init &> /dev/null; then
    tui_init || use_tui=false
  fi

  # Helper function for TUI-aware logging
  _upgrade_log() {
    if [[ "$use_tui" == "true" ]] && declare -f tui_log &> /dev/null; then
      tui_log "$@"
    else
      log "$@"
    fi
  }

  _upgrade_success() {
    if [[ "$use_tui" == "true" ]] && declare -f tui_success &> /dev/null; then
      tui_success "$@"
    else
      success "$@"
    fi
  }

  # Update zinit if present
  if command -v zsh &> /dev/null; then
    if [[ "$use_tui" == "true" ]] && declare -f tui_run_animated &> /dev/null; then
      tui_progress_start "Updating zinit" 0
      tui_progress_update 0 "cleaning"
      tui_run_animated "zsh -c 'source ~/.zshrc && zinit delete --clean' 2>/dev/null" || true
      tui_progress_update 0 "self-update"
      tui_run_animated "zsh -c 'source ~/.zshrc && zinit self-update' 2>/dev/null" || true
      tui_progress_update 0 "updating plugins"
      tui_run_animated "zsh -c 'source ~/.zshrc && zinit update --all' 2>/dev/null" || true
      tui_progress_complete "Zinit updated"
    else
      log "Cleaning zinit..."
      zsh -ic 'zinit delete --clean' 2> /dev/null || true
      log "Updating zinit..."
      zsh -ic 'zinit self-update' 2> /dev/null || true
      zsh -ic 'zinit update --all' 2> /dev/null || true
    fi
  fi

  # Update TPM and tmux plugins if present
  tpm_home="${HOME}/.tmux/plugins/tpm"
  if [[ -d "$tpm_home" ]]; then
    if [[ "$use_tui" == "true" ]] && declare -f tui_run_animated &> /dev/null; then
      tui_progress_start "Updating TPM" 0
      tui_progress_update 0 "pulling latest"
      tui_run_animated "git -C '$tpm_home' pull" || true
      tui_progress_update 0 "updating plugins"
      tui_run_animated "'$tpm_home/bin/update_plugins' all" || true
      tui_progress_complete "TPM updated"
    else
      log "Updating TPM..."
      git -C "$tpm_home" pull || true
      log "Updating tmux plugins..."
      "$tpm_home/bin/update_plugins" all 2> /dev/null || true
    fi
  fi

  if is_macos; then
    if command -v brew &> /dev/null; then
      if [[ "$use_tui" == "true" ]] && declare -f brew_upgrade_with_tui &> /dev/null; then
        brew_upgrade_with_tui
      else
        log "Upgrading Homebrew packages..."
        brew update && brew upgrade
      fi
    fi
    if command -v mas &> /dev/null; then
      if [[ "$use_tui" == "true" ]] && declare -f tui_run_animated &> /dev/null; then
        tui_progress_start "Upgrading Mac App Store" 0
        tui_run_animated "mas upgrade"
        tui_progress_complete "App Store updated"
      else
        log "Upgrading Mac App Store apps..."
        mas upgrade
      fi
    fi
  elif is_linux; then
    if [[ "$use_tui" == "true" ]] && declare -f tui_run_animated &> /dev/null; then
      tui_progress_start "Upgrading system packages" 0
      tui_run_animated "upgrade_packages"
      tui_progress_complete "System packages updated"
    else
      log "Upgrading packages..."
      upgrade_packages
    fi
    if command -v brew &> /dev/null; then
      if [[ "$use_tui" == "true" ]] && declare -f brew_upgrade_with_tui &> /dev/null; then
        brew_upgrade_with_tui
      else
        log "Upgrading Homebrew packages..."
        brew update && brew upgrade
      fi
    fi
  fi

  # Upgrade npm/bun packages from config
  npm_packages=()
  if [[ -f "$root_dir/configs/npm.json" ]]; then
    while IFS= read -r line; do
      [[ -n "$line" ]] && npm_packages+=("$line")
    done < <(load_packages_from_json "$root_dir/configs/npm.json")
  fi

  if [[ ${#npm_packages[@]} -gt 0 ]]; then
    # Prefer bun if available, fall back to npm
    if command -v bun &> /dev/null; then
      pkg_cmd="bun"
      pkg_install="bun install -g"
    elif command -v npm &> /dev/null; then
      pkg_cmd="npm"
      pkg_install="npm install -g"
    else
      pkg_cmd=""
    fi

    if [[ -n "$pkg_cmd" ]]; then
      if [[ "$use_tui" == "true" ]] && declare -f tui_progress_start &> /dev/null; then
        tui_progress_start "Upgrading $pkg_cmd packages" "${#npm_packages[@]}"
        for pkg in "${npm_packages[@]}"; do
          tui_progress_next "$pkg"
          $pkg_install "$pkg" || warn "Failed to upgrade $pkg"
        done
        tui_progress_complete "${pkg_cmd^} packages updated"
      else
        log "Upgrading $pkg_cmd packages..."
        for pkg in "${npm_packages[@]}"; do
          $pkg_install "$pkg" || warn "Failed to upgrade $pkg"
        done
      fi
    fi
  fi

  # Upgrade cargo packages from config
  if command -v cargo &> /dev/null && [[ -f "$root_dir/configs/cargo.json" ]]; then
    # Count cargo packages
    cargo_count=0
    if command -v jq &> /dev/null; then
      cargo_count=$(jq 'length' "$root_dir/configs/cargo.json" 2> /dev/null || echo 0)
    fi

    if [[ "$cargo_count" -gt 0 ]]; then
      if [[ "$use_tui" == "true" ]] && declare -f tui_progress_start &> /dev/null; then
        tui_progress_start "Upgrading cargo packages" "$cargo_count"

        while IFS= read -r pkg_json; do
          [[ -z "$pkg_json" ]] && continue

          git_url=$(echo "$pkg_json" | jq -r '.git // empty')
          features=$(echo "$pkg_json" | jq -r '.features // [] | join(",")')

          if [[ -n "$git_url" ]]; then
            pkg_name=$(basename "$git_url" .git)
            tui_progress_next "$pkg_name"

            install_cmd="cargo install --force --git $git_url"
            [[ -n "$features" ]] && install_cmd+=" --features $features"

            eval "$install_cmd" || warn "Failed to upgrade $pkg_name"
          fi
        done < <(jq -c '.[]' "$root_dir/configs/cargo.json" 2> /dev/null)

        tui_progress_complete "Cargo packages updated"
      else
        log "Upgrading cargo packages..."
        while IFS= read -r pkg_json; do
          [[ -z "$pkg_json" ]] && continue

          git_url=$(echo "$pkg_json" | jq -r '.git // empty')
          features=$(echo "$pkg_json" | jq -r '.features // [] | join(",")')

          if [[ -n "$git_url" ]]; then
            install_cmd="cargo install --force --git $git_url"
            [[ -n "$features" ]] && install_cmd+=" --features $features"

            eval "$install_cmd" || warn "Failed to upgrade from $git_url"
          fi
        done < <(jq -c '.[]' "$root_dir/configs/cargo.json" 2> /dev/null)
      fi
    fi
  fi

  # Cleanup TUI
  if [[ "$use_tui" == "true" ]] && declare -f tui_cleanup &> /dev/null; then
    tui_cleanup
  fi

  success "Upgrade complete"

}

# :command.function
jsh_configure_command() {
  # src/configure_command.sh
  root_dir="$(get_root_dir)"

  header "Configuring environment"

  # Deploy dotfiles
  "$0" dotfiles

  # Configure brew links
  if check_brew; then
    log "Configuring Brew Links..."
    brew link --overwrite --force mpv tlrc || warn "Failed to link brew packages"
  fi

  if is_macos; then
    log "Configuring macOS..."
    bash "$root_dir/scripts/macos/configure-settings.sh" || warn "Failed to configure macOS settings"
    bash "$root_dir/scripts/macos/configure-dock.sh" || warn "Failed to configure dock"

    # VSCode
    if [[ -d "/Applications/Visual Studio Code.app" ]]; then
      log "Configuring VSCode..."
      vscode_user="$HOME/Library/Application Support/Code/User"
      mkdir -p "$vscode_user"
      ln -sf "$root_dir/configs/vscode/keybindings.json" "$vscode_user/keybindings.json"
      ln -sf "$root_dir/configs/vscode/settings.json" "$vscode_user/settings.json"
    fi
  elif is_linux; then
    log "Configuring Linux..."
    bash "$root_dir/scripts/linux/configure-sudoers.sh" || warn "Failed to configure sudoers"
  fi

  success "Configuration complete"

}

# :command.function
jsh_dotfiles_command() {
  # src/dotfiles_command.sh
  root_dir="$(get_root_dir)"
  dotfiles_dir="$root_dir/dotfiles"
  non_interactive="${args[--non - interactive]:-}"

  # Handle flags
  if [[ "${args[--status]}" ]]; then
    # Show status
    header "Dotfile Symlink Status"

    for item in "$dotfiles_dir"/.* "$dotfiles_dir"/*; do
      [[ "$(basename "$item")" == "." || "$(basename "$item")" == ".." ]] && continue
      [[ ! -e "$item" ]] && continue

      basename_item=$(basename "$item")

      if [[ "$basename_item" == ".config" ]]; then
        for config_item in "$item"/*; do
          [[ ! -e "$config_item" ]] && continue
          config_basename=$(basename "$config_item")
          config_target="$HOME/.config/$config_basename"

          if [[ -L "$config_target" ]]; then
            link_target=$(readlink "$config_target" 2> /dev/null || true)
            if [[ "$link_target" == "$config_item" ]]; then
              echo -e "  ${GREEN}âœ“${RESET} .config/$config_basename"
            else
              echo -e "  ${YELLOW}âš ${RESET} .config/$config_basename (wrong target)"
            fi
          elif [[ -e "$config_target" ]]; then
            echo -e "  ${YELLOW}âš ${RESET} .config/$config_basename (file exists)"
          else
            echo -e "  ${RED}âœ—${RESET} .config/$config_basename (not linked)"
          fi
        done
      else
        target="$HOME/$basename_item"
        if [[ -L "$target" ]]; then
          link_target=$(readlink "$target" 2> /dev/null || true)
          if [[ "$link_target" == "$item" ]]; then
            echo -e "  ${GREEN}âœ“${RESET} $basename_item"
          else
            echo -e "  ${YELLOW}âš ${RESET} $basename_item (wrong target)"
          fi
        elif [[ -e "$target" ]]; then
          echo -e "  ${YELLOW}âš ${RESET} $basename_item (file exists)"
        else
          echo -e "  ${RED}âœ—${RESET} $basename_item (not linked)"
        fi
      fi
    done
    exit 0
  fi

  if [[ "${args[--remove]}" ]]; then
    # Remove symlinks
    log "Removing jsh-managed symlinks..."

    find ~ -maxdepth 1 -type l -print 2> /dev/null | while read -r link; do
      target=$(readlink "$link" 2> /dev/null || echo "")
      if [[ "$target" == *"$root_dir/dotfiles"* ]]; then
        echo "ðŸ—‘ï¸  Removing symlink: $link"
        rm "$link"
      fi
    done

    if [[ -d "$HOME/.config" ]]; then
      find "$HOME/.config" -maxdepth 1 -type l -print 2> /dev/null | while read -r link; do
        target=$(readlink "$link" 2> /dev/null || echo "")
        if [[ "$target" == *"$root_dir/dotfiles/.config"* ]]; then
          echo "ðŸ—‘ï¸  Removing symlink: $link"
          rm "$link"
        fi
      done
    fi

    success "Dotfiles symlinks removed"
    exit 0
  fi

  # Default: deploy dotfiles
  log "Deploying dotfiles..."
  mkdir -p "$HOME/.config"

  for item in "$dotfiles_dir"/.* "$dotfiles_dir"/*; do
    [[ "$(basename "$item")" == "." || "$(basename "$item")" == ".." ]] && continue
    [[ ! -e "$item" ]] && continue

    basename_item=$(basename "$item")
    target="$HOME/$basename_item"

    if [[ "$basename_item" == ".config" ]]; then
      log "Processing .config directory..."
      for config_item in "$item"/*; do
        [[ ! -e "$config_item" ]] && continue
        config_basename=$(basename "$config_item")
        config_target="$HOME/.config/$config_basename"

        if [[ -e "$config_target" || -L "$config_target" ]]; then
          link_target=$(readlink "$config_target" 2> /dev/null || echo "")
          if [[ "$link_target" != "$config_item" ]]; then
            if [[ -n "$non_interactive" ]]; then
              # Auto-backup without prompting
              mv "$config_target" "${config_target}.backup"
              ln -sf "$config_item" "$config_target"
              echo "  âœ“ Backed up and linked $config_basename"
            else
              # Prompt user for existing file
              echo ""
              warn "Conflict: $config_target already exists"
              if [[ -L "$config_target" ]]; then
                info "  Current symlink points to: $link_target"
              fi
              echo "  [s]kip  [b]ackup and replace  [o]verwrite"
              read -n 1 -r -p "  Choice: " choice
              echo ""
              case "$choice" in
                b | B)
                  mv "$config_target" "${config_target}.backup"
                  ln -sf "$config_item" "$config_target"
                  echo "  âœ“ Backed up and linked $config_basename"
                  ;;
                o | O)
                  rm -rf "$config_target"
                  ln -sf "$config_item" "$config_target"
                  echo "  âœ“ Overwritten $config_basename"
                  ;;
                *)
                  echo "  â­ Skipped $config_basename"
                  ;;
              esac
            fi
          else
            rm "$config_target"
            ln -sf "$config_item" "$config_target"
          fi
        else
          ln -sf "$config_item" "$config_target"
          echo "  âœ“ Linked $config_basename"
        fi
      done
    else
      if [[ -e "$target" || -L "$target" ]]; then
        link_target=$(readlink "$target" 2> /dev/null || echo "")
        if [[ "$link_target" != "$item" ]]; then
          if [[ -n "$non_interactive" ]]; then
            # Auto-backup without prompting
            mv "$target" "${target}.backup"
            ln -sf "$item" "$target"
            echo "  âœ“ Backed up and linked $basename_item"
          else
            echo ""
            warn "Conflict: $target already exists"
            if [[ -L "$target" ]]; then
              info "  Current symlink points to: $link_target"
            fi
            echo "  [s]kip  [b]ackup and replace  [o]verwrite"
            read -n 1 -r -p "  Choice: " choice
            echo ""
            case "$choice" in
              b | B)
                mv "$target" "${target}.backup"
                ln -sf "$item" "$target"
                echo "  âœ“ Backed up and linked $basename_item"
                ;;
              o | O)
                rm -rf "$target"
                ln -sf "$item" "$target"
                echo "  âœ“ Overwritten $basename_item"
                ;;
              *)
                echo "  â­ Skipped $basename_item"
                ;;
            esac
          fi
        else
          rm "$target"
          ln -sf "$item" "$target"
        fi
      else
        ln -sf "$item" "$target"
        echo "  âœ“ Linked $basename_item"
      fi
    fi
  done

  success "Dotfiles deployed successfully"

}

# :command.function
jsh_clean_command() {
  # src/clean_command.sh
  root_dir="$(get_root_dir)"
  header "Cleaning up system"
  bash "$root_dir/scripts/unix/cleanup.sh" "$root_dir"

}

# :command.function
jsh_status_command() {
  # src/status_command.sh
  root_dir="$(get_root_dir)"

  header "System Status"

  check_brew || exit 1

  # Homebrew formulae
  echo -e "${BOLD}${MAGENTA}Homebrew Formulae:${RESET}"
  if cmd_exists brew; then
    formulae_count=$(brew list --formula 2> /dev/null | wc -l | tr -d ' ')
    echo -e "  Installed: ${GREEN}${formulae_count}${RESET} formulae"

    outdated=$(brew outdated --formula 2> /dev/null | wc -l | tr -d ' ')
    if [[ "$outdated" -gt 0 ]]; then
      echo -e "  Outdated:  ${YELLOW}${outdated}${RESET} formulae"
    else
      echo -e "  Outdated:  ${GREEN}0${RESET} (all up to date)"
    fi
  fi
  echo

  # Homebrew casks (macOS only)
  if is_macos; then
    echo -e "${BOLD}${MAGENTA}Homebrew Casks:${RESET}"
    casks_count=$(brew list --cask 2> /dev/null | wc -l | tr -d ' ')
    echo -e "  Installed: ${GREEN}${casks_count}${RESET} casks"

    outdated_casks=$(brew outdated --cask 2> /dev/null | wc -l | tr -d ' ')
    if [[ "$outdated_casks" -gt 0 ]]; then
      echo -e "  Outdated:  ${YELLOW}${outdated_casks}${RESET} casks"
    else
      echo -e "  Outdated:  ${GREEN}0${RESET} (all up to date)"
    fi
    echo
  fi

  # Homebrew services
  echo -e "${BOLD}${MAGENTA}Homebrew Services:${RESET}"
  if cmd_exists brew; then
    while IFS= read -r line; do
      service=$(echo "$line" | awk '{print $1}')
      svc_status=$(echo "$line" | awk '{print $2}')

      if [[ "$svc_status" == "started" ]]; then
        echo -e "  ${GREEN}â—${RESET} ${service} (${GREEN}running${RESET})"
      elif [[ "$svc_status" == "stopped" ]]; then
        echo -e "  ${RED}â—${RESET} ${service} (${RED}stopped${RESET})"
      else
        echo -e "  ${YELLOW}â—${RESET} ${service} (${YELLOW}${svc_status}${RESET})"
      fi
    done < <(brew services list 2> /dev/null | tail -n +2)
  fi
  echo

  # Symlinks
  echo -e "${BOLD}${MAGENTA}Dotfile Symlinks:${RESET}"
  symlink_count=0
  broken_count=0

  for link in "$HOME"/.* "$HOME"/*; do
    [[ ! -L "$link" ]] && continue
    target=$(readlink "$link" 2> /dev/null || true)
    [[ -z "$target" ]] && continue

    case "$target" in
      "$root_dir"*) ;;
      *) continue ;;
    esac

    ((++symlink_count))
    if [[ ! -e "$link" ]]; then
      ((++broken_count))
    fi
  done

  echo -e "  Total:  ${GREEN}${symlink_count}${RESET} symlinks"
  if [[ "$broken_count" -gt 0 ]]; then
    echo -e "  Broken: ${RED}${broken_count}${RESET} symlinks"
  else
    echo -e "  Broken: ${GREEN}0${RESET} (all valid)"
  fi
  echo

  # Git status
  echo -e "${BOLD}${MAGENTA}Git Repository:${RESET}"
  if [[ -d "${root_dir}/.git" ]]; then
    pushd "${root_dir}" > /dev/null
    branch=$(git branch --show-current 2> /dev/null || echo "unknown")
    echo -e "  Branch:  ${CYAN}${branch}${RESET}"

    git_status=$(git status --porcelain 2> /dev/null | wc -l | tr -d ' ')
    if [[ "$git_status" -gt 0 ]]; then
      echo -e "  Changes: ${YELLOW}${git_status}${RESET} uncommitted changes"
    else
      echo -e "  Changes: ${GREEN}clean${RESET}"
    fi
    popd > /dev/null
  fi
  echo

  # System info
  echo -e "${BOLD}${MAGENTA}System Information:${RESET}"
  echo -e "  OS:     $(uname -s) $(uname -r)"
  echo -e "  Shell:  ${SHELL} (${ZSH_VERSION:-bash})"
  echo -e "  Arch:   $(uname -m)"
  echo

}

# :command.function
jsh_doctor_command() {
  # src/doctor_command.sh
  root_dir="$(get_root_dir)"

  header "Running jsh diagnostics"

  issues=0
  warnings=0

  # Check for required commands
  echo -e "${BOLD}Checking required commands...${RESET}"
  required_cmds=(brew git curl jq vim)
  for cmd in "${required_cmds[@]}"; do
    if cmd_exists "$cmd"; then
      echo -e "  ${GREEN}âœ“${RESET} ${cmd}"
    else
      echo -e "  ${RED}âœ—${RESET} ${cmd} (missing)"
      ((issues++))
    fi
  done
  echo

  # Check for recommended commands
  echo -e "${BOLD}Checking recommended commands...${RESET}"
  recommended_cmds=(fzf zoxide rg fd nvim tmux)
  for cmd in "${recommended_cmds[@]}"; do
    if cmd_exists "$cmd"; then
      echo -e "  ${GREEN}âœ“${RESET} ${cmd}"
    else
      echo -e "  ${YELLOW}â—‹${RESET} ${cmd} (not installed - optional)"
    fi
  done
  echo

  # Check for broken symlinks
  echo -e "${BOLD}Checking dotfile symlinks...${RESET}"
  dotfiles=(.bashrc .zshrc .jshrc .vimrc .tmux.conf .gitconfig .inputrc .editorconfig)
  for dotfile in "${dotfiles[@]}"; do
    target="${HOME}/${dotfile}"
    if [[ -L "$target" ]]; then
      if [[ -e "$target" ]]; then
        echo -e "  ${GREEN}âœ“${RESET} ${dotfile} -> $(readlink "$target")"
      else
        echo -e "  ${RED}âœ—${RESET} ${dotfile} (broken symlink)"
        ((issues++))
      fi
    elif [[ -f "$target" ]]; then
      echo -e "  ${YELLOW}âš ${RESET} ${dotfile} (exists but not symlinked)"
      ((warnings++))
    else
      echo -e "  ${YELLOW}â—‹${RESET} ${dotfile} (not present)"
    fi
  done
  echo

  # Check Git repository status
  echo -e "${BOLD}Checking Git repository...${RESET}"
  if [[ -d "${root_dir}/.git" ]]; then
    pushd "${root_dir}" > /dev/null || exit 1
    if git rev-parse --git-dir > /dev/null 2>&1; then
      echo -e "  ${GREEN}âœ“${RESET} Git repository is valid"

      # Check for uncommitted changes
      if git diff --quiet HEAD 2> /dev/null; then
        echo -e "  ${GREEN}âœ“${RESET} Working tree is clean"
      else
        local changes
        changes=$(git status --short | wc -l | tr -d ' ')
        echo -e "  ${YELLOW}âš ${RESET} $changes uncommitted change(s)"
        ((warnings++))
      fi

      # Check remote sync status
      if git remote get-url origin &> /dev/null; then
        git fetch origin --quiet 2> /dev/null || true
        local ahead behind
        ahead=$(git rev-list --count origin/main..HEAD 2> /dev/null || echo 0)
        behind=$(git rev-list --count HEAD..origin/main 2> /dev/null || echo 0)
        if [[ "$ahead" -gt 0 ]]; then
          echo -e "  ${YELLOW}âš ${RESET} $ahead commit(s) ahead of origin"
        fi
        if [[ "$behind" -gt 0 ]]; then
          echo -e "  ${YELLOW}âš ${RESET} $behind commit(s) behind origin"
          ((warnings++))
        fi
        if [[ "$ahead" -eq 0 && "$behind" -eq 0 ]]; then
          echo -e "  ${GREEN}âœ“${RESET} In sync with origin"
        fi
      fi
    else
      echo -e "  ${RED}âœ—${RESET} Git repository is corrupted"
      ((issues++))
    fi

    if [[ -f "${root_dir}/.gitmodules" ]]; then
      if git submodule status | grep -q '^-'; then
        echo -e "  ${YELLOW}âš ${RESET} Some submodules are not initialized"
        ((warnings++))
      else
        echo -e "  ${GREEN}âœ“${RESET} All submodules initialized"
      fi
    fi
    popd > /dev/null || exit 1
  else
    echo -e "  ${RED}âœ—${RESET} Not a Git repository"
    ((issues++))
  fi
  echo

  # Check plugin managers
  echo -e "${BOLD}Checking plugin managers...${RESET}"

  # Zinit
  zinit_home="${XDG_DATA_HOME:-${HOME}/.local/share}/zinit/zinit.git"
  if [[ -d "$zinit_home" ]]; then
    if [[ -f "${zinit_home}/zinit.zsh" ]]; then
      echo -e "  ${GREEN}âœ“${RESET} Zinit installed"
    else
      echo -e "  ${RED}âœ—${RESET} Zinit installation corrupted"
      ((issues++))
    fi
  else
    echo -e "  ${YELLOW}â—‹${RESET} Zinit not installed (optional)"
  fi

  # TPM
  tpm_home="${HOME}/.tmux/plugins/tpm"
  if [[ -d "$tpm_home" ]]; then
    if [[ -x "${tpm_home}/tpm" ]]; then
      echo -e "  ${GREEN}âœ“${RESET} TPM installed"
    else
      echo -e "  ${RED}âœ—${RESET} TPM installation corrupted"
      ((issues++))
    fi
  else
    echo -e "  ${YELLOW}â—‹${RESET} TPM not installed (optional)"
  fi

  # vim-plug
  vim_plug="${HOME}/.vim/autoload/plug.vim"
  if [[ -f "$vim_plug" ]]; then
    echo -e "  ${GREEN}âœ“${RESET} vim-plug installed"
  else
    echo -e "  ${YELLOW}â—‹${RESET} vim-plug not installed (optional)"
  fi
  echo

  # Check Homebrew health
  if cmd_exists brew; then
    echo -e "${BOLD}Checking Homebrew...${RESET}"
    if brew doctor > /dev/null 2>&1; then
      echo -e "  ${GREEN}âœ“${RESET} Homebrew is healthy"
    else
      echo -e "  ${YELLOW}âš ${RESET} Homebrew has warnings (run 'brew doctor' for details)"
      ((warnings++))
    fi

    # Check for outdated packages
    local outdated
    outdated=$(brew outdated --quiet 2> /dev/null | wc -l | tr -d ' ')
    if [[ "$outdated" -gt 0 ]]; then
      echo -e "  ${YELLOW}âš ${RESET} $outdated outdated package(s) (run 'jsh upgrade' to update)"
    else
      echo -e "  ${GREEN}âœ“${RESET} All packages up to date"
    fi
  fi
  echo

  # Check shell configuration
  echo -e "${BOLD}Checking shell configuration...${RESET}"
  current_shell=$(basename "$SHELL")
  echo -e "  Current shell: $current_shell"

  # Check if shell rc sources jshrc
  case "$current_shell" in
    zsh)
      if grep -q "\.jshrc" ~/.zshrc 2> /dev/null; then
        echo -e "  ${GREEN}âœ“${RESET} .zshrc sources .jshrc"
      else
        echo -e "  ${YELLOW}âš ${RESET} .zshrc does not source .jshrc"
        ((warnings++))
      fi
      ;;
    bash)
      if grep -q "\.jshrc" ~/.bashrc 2> /dev/null; then
        echo -e "  ${GREEN}âœ“${RESET} .bashrc sources .jshrc"
      else
        echo -e "  ${YELLOW}âš ${RESET} .bashrc does not source .jshrc"
        ((warnings++))
      fi
      ;;
  esac

  # Check TERM setting
  if [[ -n "$TMUX" ]]; then
    if [[ "$TERM" == "tmux-256color" || "$TERM" == "screen-256color" ]]; then
      echo -e "  ${GREEN}âœ“${RESET} TERM correctly set for tmux: $TERM"
    else
      echo -e "  ${YELLOW}âš ${RESET} TERM may not be optimal for tmux: $TERM"
      ((warnings++))
    fi
  else
    echo -e "  TERM: $TERM"
  fi
  echo

  # Summary
  echo -e "${BOLD}Summary${RESET}"
  if [[ $issues -eq 0 && $warnings -eq 0 ]]; then
    success "All checks passed! No issues found."
  elif [[ $issues -eq 0 ]]; then
    info "No critical issues. $warnings warning(s) found."
  else
    warn "Found $issues issue(s) and $warnings warning(s)."
    echo ""
    info "Suggestions:"
    info "  - Run 'jsh dotfiles' to fix missing symlinks"
    info "  - Run 'jsh plugins install' to install plugin managers"
    info "  - Run 'jsh sync' to sync with remote repository"
    exit 1
  fi

}

# :command.function
jsh_deinit_command() {
  # src/deinit_command.sh
  root_dir="$(get_root_dir)"
  dotfiles_dir="$root_dir/dotfiles"

  header "Deinitializing jsh"

  warn "This will remove all jsh-managed symlinks and restore original files."
  if ! confirm "Continue with uninstall?"; then
    info "Uninstall cancelled"
    exit 0
  fi

  removed_count=0
  restored_count=0

  log "Removing jsh-managed symlinks from home directory..."

  # Process home directory symlinks
  for item in "$dotfiles_dir"/.* "$dotfiles_dir"/*; do
    [[ "$(basename "$item")" == "." || "$(basename "$item")" == ".." ]] && continue
    [[ ! -e "$item" ]] && continue

    basename_item=$(basename "$item")
    target="$HOME/$basename_item"

    [[ "$basename_item" == ".config" ]] && continue

    if [[ -L "$target" ]]; then
      link_target=$(readlink "$target" 2> /dev/null || echo "")

      if [[ "$link_target" == "$item" ]]; then
        echo "ðŸ—‘ï¸  Removing symlink: $target"
        rm "$target"
        ((removed_count++))

        backup_path="${target}-backup"
        if [[ -e "$backup_path" || -L "$backup_path" ]]; then
          echo "â™»ï¸  Restoring backup: $backup_path -> $target"
          mv "$backup_path" "$target"
          ((restored_count++))
        fi
      fi
    fi
  done

  log "Removing jsh-managed symlinks from .config directory..."

  if [[ -d "$dotfiles_dir/.config" ]]; then
    for config_item in "$dotfiles_dir/.config"/*; do
      [[ ! -e "$config_item" ]] && continue

      config_basename=$(basename "$config_item")
      config_target="$HOME/.config/$config_basename"

      if [[ -L "$config_target" ]]; then
        link_target=$(readlink "$config_target" 2> /dev/null || echo "")

        if [[ "$link_target" == "$config_item" ]]; then
          echo "ðŸ—‘ï¸  Removing symlink: $config_target"
          rm "$config_target"
          ((removed_count++))

          backup_path="${config_target}-backup"
          if [[ -e "$backup_path" || -L "$backup_path" ]]; then
            echo "â™»ï¸  Restoring backup: $backup_path -> $config_target"
            mv "$backup_path" "$config_target"
            ((restored_count++))
          fi
        fi
      fi
    done
  fi

  info "Note: You may want to remove '$root_dir/bin' from your PATH"

  echo ""
  success "Uninstall complete!"
  info "  Removed symlinks: $removed_count"
  info "  Restored backups: $restored_count"

  if [[ $restored_count -gt 0 ]]; then
    info ""
    info "Your original files have been restored."
  fi

  info ""
  info "To completely remove jsh, run: rm -rf $root_dir"

}

# :command.function
jsh_brew_command() {
  # src/brew_command.sh
  subcmd="${args[subcommand]:-help}"

  # Parse extra args from catch_all
  # Bashly stores catch_all args in other_args array
  extra_args=("${other_args[@]}")

  # Build flags to pass through
  flags=()
  [[ -n "${args[--quiet]}" ]] && flags+=("--quiet")
  [[ -n "${args[--force]}" ]] && flags+=("--force")

  case "${subcmd}" in
    setup)
      brew_setup
      ;;
    check)
      brew_check "${flags[@]}" "${extra_args[@]}"
      ;;
    help | --help | -h)
      echo -e "${BOLD}${CYAN}jsh brew${RESET} - Homebrew wrapper"
      echo ""
      echo "Subcommands:"
      echo "  setup                 Install or update Homebrew"
      echo "  check [package]       Verify package or run comprehensive checks"
      echo "  <brew command>        Pass through to brew (e.g., install, list, update)"
      echo ""
      echo "Check Options:"
      echo "  --quiet, -q          Silent mode (for check command)"
      echo "  --force, -f          Force check even if run recently"
      echo "  --linux              Force check as if on Linux platform"
      echo "  --darwin, --macos    Force check as if on Darwin/macOS platform"
      ;;
    *)
      if ! check_brew; then
        exit 1
      fi
      run_brew "${subcmd}" "${extra_args[@]}"
      ;;
  esac

}

# :command.function
jsh_completions_command() {
  # src/completions_command.sh
  if [[ "${args[--install]}" ]]; then
    # Install completions
    completion_file="$HOME/.jsh-completion.zsh"
    "$0" completions > "$completion_file"

    # Add to .zshrc if not already there
    if ! grep -q "source.*jsh-completion" "$HOME/.zshrc" 2> /dev/null; then
      echo "" >> "$HOME/.zshrc"
      echo "# jsh completions" >> "$HOME/.zshrc"
      echo "source $completion_file" >> "$HOME/.zshrc"
      success "Completions installed to $completion_file and added to .zshrc"
    else
      success "Completions updated at $completion_file"
    fi
    exit 0
  fi

  # Generate completions using printf to avoid heredoc indentation issues with bashly
  printf '%s\n' '#compdef jsh' '' \
    '_jsh() {' \
    '  local -a commands' \
    '  commands=(' \
    "    'init:Set up shell environment'" \
    "    'install:Install packages'" \
    "    'uninstall:Uninstall a package and remove from config'" \
    "    'upgrade:Upgrade all packages'" \
    "    'configure:Apply dotfiles, OS settings, and app configs'" \
    "    'dotfiles:Manage dotfile symlinks'" \
    "    'clean:Remove caches, temp files, old Homebrew versions'" \
    "    'status:Show brew packages, services, symlinks, git status'" \
    "    'doctor:Check for missing tools, broken symlinks, repo issues'" \
    "    'deinit:Remove jsh symlinks and restore backups'" \
    "    'brew:Homebrew wrapper'" \
    "    'completions:Generate shell completion script'" \
    '  )' \
    '' \
    '  _arguments -C \' \
    "    '1: :->command' \\" \
    "    '*:: :->args'" \
    '' \
    '  case $state in' \
    '    command)' \
    "      _describe -t commands 'jsh command' commands" \
    '      ;;' \
    '    args)' \
    '      case $line[1] in' \
    '        init)' \
    '          _arguments \' \
    "            '(-y --non-interactive)'{-y,--non-interactive}'[Use defaults]' \\" \
    "            '--shell[Pre-select shell]:shell:(zsh bash skip)' \\" \
    "            '--minimal[Lightweight setup]' \\" \
    "            '--full[Full setup with plugins]' \\" \
    "            '--setup[Also run install + configure]' \\" \
    "            '--no-install[Skip package installation]' \\" \
    "            '--skip-brew[Skip Homebrew]' \\" \
    "            '--dry-run[Preview changes]'" \
    '          ;;' \
    '        dotfiles)' \
    '          _arguments \' \
    "            '(-s --status)'{-s,--status}'[Show symlink status]' \\" \
    "            '(-d --remove)'{-d,--remove}'[Remove symlinks]'" \
    '          ;;' \
    '        install)' \
    '          # Could add package completion here' \
    '          ;;' \
    '        uninstall)' \
    '          # Could add installed package completion here' \
    '          ;;' \
    '        completions)' \
    '          _arguments \' \
    "            '(-i --install)'{-i,--install}'[Install to shell config]'" \
    '          ;;' \
    '      esac' \
    '      ;;' \
    '  esac' \
    '}' \
    '' \
    '_jsh'

}

# :command.function
jsh_tools_command() {
  # src/tools_command.sh
  # jsh tools - Discover and manage optional development tools
  #
  # Usage:
  #   jsh tools              - List all tools and their status
  #   jsh tools list         - Same as above
  #   jsh tools check        - Check health of installed tools
  #   jsh tools install      - Install all recommended tools
  #   jsh tools recommend    - Show recommended tools for your environment
  #
  # Categories:
  #   shell  - Shell enhancements (fzf, zoxide, atuin, eza)
  #   editor - Editor tools (neovim, helix, vim plugins)
  #   dev    - Development tools (git, jq, ripgrep, fd)
  #   k8s    - Kubernetes tools (kubectl, k9s, kubectx, helm)
  #   git    - Git enhancements (gh, lazygit, delta, forgit)

  root_dir="$(get_root_dir)"
  action="${args[action]:-list}"
  show_missing="${args[--missing]:-}"
  category_filter="${args[--category]:-}"

  # Tool definitions: name|category|description|check_command|install_command
  declare -a TOOLS=(
    # Shell enhancements
    "fzf|shell|Fuzzy finder for files, history, etc.|fzf --version|brew install fzf"
    "zoxide|shell|Smarter cd command with frecency|zoxide --version|brew install zoxide"
    "atuin|shell|Magical shell history with sync|atuin --version|brew install atuin"
    "eza|shell|Modern replacement for ls|eza --version|brew install eza"
    "bat|shell|Cat clone with syntax highlighting|bat --version|brew install bat"
    "starship|shell|Cross-shell prompt|starship --version|brew install starship"
    "direnv|shell|Per-directory environment variables|direnv version|brew install direnv"

    # Editor tools
    "nvim|editor|Neovim - hyperextensible Vim|nvim --version|brew install neovim"
    "hx|editor|Helix - post-modern modal editor|hx --version|brew install helix"
    "vim|editor|Vi Improved - the classic|vim --version|brew install vim"

    # Development tools
    "jq|dev|JSON processor|jq --version|brew install jq"
    "yq|dev|YAML processor|yq --version|brew install yq"
    "rg|dev|Ripgrep - fast grep replacement|rg --version|brew install ripgrep"
    "fd|dev|Fast find replacement|fd --version|brew install fd"
    "sd|dev|Intuitive find-and-replace|sd --version|brew install sd"
    "hyperfine|dev|Benchmarking tool|hyperfine --version|brew install hyperfine"
    "tokei|dev|Code statistics|tokei --version|brew install tokei"
    "just|dev|Modern make alternative|just --version|brew install just"
    "watchexec|dev|Execute commands on file changes|watchexec --version|brew install watchexec"

    # Kubernetes tools
    "kubectl|k8s|Kubernetes CLI|kubectl version --client|brew install kubernetes-cli"
    "k9s|k8s|Kubernetes TUI|k9s version|brew install k9s"
    "kubectx|k8s|Switch Kubernetes contexts|kubectx --version|brew install kubectx"
    "helm|k8s|Kubernetes package manager|helm version|brew install helm"
    "stern|k8s|Multi-pod log tailing|stern --version|brew install stern"
    "kustomize|k8s|Kubernetes config customization|kustomize version|brew install kustomize"

    # Git enhancements
    "gh|git|GitHub CLI|gh --version|brew install gh"
    "lazygit|git|Terminal UI for git|lazygit --version|brew install lazygit"
    "delta|git|Syntax-highlighting pager for git|delta --version|brew install git-delta"
    "git-lfs|git|Git Large File Storage|git lfs version|brew install git-lfs"
    "pre-commit|git|Git hook framework|pre-commit --version|brew install pre-commit"

    # Container tools
    "docker|container|Container runtime|docker --version|brew install --cask docker"
    "podman|container|Docker alternative|podman --version|brew install podman"
    "lazydocker|container|Terminal UI for Docker|lazydocker --version|brew install lazydocker"

    # Cloud tools
    "aws|cloud|AWS CLI|aws --version|brew install awscli"
    "gcloud|cloud|Google Cloud CLI|gcloud --version|brew install google-cloud-sdk"
    "az|cloud|Azure CLI|az --version|brew install azure-cli"
    "terraform|cloud|Infrastructure as Code|terraform version|brew install terraform"
  )

  # Check if a tool is installed
  check_tool() {
    local check_cmd="$1"
    eval "$check_cmd" &> /dev/null
    return $?
  }

  # Get tool info
  parse_tool() {
    local tool_line="$1"
    IFS='|' read -r name category description check_cmd install_cmd <<< "$tool_line"
    echo "$name|$category|$description|$check_cmd|$install_cmd"
  }

  # List tools
  list_tools() {
    local filter_cat="$1"
    local only_missing="$2"

    echo -e "${BOLD}Development Tools${RESET}"
    echo ""

    local current_cat=""
    local installed_count=0
    local missing_count=0

    for tool_line in "${TOOLS[@]}"; do
      IFS='|' read -r name category description check_cmd install_cmd <<< "$tool_line"

      # Filter by category if specified
      [[ -n "$filter_cat" && "$category" != "$filter_cat" ]] && continue

      # Check if installed
      local status icon color
      if check_tool "$check_cmd"; then
        status="installed"
        icon="âœ“"
        color="${GREEN}"
        ((installed_count++)) || true
        [[ -n "$only_missing" ]] && continue
      else
        status="missing"
        icon="âœ—"
        color="${RED}"
        ((missing_count++)) || true
      fi

      # Print category header
      if [[ "$category" != "$current_cat" ]]; then
        [[ -n "$current_cat" ]] && echo ""
        echo -e "${BOLD}${category^^}${RESET}"
        current_cat="$category"
      fi

      # Print tool info
      printf "  ${color}${icon}${RESET} %-15s %s\n" "$name" "$description"
    done

    echo ""
    echo -e "${BOLD}Summary:${RESET} ${GREEN}$installed_count installed${RESET}, ${RED}$missing_count missing${RESET}"
  }

  # Check tool health
  check_tools() {
    echo -e "${BOLD}Checking tool health...${RESET}"
    echo ""

    local issues=0

    for tool_line in "${TOOLS[@]}"; do
      IFS='|' read -r name category description check_cmd install_cmd <<< "$tool_line"

      if check_tool "$check_cmd"; then
        # Tool is installed, check version
        local version
        version=$(eval "$check_cmd" 2>&1 | head -1)
        echo -e "  ${GREEN}âœ“${RESET} $name: $version"
      fi
    done

    echo ""
    if [[ $issues -eq 0 ]]; then
      success "All installed tools are healthy"
    else
      warn "Found $issues issue(s)"
    fi
  }

  # Install missing recommended tools
  install_tools() {
    local filter_cat="$1"

    # Check for Homebrew first
    if ! command -v brew &> /dev/null; then
      echo -e "${RED}Homebrew is not installed${RESET}"
      echo "Install Homebrew first: https://brew.sh"
      echo "Or run: jsh init"
      return 1
    fi

    # Recommended tools (installed by default without -c flag)
    local -A recommended=(
      [fzf]=1 [zoxide]=1 [eza]=1 [bat]=1 [direnv]=1
      [nvim]=1
      [jq]=1 [rg]=1 [fd]=1
      [gh]=1 [lazygit]=1 [delta]=1
    )

    # Map tool names to brew package names (when different)
    local -A brew_pkg=(
      [nvim]=neovim [rg]=ripgrep [delta]=git-delta
    )

    # Collect tools to install
    local -a to_install=()
    local -a to_install_names=()
    local name category description check_cmd install_cmd pkg

    for tool_line in "${TOOLS[@]}"; do
      IFS='|' read -r name category description check_cmd install_cmd <<< "$tool_line"

      # Filter by category if specified
      [[ -n "$filter_cat" && "$category" != "$filter_cat" ]] && continue

      # Only install recommended tools unless category filter is set
      [[ -z "$filter_cat" && -z "${recommended[$name]:-}" ]] && continue

      # Skip if already installed
      eval "$check_cmd" &> /dev/null && continue

      # Get brew package name
      pkg="${brew_pkg[$name]:-$name}"
      to_install+=("$pkg")
      to_install_names+=("$name")
    done

    # Nothing to install?
    if [[ ${#to_install[@]} -eq 0 ]]; then
      echo "All recommended tools are already installed"
      return 0
    fi

    # Show what we're installing
    echo -e "${BOLD}Installing ${#to_install[@]} tool(s):${RESET} ${to_install_names[*]}"
    echo ""

    # Install all at once
    if brew install "${to_install[@]}"; then
      echo ""
      echo -e "${GREEN}Installed ${#to_install[@]} tool(s)${RESET}"
      echo "Reload your shell to use new tools: exec \$SHELL"
    else
      echo ""
      echo -e "${YELLOW}Some tools may have failed to install${RESET}"
      echo "Run 'jsh tools list' to check status"
    fi
  }

  # Show recommendations
  recommend_tools() {
    echo -e "${BOLD}Recommended Tools for Your Environment${RESET}"
    echo ""

    # Detect environment
    local env_type=""
    if [[ -f "${root_dir}/src/lib/environment.sh" ]]; then
      source "${root_dir}/src/lib/environment.sh"
      env_type=$(get_jsh_env 2> /dev/null || echo "unknown")
    fi

    info "Detected environment: ${env_type:-unknown}"
    echo ""

    echo -e "${BOLD}Essential (start here):${RESET}"
    echo "  fzf       - Fuzzy finder, dramatically improves productivity"
    echo "  zoxide    - Smarter cd that learns your habits"
    echo "  eza       - Beautiful ls replacement with git integration"
    echo "  rg        - Ripgrep - search code blazingly fast"
    echo ""

    echo -e "${BOLD}Developer productivity:${RESET}"
    echo "  jq        - Parse and manipulate JSON"
    echo "  fd        - Find files faster than find"
    echo "  bat       - Cat with syntax highlighting"
    echo "  delta     - Beautiful git diffs"
    echo "  lazygit   - Terminal UI for git operations"
    echo ""

    echo -e "${BOLD}For Kubernetes users:${RESET}"
    echo "  k9s       - Terminal UI for Kubernetes"
    echo "  kubectx   - Switch contexts/namespaces quickly"
    echo "  stern     - Tail logs from multiple pods"
    echo ""

    info "Run 'jsh tools install' to install recommended tools"
    info "Run 'jsh tools list -c <category>' to see all tools in a category"
  }

  # Main action dispatch
  case "$action" in
    list)
      list_tools "$category_filter" "$show_missing"
      ;;
    check)
      check_tools
      ;;
    install)
      install_tools "$category_filter"
      ;;
    recommend)
      recommend_tools
      ;;
    *)
      error "Unknown action: $action"
      info "Valid actions: list, check, install, recommend"
      exit 1
      ;;
  esac

}

# :command.function
jsh_sync_command() {
  # src/sync_command.sh
  # jsh sync - Sync jsh changes with remote repository
  #
  # Usage:
  #   jsh sync              - Pull then push changes
  #   jsh sync --pull       - Pull changes only
  #   jsh sync --push       - Push changes only
  #   jsh sync --stash      - Stash local changes before syncing
  #
  # This command helps keep your jsh configuration synchronized across machines.
  # It handles git operations safely and provides clear feedback.

  root_dir="$(get_root_dir)"
  pull_only="${args[--pull]:-}"
  push_only="${args[--push]:-}"
  do_stash="${args[--stash]:-}"
  force_sync="${args[--force]:-}"

  header "Syncing jsh repository"

  # Ensure we're in a git repository
  if [[ ! -d "${root_dir}/.git" ]]; then
    error "Not a git repository: ${root_dir}"
    exit 1
  fi

  cd "${root_dir}" || exit 1

  # Check for remote
  remote_url=$(git remote get-url origin 2> /dev/null || echo "")
  if [[ -z "$remote_url" ]]; then
    error "No remote 'origin' configured"
    info "Add a remote with: git remote add origin <url>"
    exit 1
  fi

  info "Remote: $remote_url"
  echo ""

  # Get current branch
  current_branch=$(git rev-parse --abbrev-ref HEAD 2> /dev/null || echo "main")
  info "Branch: $current_branch"

  # Check for uncommitted changes
  has_changes=false
  if ! git diff --quiet HEAD 2> /dev/null; then
    has_changes=true
  fi

  if ! git diff --cached --quiet 2> /dev/null; then
    has_changes=true
  fi

  # Handle uncommitted changes
  if [[ "$has_changes" == "true" ]]; then
    echo ""
    warn "You have uncommitted changes:"
    git status --short
    echo ""

    if [[ -n "$do_stash" ]]; then
      log "Stashing changes..."
      stash_msg="jsh sync stash $(date '+%Y-%m-%d %H:%M:%S')"
      git stash push -m "$stash_msg"
      info "Changes stashed: $stash_msg"
    elif [[ -z "$push_only" ]]; then
      # For pull operations, we need clean state
      error "Cannot pull with uncommitted changes"
      info "Options:"
      info "  1. Commit your changes first"
      info "  2. Run with --stash to stash changes"
      info "  3. Run with --push to only push (skip pull)"
      exit 1
    fi
  fi

  # Fetch latest from remote
  log "Fetching from remote..."
  if ! git fetch origin "$current_branch" 2> /dev/null; then
    warn "Could not fetch from remote (offline or no access)"
  fi

  # Pull changes
  if [[ -z "$push_only" ]]; then
    echo ""
    log "Pulling changes..."

    # Check if we need to pull
    local_hash=$(git rev-parse HEAD 2> /dev/null)
    remote_hash=$(git rev-parse "origin/$current_branch" 2> /dev/null || echo "")

    if [[ -z "$remote_hash" ]]; then
      info "No remote branch found, skipping pull"
    elif [[ "$local_hash" == "$remote_hash" ]]; then
      info "Already up to date"
    else
      # Count commits behind
      commits_behind=$(git rev-list --count "HEAD..origin/$current_branch" 2> /dev/null || echo 0)

      if [[ "$commits_behind" -gt 0 ]]; then
        info "Pulling $commits_behind commit(s)..."

        if [[ -n "$force_sync" ]]; then
          git reset --hard "origin/$current_branch"
          success "Force updated to remote"
        else
          if git pull --rebase origin "$current_branch"; then
            success "Pulled $commits_behind commit(s)"
          else
            error "Pull failed - you may have conflicts"
            info "Resolve conflicts and run 'jsh sync' again"
            exit 1
          fi
        fi
      fi
    fi
  fi

  # Push changes
  if [[ -z "$pull_only" ]]; then
    echo ""
    log "Pushing changes..."

    # Check if we have commits to push
    commits_ahead=$(git rev-list --count "origin/$current_branch..HEAD" 2> /dev/null || echo 0)

    if [[ "$commits_ahead" -eq 0 ]]; then
      info "Nothing to push"
    else
      info "Pushing $commits_ahead commit(s)..."

      if git push origin "$current_branch"; then
        success "Pushed $commits_ahead commit(s)"
      else
        error "Push failed"
        info "Check your remote access and try again"
        exit 1
      fi
    fi
  fi

  # Restore stashed changes
  if [[ -n "$do_stash" && "$has_changes" == "true" ]]; then
    echo ""
    log "Restoring stashed changes..."
    if git stash pop; then
      success "Stashed changes restored"
    else
      warn "Could not restore stash - conflicts may exist"
      info "Your changes are still in the stash. Run 'git stash list' to see them."
    fi
  fi

  # Update submodules if present
  if [[ -f "${root_dir}/.gitmodules" ]]; then
    echo ""
    log "Updating submodules..."
    # Check if .git directory is writable (handles read-only mounts)
    if [[ -d "${root_dir}/.git" ]] && [[ ! -w "${root_dir}/.git" ]]; then
      warn "Git directory is read-only, skipping submodule update"
    elif git submodule update --init --recursive 2> /dev/null; then
      success "Submodules updated"
    else
      warn "Could not update submodules (read-only filesystem?)"
    fi
  fi

  echo ""
  success "Sync complete!"

  # Show current status
  echo ""
  info "Current status:"
  git log --oneline -3

}

# :command.function
jsh_profile_command() {
  # src/profile_command.sh
  # jsh profile - Show current environment profile and configuration
  #
  # Usage:
  #   jsh profile           - Show environment summary
  #   jsh profile -v        - Show detailed configuration
  #   jsh profile --json    - Output as JSON
  #
  # This command helps you understand your current jsh environment,
  # what's configured, and what's available.

  root_dir="$(get_root_dir)"
  verbose="${args[--verbose]:-}"
  json_output="${args[--json]:-}"

  # Source environment detection if available
  if [[ -f "${root_dir}/src/lib/environment.sh" ]]; then
    source "${root_dir}/src/lib/environment.sh"
  fi

  # Detect environment type
  get_env_type() {
    if declare -f get_jsh_env &> /dev/null; then
      get_jsh_env 2> /dev/null || echo "unknown"
    else
      if is_macos; then
        echo "macos"
      elif is_linux; then
        echo "linux"
      else
        echo "unknown"
      fi
    fi
  }

  # Get shell info
  get_shell_info() {
    local shell_name shell_version
    shell_name=$(basename "$SHELL")

    case "$shell_name" in
      zsh)
        shell_version=$(zsh --version 2> /dev/null | head -1 | awk '{print $2}')
        ;;
      bash)
        shell_version=$BASH_VERSION
        ;;
      *)
        shell_version="unknown"
        ;;
    esac

    echo "$shell_name $shell_version"
  }

  # Get package manager info
  get_package_manager() {
    if command -v brew &> /dev/null; then
      local brew_version
      brew_version=$(brew --version 2> /dev/null | head -1 | awk '{print $2}')
      echo "Homebrew $brew_version"
    elif command -v apt-get &> /dev/null; then
      echo "apt"
    elif command -v dnf &> /dev/null; then
      echo "dnf"
    elif command -v pacman &> /dev/null; then
      echo "pacman"
    else
      echo "unknown"
    fi
  }

  # Count installed packages
  count_packages() {
    local count=0
    if command -v brew &> /dev/null; then
      count=$(brew list --formula 2> /dev/null | wc -l | tr -d ' ')
    fi
    echo "$count"
  }

  # Get plugin status
  get_plugin_status() {
    local zinit_status="not installed"
    local tpm_status="not installed"
    local vim_plug_status="not installed"

    # Zinit
    local zinit_home="${XDG_DATA_HOME:-${HOME}/.local/share}/zinit/zinit.git"
    if [[ -d "$zinit_home" ]]; then
      local plugin_count
      plugin_count=$(find "${zinit_home%/*}" -maxdepth 2 -type d -name "*.git" 2> /dev/null | wc -l | tr -d ' ')
      zinit_status="installed ($plugin_count plugins)"
    fi

    # TPM
    local tpm_home="${HOME}/.tmux/plugins/tpm"
    if [[ -d "$tpm_home" ]]; then
      local plugin_count
      plugin_count=$(find "${HOME}/.tmux/plugins" -maxdepth 1 -type d 2> /dev/null | wc -l | tr -d ' ')
      ((plugin_count--)) # Subtract 1 for the plugins dir itself
      tpm_status="installed ($plugin_count plugins)"
    fi

    # vim-plug
    if [[ -f "${HOME}/.vim/autoload/plug.vim" ]]; then
      local plugin_count
      plugin_count=$(find "${HOME}/.vim/plugged" -maxdepth 1 -type d 2> /dev/null | wc -l | tr -d ' ')
      ((plugin_count--)) # Subtract 1 for the plugged dir itself
      vim_plug_status="installed ($plugin_count plugins)"
    fi

    echo "zinit:$zinit_status|tpm:$tpm_status|vim-plug:$vim_plug_status"
  }

  # Get jsh version
  get_jsh_version() {
    if [[ -f "${root_dir}/VERSION" ]]; then
      cat "${root_dir}/VERSION"
    else
      echo "unknown"
    fi
  }

  # Get git info
  get_git_info() {
    local branch commit dirty
    if [[ -d "${root_dir}/.git" ]]; then
      branch=$(git -C "$root_dir" rev-parse --abbrev-ref HEAD 2> /dev/null || echo "unknown")
      commit=$(git -C "$root_dir" rev-parse --short HEAD 2> /dev/null || echo "unknown")
      if git -C "$root_dir" diff --quiet HEAD 2> /dev/null; then
        dirty=""
      else
        dirty=" (modified)"
      fi
      echo "$branch@$commit$dirty"
    else
      echo "not a git repo"
    fi
  }

  # JSON output
  if [[ -n "$json_output" ]]; then
    env_type=$(get_env_type)
    shell_info=$(get_shell_info)
    pkg_manager=$(get_package_manager)
    pkg_count=$(count_packages)
    plugin_status=$(get_plugin_status)
    jsh_version=$(get_jsh_version)
    git_info=$(get_git_info)

    # Parse plugin status
    IFS='|' read -r zinit tpm vim_plug <<< "$plugin_status"

    printf '{\n'
    printf '  "version": "%s",\n' "$jsh_version"
    printf '  "environment": "%s",\n' "$env_type"
    printf '  "shell": "%s",\n' "$shell_info"
    printf '  "package_manager": "%s",\n' "$pkg_manager"
    printf '  "package_count": %s,\n' "$pkg_count"
    printf '  "jsh_root": "%s",\n' "$root_dir"
    printf '  "git": "%s",\n' "$git_info"
    printf '  "plugins": {\n'
    printf '    "zinit": "%s",\n' "${zinit#zinit:}"
    printf '    "tpm": "%s",\n' "${tpm#tpm:}"
    printf '    "vim_plug": "%s"\n' "${vim_plug#vim-plug:}"
    printf '  }\n'
    printf '}\n'
    exit 0
  fi

  # Normal output
  header "jsh Environment Profile"

  # Basic info
  echo -e "${BOLD}System${RESET}"
  printf "  %-20s %s\n" "Environment:" "$(get_env_type)"
  printf "  %-20s %s\n" "OS:" "$(uname -s) $(uname -r)"
  printf "  %-20s %s\n" "Architecture:" "$(uname -m)"
  printf "  %-20s %s\n" "Hostname:" "$(hostname)"
  echo ""

  echo -e "${BOLD}Shell${RESET}"
  printf "  %-20s %s\n" "Current Shell:" "$(get_shell_info)"
  printf "  %-20s %s\n" "SHELL:" "$SHELL"
  printf "  %-20s %s\n" "TERM:" "$TERM"
  echo ""

  echo -e "${BOLD}jsh${RESET}"
  printf "  %-20s %s\n" "Version:" "$(get_jsh_version)"
  printf "  %-20s %s\n" "Root:" "$root_dir"
  printf "  %-20s %s\n" "Git:" "$(get_git_info)"
  echo ""

  echo -e "${BOLD}Package Management${RESET}"
  printf "  %-20s %s\n" "Manager:" "$(get_package_manager)"
  printf "  %-20s %s\n" "Installed:" "$(count_packages) packages"
  echo ""

  # Plugin status
  echo -e "${BOLD}Plugins${RESET}"
  plugin_status=$(get_plugin_status)
  IFS='|' read -r zinit tpm vim_plug <<< "$plugin_status"
  printf "  %-20s %s\n" "Zinit:" "${zinit#zinit:}"
  printf "  %-20s %s\n" "TPM:" "${tpm#tpm:}"
  printf "  %-20s %s\n" "vim-plug:" "${vim_plug#vim-plug:}"
  echo ""

  # Verbose output
  if [[ -n "$verbose" ]]; then
    echo -e "${BOLD}Paths${RESET}"
    printf "  %-20s %s\n" "HOME:" "$HOME"
    printf "  %-20s %s\n" "JSH:" "${JSH:-not set}"
    printf "  %-20s %s\n" "JSH_CUSTOM:" "${JSH_CUSTOM:-not set}"
    printf "  %-20s %s\n" "XDG_CONFIG_HOME:" "${XDG_CONFIG_HOME:-not set}"
    echo ""

    echo -e "${BOLD}Key Tools${RESET}"
    tools=(git vim nvim tmux fzf zoxide brew docker kubectl)
    for tool in "${tools[@]}"; do
      if command -v "$tool" &> /dev/null; then
        version=$("$tool" --version 2> /dev/null | head -1 | cut -c1-50)
        printf "  ${GREEN}%-20s${RESET} %s\n" "$tool:" "$version"
      else
        printf "  ${RED}%-20s${RESET} %s\n" "$tool:" "not installed"
      fi
    done
    echo ""

    echo -e "${BOLD}Configuration Files${RESET}"
    dotfiles=(.bashrc .zshrc .vimrc .tmux.conf .gitconfig .inputrc)
    for dotfile in "${dotfiles[@]}"; do
      target="${HOME}/${dotfile}"
      if [[ -L "$target" ]]; then
        link_target=$(readlink "$target")
        printf "  ${GREEN}%-20s${RESET} -> %s\n" "$dotfile:" "$link_target"
      elif [[ -f "$target" ]]; then
        printf "  ${YELLOW}%-20s${RESET} %s\n" "$dotfile:" "exists (not symlinked)"
      else
        printf "  ${RED}%-20s${RESET} %s\n" "$dotfile:" "missing"
      fi
    done
    echo ""
  fi

  info "Run 'jsh profile -v' for detailed information"
  info "Run 'jsh profile --json' for machine-readable output"

}

# :command.function
jsh_plugins_command() {
  # src/plugins_command.sh
  # jsh plugins - Manage shell, vim, and tmux plugins
  #
  # Usage:
  #   jsh plugins              - List all plugin managers and their status
  #   jsh plugins list         - Same as above
  #   jsh plugins install      - Install all plugin managers and their plugins
  #   jsh plugins update       - Update all plugins
  #   jsh plugins check        - Check plugin health
  #
  # Options:
  #   --vim   - Only manage vim plugins (vim-plug)
  #   --tmux  - Only manage tmux plugins (TPM)
  #   --shell - Only manage shell plugins (zinit)

  root_dir="$(get_root_dir)"
  action="${args[action]:-list}"
  vim_only="${args[--vim]:-}"
  tmux_only="${args[--tmux]:-}"
  shell_only="${args[--shell]:-}"

  # Determine which plugin managers to operate on
  manage_all=true
  [[ -n "$vim_only" || -n "$tmux_only" || -n "$shell_only" ]] && manage_all=false

  should_manage_vim() {
    [[ "$manage_all" == "true" || -n "$vim_only" ]]
  }

  should_manage_tmux() {
    [[ "$manage_all" == "true" || -n "$tmux_only" ]]
  }

  should_manage_shell() {
    [[ "$manage_all" == "true" || -n "$shell_only" ]]
  }

  # Plugin manager paths
  ZINIT_HOME="${XDG_DATA_HOME:-${HOME}/.local/share}/zinit/zinit.git"
  TPM_HOME="${HOME}/.tmux/plugins/tpm"
  VIM_PLUG="${HOME}/.vim/autoload/plug.vim"
  VIM_PLUGGED="${HOME}/.vim/plugged"

  # List plugins
  list_plugins() {
    header "Plugin Status"

    # Zinit (zsh plugins)
    if should_manage_shell; then
      echo -e "${BOLD}Shell Plugins (Zinit)${RESET}"
      if [[ -d "$ZINIT_HOME" ]]; then
        echo -e "  ${GREEN}âœ“${RESET} Zinit installed: $ZINIT_HOME"

        # List installed plugins
        local plugins_dir="${ZINIT_HOME%/*}/plugins"
        if [[ -d "$plugins_dir" ]]; then
          local count
          count=$(find "$plugins_dir" -maxdepth 1 -type d 2> /dev/null | wc -l | tr -d ' ')
          ((count--)) # Subtract 1 for parent dir
          echo "    Plugins installed: $count"

          # List some plugins
          local i=0 plugin_name
          for plugin_dir in "$plugins_dir"/*; do
            [[ -d "$plugin_dir" ]] || continue
            plugin_name=$(basename "$plugin_dir")
            echo "    - $plugin_name"
            ((i++))
            [[ $i -ge 10 ]] && echo "    ... and more" && break
          done
        fi
      else
        echo -e "  ${RED}âœ—${RESET} Zinit not installed"
        echo "    Install with: jsh plugins install --shell"
      fi
      echo ""
    fi

    # TPM (tmux plugins)
    if should_manage_tmux; then
      echo -e "${BOLD}Tmux Plugins (TPM)${RESET}"
      if [[ -d "$TPM_HOME" ]]; then
        echo -e "  ${GREEN}âœ“${RESET} TPM installed: $TPM_HOME"

        # List installed plugins
        local plugins_dir="${HOME}/.tmux/plugins"
        if [[ -d "$plugins_dir" ]]; then
          local count
          count=$(find "$plugins_dir" -maxdepth 1 -type d 2> /dev/null | wc -l | tr -d ' ')
          ((count--)) # Subtract 1 for parent dir
          echo "    Plugins installed: $count"

          local plugin_name
          for plugin_dir in "$plugins_dir"/*; do
            [[ -d "$plugin_dir" ]] || continue
            plugin_name=$(basename "$plugin_dir")
            echo "    - $plugin_name"
          done
        fi
      else
        echo -e "  ${RED}âœ—${RESET} TPM not installed"
        echo "    Install with: jsh plugins install --tmux"
      fi
      echo ""
    fi

    # vim-plug (vim plugins)
    if should_manage_vim; then
      echo -e "${BOLD}Vim Plugins (vim-plug)${RESET}"
      if [[ -f "$VIM_PLUG" ]]; then
        echo -e "  ${GREEN}âœ“${RESET} vim-plug installed: $VIM_PLUG"

        # List installed plugins
        if [[ -d "$VIM_PLUGGED" ]]; then
          local count
          count=$(find "$VIM_PLUGGED" -maxdepth 1 -type d 2> /dev/null | wc -l | tr -d ' ')
          ((count--)) # Subtract 1 for parent dir
          echo "    Plugins installed: $count"

          local i=0 plugin_name
          for plugin_dir in "$VIM_PLUGGED"/*; do
            [[ -d "$plugin_dir" ]] || continue
            plugin_name=$(basename "$plugin_dir")
            echo "    - $plugin_name"
            ((i++))
            [[ $i -ge 15 ]] && echo "    ... and more" && break
          done
        fi
      else
        echo -e "  ${RED}âœ—${RESET} vim-plug not installed"
        echo "    Install with: jsh plugins install --vim"
      fi
      echo ""
    fi
  }

  # Install plugin managers and plugins
  install_plugins() {
    header "Installing Plugins"

    # Install Zinit
    if should_manage_shell; then
      if [[ ! -d "$ZINIT_HOME" ]]; then
        log "Installing Zinit..."
        mkdir -p "${ZINIT_HOME%/*}"
        if git_clone_https "https://github.com/zdharma-continuum/zinit.git" "$ZINIT_HOME"; then
          success "Zinit installed"
          info "Plugins will be installed on next zsh startup"
        else
          warn "Failed to install Zinit"
        fi
      else
        info "Zinit already installed"
      fi
      echo ""
    fi

    # Install TPM
    if should_manage_tmux; then
      if [[ ! -d "$TPM_HOME" ]]; then
        log "Installing TPM..."
        mkdir -p "${TPM_HOME%/*}"
        if git_clone_https "https://github.com/tmux-plugins/tpm.git" "$TPM_HOME"; then
          success "TPM installed"
          info "In tmux, press prefix + I to install plugins"
        else
          warn "Failed to install TPM"
        fi
      else
        info "TPM already installed"
        # Install tmux plugins
        log "Installing tmux plugins..."
        if [[ -x "${TPM_HOME}/bin/install_plugins" ]]; then
          "${TPM_HOME}/bin/install_plugins"
          success "Tmux plugins installed"
        fi
      fi
      echo ""
    fi

    # Install vim-plug
    if should_manage_vim; then
      if [[ ! -f "$VIM_PLUG" ]]; then
        log "Installing vim-plug..."
        if curl -fLo "$VIM_PLUG" --create-dirs \
          https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim; then
          success "vim-plug installed"
          info "Open vim and run :PlugInstall to install plugins"
        else
          warn "Failed to install vim-plug"
        fi
      else
        info "vim-plug already installed"
        # Install vim plugins
        log "Installing vim plugins..."
        if command -v vim &> /dev/null; then
          vim +PlugInstall +qall 2> /dev/null
          success "Vim plugins installed"
        fi
      fi
      echo ""
    fi

    success "Plugin installation complete"
  }

  # Update all plugins
  update_plugins() {
    header "Updating Plugins"

    # Update Zinit and plugins
    if should_manage_shell && [[ -d "$ZINIT_HOME" ]]; then
      log "Updating Zinit..."
      if command -v zsh &> /dev/null; then
        zsh -c 'source ~/.zshrc && zinit self-update' 2> /dev/null || true
        zsh -c 'source ~/.zshrc && zinit update --all' 2> /dev/null || true
        success "Zinit plugins updated"
      else
        warn "zsh not found, skipping Zinit update"
      fi
      echo ""
    fi

    # Update TPM and tmux plugins
    if should_manage_tmux && [[ -d "$TPM_HOME" ]]; then
      log "Updating TPM..."
      git_pull_https "$TPM_HOME"
      if [[ -x "${TPM_HOME}/bin/update_plugins" ]]; then
        "${TPM_HOME}/bin/update_plugins" all 2> /dev/null
        success "Tmux plugins updated"
      fi
      echo ""
    fi

    # Update vim plugins
    if should_manage_vim && [[ -f "$VIM_PLUG" ]]; then
      log "Updating vim plugins..."
      # Update vim-plug itself
      if command -v vim &> /dev/null; then
        vim +PlugUpgrade +PlugUpdate +qall 2> /dev/null
        success "Vim plugins updated"
      fi
      echo ""
    fi

    success "Plugin update complete"
  }

  # Check plugin health
  check_plugins() {
    header "Checking Plugin Health"

    local issues=0

    # Check Zinit
    if should_manage_shell; then
      echo -e "${BOLD}Zinit${RESET}"
      if [[ -d "$ZINIT_HOME" ]]; then
        # Check if zinit is valid
        if [[ -f "${ZINIT_HOME}/zinit.zsh" ]]; then
          echo -e "  ${GREEN}âœ“${RESET} Zinit installation valid"
        else
          echo -e "  ${RED}âœ—${RESET} Zinit installation corrupted"
          ((issues++))
        fi

        # Check for broken plugin symlinks
        local plugins_dir="${ZINIT_HOME%/*}/plugins"
        if [[ -d "$plugins_dir" ]]; then
          local broken
          broken=$(find "$plugins_dir" -type l ! -exec test -e {} \; -print 2> /dev/null | wc -l | tr -d ' ')
          if [[ "$broken" -gt 0 ]]; then
            echo -e "  ${YELLOW}âš ${RESET} $broken broken plugin symlink(s)"
            ((issues++))
          else
            echo -e "  ${GREEN}âœ“${RESET} All plugin symlinks valid"
          fi
        fi
      else
        echo -e "  ${YELLOW}âš ${RESET} Zinit not installed"
      fi
      echo ""
    fi

    # Check TPM
    if should_manage_tmux; then
      echo -e "${BOLD}TPM${RESET}"
      if [[ -d "$TPM_HOME" ]]; then
        if [[ -x "${TPM_HOME}/tpm" ]]; then
          echo -e "  ${GREEN}âœ“${RESET} TPM installation valid"
        else
          echo -e "  ${RED}âœ—${RESET} TPM installation corrupted"
          ((issues++))
        fi

        # Check tmux.conf for TPM initialization
        if grep -q "run.*tpm/tpm" ~/.tmux.conf 2> /dev/null; then
          echo -e "  ${GREEN}âœ“${RESET} TPM configured in tmux.conf"
        else
          echo -e "  ${YELLOW}âš ${RESET} TPM not configured in tmux.conf"
        fi
      else
        echo -e "  ${YELLOW}âš ${RESET} TPM not installed"
      fi
      echo ""
    fi

    # Check vim-plug
    if should_manage_vim; then
      echo -e "${BOLD}vim-plug${RESET}"
      if [[ -f "$VIM_PLUG" ]]; then
        echo -e "  ${GREEN}âœ“${RESET} vim-plug installation valid"

        # Check for plugin directory
        if [[ -d "$VIM_PLUGGED" ]]; then
          local broken
          broken=$(find "$VIM_PLUGGED" -maxdepth 1 -type d -empty 2> /dev/null | wc -l | tr -d ' ')
          if [[ "$broken" -gt 0 ]]; then
            echo -e "  ${YELLOW}âš ${RESET} $broken empty plugin directories"
          else
            echo -e "  ${GREEN}âœ“${RESET} All plugins have content"
          fi
        else
          echo -e "  ${YELLOW}âš ${RESET} No plugins installed"
        fi

        # Check vimrc for vim-plug initialization
        if grep -q "plug#begin" ~/.vimrc 2> /dev/null; then
          echo -e "  ${GREEN}âœ“${RESET} vim-plug configured in vimrc"
        else
          echo -e "  ${YELLOW}âš ${RESET} vim-plug not configured in vimrc"
        fi
      else
        echo -e "  ${YELLOW}âš ${RESET} vim-plug not installed"
      fi
      echo ""
    fi

    # Summary
    if [[ $issues -eq 0 ]]; then
      success "All plugin systems healthy"
    else
      warn "Found $issues issue(s)"
    fi
  }

  # Main action dispatch
  case "$action" in
    list)
      list_plugins
      ;;
    install)
      install_plugins
      ;;
    update)
      update_plugins
      ;;
    check)
      check_plugins
      ;;
    *)
      error "Unknown action: $action"
      info "Valid actions: list, install, update, check"
      exit 1
      ;;
  esac

}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --version | -v )
    version_command
    exit
    ;;

  --help | -h )
    long_usage=yes
    jsh_usage
    exit
    ;;

  esac

  # :command.command_filter
  action=${1:-}

  case $action in
  -* )
    ;;

  init )
    action="init"
    shift
    jsh_init_parse_requirements "$@"
    shift $#
    ;;

  install )
    action="install"
    shift
    jsh_install_parse_requirements "$@"
    shift $#
    ;;

  uninstall )
    action="uninstall"
    shift
    jsh_uninstall_parse_requirements "$@"
    shift $#
    ;;

  upgrade | update )
    action="upgrade"
    shift
    jsh_upgrade_parse_requirements "$@"
    shift $#
    ;;

  configure )
    action="configure"
    shift
    jsh_configure_parse_requirements "$@"
    shift $#
    ;;

  dotfiles )
    action="dotfiles"
    shift
    jsh_dotfiles_parse_requirements "$@"
    shift $#
    ;;

  clean | cleanup )
    action="clean"
    shift
    jsh_clean_parse_requirements "$@"
    shift $#
    ;;

  status )
    action="status"
    shift
    jsh_status_parse_requirements "$@"
    shift $#
    ;;

  doctor | check )
    action="doctor"
    shift
    jsh_doctor_parse_requirements "$@"
    shift $#
    ;;

  deinit )
    action="deinit"
    shift
    jsh_deinit_parse_requirements "$@"
    shift $#
    ;;

  brew )
    action="brew"
    shift
    jsh_brew_parse_requirements "$@"
    shift $#
    ;;

  completions )
    action="completions"
    shift
    jsh_completions_parse_requirements "$@"
    shift $#
    ;;

  tools )
    action="tools"
    shift
    jsh_tools_parse_requirements "$@"
    shift $#
    ;;

  sync )
    action="sync"
    shift
    jsh_sync_parse_requirements "$@"
    shift $#
    ;;

  profile | env )
    action="profile"
    shift
    jsh_profile_parse_requirements "$@"
    shift $#
    ;;

  plugins )
    action="plugins"
    shift
    jsh_plugins_parse_requirements "$@"
    shift $#
    ;;

  # :command.command_fallback
  "" )
    jsh_usage
    exit 1
    ;;

  * )
    printf "invalid command: %s\n" "$action"
    exit 1
    ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1

      ;;

    esac
  done

}

# :command.parse_requirements
jsh_init_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    jsh_init_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="init"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --non-interactive | -y )

      # :flag.case_no_arg
      args[--non-interactive]=1
      shift
      ;;

    # :flag.case
    --shell )

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then

        args[--shell]="$2"
        shift
        shift
      else
        printf "%s\n" "--shell requires an argument: --shell SHELL"
        exit 1
      fi
      ;;

    # :flag.case
    --minimal )

      # :flag.case_no_arg
      args[--minimal]=1
      shift
      ;;

    # :flag.case
    --full )

      # :flag.case_no_arg
      args[--full]=1
      shift
      ;;

    # :flag.case
    --setup )

      # :flag.case_no_arg
      args[--setup]=1
      shift
      ;;

    # :flag.case
    --no-install )

      # :flag.case_no_arg
      args[--no-install]=1
      shift
      ;;

    # :flag.case
    --skip-brew )

      # :flag.case_no_arg
      args[--skip-brew]=1
      shift
      ;;

    # :flag.case
    --dry-run )

      # :flag.case_no_arg
      args[--dry-run]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1

      ;;

    esac
  done

}

# :command.parse_requirements
jsh_install_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    jsh_install_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="install"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --brew )

      # :flag.case_no_arg
      args[--brew]=1
      shift
      ;;

    # :flag.case
    --gem )

      # :flag.case_no_arg
      args[--gem]=1
      shift
      ;;

    # :flag.case
    --bun )

      # :flag.case_no_arg
      args[--bun]=1
      shift
      ;;

    # :flag.case
    --npm )

      # :flag.case_no_arg
      args[--npm]=1
      shift
      ;;

    # :flag.case
    --pip )

      # :flag.case_no_arg
      args[--pip]=1
      shift
      ;;

    # :flag.case
    --cargo )

      # :flag.case_no_arg
      args[--cargo]=1
      shift
      ;;

    # :flag.case
    --apt )

      # :flag.case_no_arg
      args[--apt]=1
      shift
      ;;

    # :flag.case
    --dnf )

      # :flag.case_no_arg
      args[--dnf]=1
      shift
      ;;

    # :flag.case
    --pacman )

      # :flag.case_no_arg
      args[--pacman]=1
      shift
      ;;

    # :flag.case
    --yum )

      # :flag.case_no_arg
      args[--yum]=1
      shift
      ;;

    # :flag.case
    --zypper )

      # :flag.case_no_arg
      args[--zypper]=1
      shift
      ;;

    # :flag.case
    --no-progress )

      # :flag.case_no_arg
      args[--no-progress]=1
      shift
      ;;

    # :flag.case
    --quiet | -q )

      # :flag.case_no_arg
      args[--quiet]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      if [[ -z ${args[package]+x} ]]; then

        args[package]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi

      ;;

    esac
  done

}

# :command.parse_requirements
jsh_uninstall_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    jsh_uninstall_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="uninstall"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      if [[ -z ${args[package]+x} ]]; then

        args[package]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi

      ;;

    esac
  done
  # :command.required_args_filter
  if [[ -z ${args[package]+x} ]]; then
    printf "missing required argument: PACKAGE\nusage: jsh uninstall PACKAGE\n"
    exit 1
  fi

}

# :command.parse_requirements
jsh_upgrade_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    jsh_upgrade_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="upgrade"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --no-progress )

      # :flag.case_no_arg
      args[--no-progress]=1
      shift
      ;;

    # :flag.case
    --quiet | -q )

      # :flag.case_no_arg
      args[--quiet]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1

      ;;

    esac
  done

}

# :command.parse_requirements
jsh_configure_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    jsh_configure_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="configure"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1

      ;;

    esac
  done

}

# :command.parse_requirements
jsh_dotfiles_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    jsh_dotfiles_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="dotfiles"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --status | -s )

      # :flag.case_no_arg
      args[--status]=1
      shift
      ;;

    # :flag.case
    --remove | -d )

      # :flag.case_no_arg
      args[--remove]=1
      shift
      ;;

    # :flag.case
    --non-interactive | -y )

      # :flag.case_no_arg
      args[--non-interactive]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1

      ;;

    esac
  done

}

# :command.parse_requirements
jsh_clean_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    jsh_clean_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="clean"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1

      ;;

    esac
  done

}

# :command.parse_requirements
jsh_status_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    jsh_status_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="status"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1

      ;;

    esac
  done

}

# :command.parse_requirements
jsh_doctor_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    jsh_doctor_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="doctor"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1

      ;;

    esac
  done

}

# :command.parse_requirements
jsh_deinit_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    jsh_deinit_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="deinit"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1

      ;;

    esac
  done

}

# :command.parse_requirements
jsh_brew_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    jsh_brew_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="brew"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --quiet | -q )

      # :flag.case_no_arg
      args[--quiet]=1
      shift
      ;;

    # :flag.case
    --force | -f )

      # :flag.case_no_arg
      args[--force]=1
      shift
      ;;

    -?* )
      other_args+=("$1")
      shift
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_catch_all
      if [[ -z ${args[subcommand]+x} ]]; then

        args[subcommand]=$1
        shift
      else
        other_args+=("$1")
        shift
      fi

      ;;

    esac
  done

}

# :command.parse_requirements
jsh_completions_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    jsh_completions_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="completions"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --install | -i )

      # :flag.case_no_arg
      args[--install]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1

      ;;

    esac
  done

}

# :command.parse_requirements
jsh_tools_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    jsh_tools_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="tools"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --missing | -m )

      # :flag.case_no_arg
      args[--missing]=1
      shift
      ;;

    # :flag.case
    --category | -c )

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then

        args[--category]="$2"
        shift
        shift
      else
        printf "%s\n" "--category requires an argument: --category, -c CATEGORY"
        exit 1
      fi
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      if [[ -z ${args[action]+x} ]]; then

        args[action]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi

      ;;

    esac
  done

  # :command.default_assignments
  [[ -n ${args[action]:-} ]] || args[action]="list"

}

# :command.parse_requirements
jsh_sync_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    jsh_sync_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="sync"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --pull | -p )

      # :flag.case_no_arg
      args[--pull]=1
      shift
      ;;

    # :flag.case
    --push | -P )

      # :flag.case_no_arg
      args[--push]=1
      shift
      ;;

    # :flag.case
    --stash | -s )

      # :flag.case_no_arg
      args[--stash]=1
      shift
      ;;

    # :flag.case
    --force | -f )

      # :flag.case_no_arg
      args[--force]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1

      ;;

    esac
  done

}

# :command.parse_requirements
jsh_profile_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    jsh_profile_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="profile"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --verbose | -v )

      # :flag.case_no_arg
      args[--verbose]=1
      shift
      ;;

    # :flag.case
    --json )

      # :flag.case_no_arg
      args[--json]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1

      ;;

    esac
  done

}

# :command.parse_requirements
jsh_plugins_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    jsh_plugins_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="plugins"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --vim )

      # :flag.case_no_arg
      args[--vim]=1
      shift
      ;;

    # :flag.case
    --tmux )

      # :flag.case_no_arg
      args[--tmux]=1
      shift
      ;;

    # :flag.case
    --shell )

      # :flag.case_no_arg
      args[--shell]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      if [[ -z ${args[action]+x} ]]; then

        args[action]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi

      ;;

    esac
  done

  # :command.default_assignments
  [[ -n ${args[action]:-} ]] || args[action]="list"

}

# :command.initialize
initialize() {
  version="0.1.0"
  long_usage=''
  set -e

  # src/initialize.sh
  # Load environment variables from .env file if it exists
  root_dir="${JSH_ROOT:-$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)}"
  env_file="${root_dir}/.env"

  if [[ -f "$env_file" ]]; then
    # Source the .env file to load BREW_USER and other environment variables
    # Only export variables that are defined in the file
    while IFS='=' read -r key value; do
      # Skip comments and empty lines
      [[ "$key" =~ ^[[:space:]]*# ]] && continue
      [[ -z "$key" ]] && continue

      # Remove leading/trailing whitespace
      key=$(echo "$key" | xargs)
      value=$(echo "$value" | xargs)

      # Export the variable
      export "$key=$value"
    done < "$env_file"
  fi

}

# :command.run
run() {
  declare -A args=()
  declare -a other_args=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"

  if [[ $action == "init" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      jsh_init_usage
    else
      jsh_init_command
    fi

  elif [[ $action == "install" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      jsh_install_usage
    else
      jsh_install_command
    fi

  elif [[ $action == "uninstall" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      jsh_uninstall_usage
    else
      jsh_uninstall_command
    fi

  elif [[ $action == "upgrade" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      jsh_upgrade_usage
    else
      jsh_upgrade_command
    fi

  elif [[ $action == "configure" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      jsh_configure_usage
    else
      jsh_configure_command
    fi

  elif [[ $action == "dotfiles" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      jsh_dotfiles_usage
    else
      jsh_dotfiles_command
    fi

  elif [[ $action == "clean" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      jsh_clean_usage
    else
      jsh_clean_command
    fi

  elif [[ $action == "status" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      jsh_status_usage
    else
      jsh_status_command
    fi

  elif [[ $action == "doctor" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      jsh_doctor_usage
    else
      jsh_doctor_command
    fi

  elif [[ $action == "deinit" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      jsh_deinit_usage
    else
      jsh_deinit_command
    fi

  elif [[ $action == "brew" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      jsh_brew_usage
    else
      jsh_brew_command
    fi

  elif [[ $action == "completions" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      jsh_completions_usage
    else
      jsh_completions_command
    fi

  elif [[ $action == "tools" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      jsh_tools_usage
    else
      jsh_tools_command
    fi

  elif [[ $action == "sync" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      jsh_sync_usage
    else
      jsh_sync_command
    fi

  elif [[ $action == "profile" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      jsh_profile_usage
    else
      jsh_profile_command
    fi

  elif [[ $action == "plugins" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      jsh_plugins_usage
    else
      jsh_plugins_command
    fi

  elif [[ $action == "root" ]]; then
    root_command
  fi
}

initialize
run "$@"
