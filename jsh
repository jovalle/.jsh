#!/usr/bin/env bash
# This script was generated by bashly 1.3.5 (https://bashly.dev)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if ((BASH_VERSINFO[0] < 4 || (BASH_VERSINFO[0] == 4 && BASH_VERSINFO[1] < 2))); then
  printf "bash version 4.2 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
jsh_usage() {
  printf "jsh - Dotfiles and environment management utility\n\n"

  printf "%s\n" "Usage:"
  printf "  jsh COMMAND\n"
  printf "  jsh [COMMAND] --help | -h\n"
  printf "  jsh --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Set up shell environment\n" "init       "
  printf "  %s   Install packages\n" "install    "
  printf "  %s   Uninstall a package and remove from config\n" "uninstall  "
  printf "  %s   Upgrade all packages (brew, zinit, system)\n" "upgrade    "
  printf "  %s   Apply dotfiles, OS settings, and app configs\n" "configure  "
  printf "  %s   Manage dotfile symlinks\n" "dotfiles   "
  printf "  %s   Remove caches, temp files, old Homebrew versions\n" "clean      "
  printf "  %s   Show brew packages, services, symlinks, git status\n" "status     "
  printf "  %s   Check for missing tools, broken symlinks, repo issues\n" "doctor     "
  printf "  %s   Remove jsh symlinks and restore backups\n" "deinit     "
  printf "  %s   Homebrew wrapper (handles root delegation)\n" "brew       "
  printf "  %s   Generate shell completion script\n" "completions"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

    # :command.usage_environment_variables
    printf "%s\n" "Environment Variables:"

    # :environment_variable.usage
    printf "  %s\n" "JSH_ROOT"
    printf "    Path to jsh repository root\n"
    echo

    # :environment_variable.usage
    printf "  %s\n" "BREW_USER"
    printf "    User to run Homebrew commands as (when running as root)\n"
    echo

  fi
}

# :command.usage
jsh_init_usage() {
  printf "jsh init - Set up shell environment\n\n"

  printf "%s\n" "Usage:"
  printf "  jsh init [OPTIONS]\n"
  printf "  jsh init --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--non-interactive, -y"
    printf "    Use defaults (zsh + full)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--shell SHELL"
    printf "    Pre-select shell: zsh, bash, or skip\n"
    echo

    # :flag.usage
    printf "  %s\n" "--minimal"
    printf "    Lightweight setup, no plugins\n"
    echo

    # :flag.usage
    printf "  %s\n" "--full"
    printf "    Full setup with themes, plugins, completions\n"
    echo

    # :flag.usage
    printf "  %s\n" "--setup"
    printf "    Also run install + configure after init\n"
    echo

    # :flag.usage
    printf "  %s\n" "--no-install"
    printf "    Skip package installation\n"
    echo

    # :flag.usage
    printf "  %s\n" "--skip-brew"
    printf "    Skip Homebrew installation\n"
    echo

    # :flag.usage
    printf "  %s\n" "--dry-run"
    printf "    Preview changes without applying\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
jsh_install_usage() {
  printf "jsh install - Install packages\n\n"

  printf "%s\n" "Usage:"
  printf "  jsh install [PACKAGE] [OPTIONS]\n"
  printf "  jsh install --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--brew"
    printf "    Install via Homebrew/Linuxbrew\n"
    echo

    # :flag.usage
    printf "  %s\n" "--gem"
    printf "    Install via Ruby gem\n"
    echo

    # :flag.usage
    printf "  %s\n" "--bun"
    printf "    Install via bun (JavaScript runtime)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--npm"
    printf "    Install via npm (Node.js)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--pip"
    printf "    Install via pip (Python)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--cargo"
    printf "    Install via cargo (Rust)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--apt"
    printf "    Install via apt (Debian/Ubuntu)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--dnf"
    printf "    Install via dnf (Fedora/RHEL)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--pacman"
    printf "    Install via pacman (Arch Linux)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--yum"
    printf "    Install via yum (CentOS/RHEL)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--zypper"
    printf "    Install via zypper (openSUSE)\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "PACKAGE"
    printf "    Package to install (omit to install all from config)\n"
    echo

  fi
}

# :command.usage
jsh_uninstall_usage() {
  printf "jsh uninstall - Uninstall a package and remove from config\n\n"

  printf "%s\n" "Usage:"
  printf "  jsh uninstall PACKAGE\n"
  printf "  jsh uninstall --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "PACKAGE"
    printf "    Package to uninstall\n"
    echo

  fi
}

# :command.usage
jsh_upgrade_usage() {
  printf "jsh upgrade - Upgrade all packages (brew, zinit, system)\n\n"
  printf "Alias: update\n"
  echo

  printf "%s\n" "Usage:"
  printf "  jsh upgrade\n"
  printf "  jsh upgrade --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
jsh_configure_usage() {
  printf "jsh configure - Apply dotfiles, OS settings, and app configs\n\n"

  printf "%s\n" "Usage:"
  printf "  jsh configure\n"
  printf "  jsh configure --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
jsh_dotfiles_usage() {
  printf "jsh dotfiles - Manage dotfile symlinks\n\n"

  printf "%s\n" "Usage:"
  printf "  jsh dotfiles [OPTIONS]\n"
  printf "  jsh dotfiles --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--status, -s"
    printf "    Show current symlink status\n"
    echo

    # :flag.usage
    printf "  %s\n" "--remove, -d"
    printf "    Remove dotfile symlinks\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
jsh_clean_usage() {
  printf "jsh clean - Remove caches, temp files, old Homebrew versions\n\n"
  printf "Alias: cleanup\n"
  echo

  printf "%s\n" "Usage:"
  printf "  jsh clean\n"
  printf "  jsh clean --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
jsh_status_usage() {
  printf "jsh status - Show brew packages, services, symlinks, git status\n\n"

  printf "%s\n" "Usage:"
  printf "  jsh status\n"
  printf "  jsh status --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
jsh_doctor_usage() {
  printf "jsh doctor - Check for missing tools, broken symlinks, repo issues\n\n"
  printf "Alias: check\n"
  echo

  printf "%s\n" "Usage:"
  printf "  jsh doctor\n"
  printf "  jsh doctor --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
jsh_deinit_usage() {
  printf "jsh deinit - Remove jsh symlinks and restore backups\n\n"

  printf "%s\n" "Usage:"
  printf "  jsh deinit\n"
  printf "  jsh deinit --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
jsh_brew_usage() {
  printf "jsh brew - Homebrew wrapper (handles root delegation)\n\n"

  printf "%s\n" "Usage:"
  printf "  jsh brew [SUBCOMMAND] [OPTIONS] [--] [BREW_ARGS...]\n"
  printf "  jsh brew --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--quiet, -q"
    printf "    Silent mode (for check command)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--force, -f"
    printf "    Force check even if run recently\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SUBCOMMAND"
    printf "    Brew subcommand: setup, check, or any brew command\n"
    echo

    echo "  BREW_ARGS..."
    printf "    All arguments to pass through to brew\n"
    echo

  fi
}

# :command.usage
jsh_completions_usage() {
  printf "jsh completions - Generate shell completion script\n\n"

  printf "%s\n" "Usage:"
  printf "  jsh completions [OPTIONS]\n"
  printf "  jsh completions --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--install, -i"
    printf "    Install completions to shell config\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.normalize_input
# :command.normalize_input_function
normalize_input() {
  local arg passthru flags
  passthru=false

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $passthru == true ]]; then
      input+=("$arg")
    elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    elif [[ "$arg" == "--" ]]; then
      passthru=true
      input+=("$arg")
    else
      input+=("$arg")
    fi

    shift
  done
}

# :command.inspect_args
inspect_args() {
  local k

  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do
      echo "- \${args[$k]} = ${args[$k]}"
    done
  else
    echo args: none
  fi

  if ((${#other_args[@]})); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for k in "${!other_args[@]}"; do
      echo "- \${other_args[$k]} = ${other_args[$k]}"
    done
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do
      echo "- \${deps[$k]} = ${deps[$k]}"
    done
  fi

  if ((${#env_var_names[@]})); then
    readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)
    echo
    echo "environment variables:"
    for k in "${sorted_names[@]}"; do
      echo "- \$$k = ${!k:-}"
    done
  fi
}

# :command.user_lib
# src/lib/brew.sh
# Homebrew management functions for jsh

# Default brew user if not configured
BREW_USER="${BREW_USER:-}"

# ============================================================================
# Core Helper Functions
# ============================================================================

is_root() { [[ "${EUID:-$(id -u)}" -eq 0 ]]; }

check_brew() {
  if ! command -v brew &> /dev/null; then
    warn "Homebrew not found. Skipping brew-related tasks."
    return 1
  fi
  return 0
}

apply_brew_shellenv() {
  local brew_bin="$1"
  [[ -n "${brew_bin}" && -x "${brew_bin}" ]] || return 1

  local brew_env
  if brew_env="$("${brew_bin}" shellenv)"; then
    eval "${brew_env}"
    return 0
  fi
  return 1
}

# Check if a user exists on the system
user_exists() {
  local username="$1"
  if is_macos; then
    dscl . -read "/Users/${username}" &> /dev/null
  else
    id "${username}" &> /dev/null
  fi
}

# Load BREW_USER from .env if available
load_brew_user() {
  local root_dir
  root_dir="$(get_root_dir)"
  local env_file="${root_dir}/.env"
  if [[ -f "${env_file}" ]]; then
    # Source the env file to get BREW_USER
    # shellcheck source=/dev/null
    source "${env_file}"
  fi
  export BREW_USER="${BREW_USER:-}"
}

# Check if user is in admin/sudo group (idempotent check)
user_in_admin_group() {
  local username="$1"
  if is_macos; then
    dseditgroup -o checkmember -m "${username}" admin &> /dev/null
  else
    if getent group sudo &> /dev/null; then
      id -nG "${username}" 2>/dev/null | grep -qw sudo
    elif getent group wheel &> /dev/null; then
      id -nG "${username}" 2>/dev/null | grep -qw wheel
    else
      return 1
    fi
  fi
}

# Detect OS and set Homebrew path
detect_brew_path() {
  if is_macos; then
    # macOS - check both Apple Silicon and Intel paths
    if [[ -d "/opt/homebrew" ]]; then
      echo "/opt/homebrew"
    elif [[ -d "/usr/local/Homebrew" ]]; then
      echo "/usr/local"
    else
      echo ""
    fi
  elif is_linux || grep -qi microsoft /proc/version 2> /dev/null; then
    # Linux or WSL
    if [[ -d "/home/linuxbrew/.linuxbrew" ]]; then
      echo "/home/linuxbrew/.linuxbrew"
    else
      echo ""
    fi
  else
    echo ""
  fi
}

# Run a command as the brew user (for root delegation)
run_as_brew_user() {
  local brew_user="${BREW_USER:-}"

  if [[ -z "${brew_user}" ]]; then
    error "BREW_USER is not configured. Run 'jsh init' to set up brew delegation."
  fi

  if ! user_exists "${brew_user}"; then
    error "Brew user '${brew_user}' does not exist."
  fi

  local brew_user_home
  brew_user_home=$(eval echo "~${brew_user}")
  sudo -u "${brew_user}" bash -c "cd '${brew_user_home}' && \"\$@\"" -- "$@"
}

# Prompt for and create a standard user for brew delegation
# Args: default_user, non_interactive (true/false)
# Note: This function outputs the username to stdout for capture.
#       All info/status messages go to stderr to avoid corrupting the output.
create_brew_user() {
  local default_user="${1:-jay}"
  local non_interactive="${2:-false}"
  local username

  # In non-interactive mode, use default user directly
  if [[ "${non_interactive}" == "true" ]]; then
    username="${default_user}"
    info "Non-interactive mode: using user '${username}' for brew operations." >&2
  else
    echo "" >&2
    warn "Homebrew cannot be run as root." >&2
    info "A standard (non-root) user is required to install and manage Homebrew." >&2
    echo "" >&2

    # Prompt for username
    read -r -p "Enter username for brew operations [${default_user}]: " username
    username="${username:-${default_user}}"
  fi

  # Validate username
  if [[ ! "${username}" =~ ^[a-z_][a-z0-9_-]*$ ]]; then
    error "Invalid username. Use lowercase letters, numbers, underscores, and hyphens."
    return 1
  fi

  # Check if user already exists (idempotent)
  if user_exists "${username}"; then
    info "User '${username}' already exists." >&2

    # Ensure user is in admin/sudo group (idempotent)
    if ! user_in_admin_group "${username}"; then
      info "Adding '${username}' to admin/sudo group..." >&2
      if is_macos; then
        sudo dseditgroup -o edit -a "${username}" -t user admin 2>/dev/null || true
      else
        if getent group sudo &> /dev/null; then
          sudo usermod -aG sudo "${username}" 2>/dev/null || true
        elif getent group wheel &> /dev/null; then
          sudo usermod -aG wheel "${username}" 2>/dev/null || true
        fi
      fi
    fi

    if [[ "${non_interactive}" == "true" ]]; then
      echo "${username}"
      return 0
    fi

    if confirm "Use '${username}' for brew operations?"; then
      echo "${username}"
      return 0
    else
      return 1
    fi
  fi

  # Create the user
  info "Creating user '${username}'..." >&2

  if is_macos; then
    # macOS user creation
    local max_id
    max_id=$(dscl . -list /Users UniqueID | awk '{print $2}' | sort -n | tail -1)
    local new_id=$((max_id + 1))

    sudo dscl . -create "/Users/${username}"
    sudo dscl . -create "/Users/${username}" UserShell /bin/zsh
    sudo dscl . -create "/Users/${username}" RealName "${username}"
    sudo dscl . -create "/Users/${username}" UniqueID "${new_id}"
    sudo dscl . -create "/Users/${username}" PrimaryGroupID 20
    sudo dscl . -create "/Users/${username}" NFSHomeDirectory "/Users/${username}"

    sudo mkdir -p "/Users/${username}"
    sudo chown "${username}:staff" "/Users/${username}"

    # Set password (skip in non-interactive mode)
    if [[ "${non_interactive}" != "true" ]]; then
      info "Setting password for ${username}..." >&2
      sudo dscl . -passwd "/Users/${username}"
    else
      info "Skipping password setup in non-interactive mode." >&2
      info "Set password later with: sudo dscl . -passwd /Users/${username}" >&2
    fi

    # Add to admin group (idempotent)
    sudo dseditgroup -o edit -a "${username}" -t user admin 2>/dev/null || true
  else
    # Linux user creation
    if command -v useradd &> /dev/null; then
      sudo useradd -m -s /bin/bash "${username}"
    elif command -v adduser &> /dev/null; then
      sudo adduser --disabled-password --gecos "" "${username}"
    else
      error "No supported user creation tool found (useradd or adduser)"
      return 1
    fi

    # Set password (skip in non-interactive mode)
    if [[ "${non_interactive}" != "true" ]]; then
      info "Setting password for ${username}..." >&2
      sudo passwd "${username}"
    else
      info "Skipping password setup in non-interactive mode." >&2
      info "Set password later with: sudo passwd ${username}" >&2
    fi

    # Add to sudo/wheel group (idempotent)
    if getent group sudo &> /dev/null; then
      sudo usermod -aG sudo "${username}" 2>/dev/null || true
    elif getent group wheel &> /dev/null; then
      sudo usermod -aG wheel "${username}" 2>/dev/null || true
    fi
  fi

  if user_exists "${username}"; then
    success "User '${username}' created successfully." >&2
    echo "${username}"
    return 0
  else
    error "Failed to create user '${username}'"
    return 1
  fi
}

# Configure brew user delegation and save to .env
configure_brew_delegation() {
  local brew_user="$1"
  local root_dir
  root_dir="$(get_root_dir)"
  local env_file="${root_dir}/.env"

  if [[ -z "${brew_user}" ]]; then
    error "No brew user specified for delegation"
    return 1
  fi

  if [[ -f "${env_file}" ]]; then
    if grep -q "^BREW_USER=" "${env_file}"; then
      if is_macos; then
        sed -i '' "s/^BREW_USER=.*/BREW_USER=${brew_user}/" "${env_file}"
      else
        sed -i "s/^BREW_USER=.*/BREW_USER=${brew_user}/" "${env_file}"
      fi
    else
      echo "BREW_USER=${brew_user}" >> "${env_file}"
    fi
  else
    echo "BREW_USER=${brew_user}" > "${env_file}"
  fi

  export BREW_USER="${brew_user}"
  success "Brew delegation configured for user: ${brew_user}"
}

confirm() {
  local prompt="$1"
  local response
  read -r -n 1 -p "${prompt} (y/N): " response
  echo # Add newline after single character input
  case "${response}" in
    y | Y)
      return 0
      ;;
    *)
      return 1
      ;;
  esac
}

# ============================================================================
# Setup Command
# ============================================================================

brew_setup() {
  # Load any existing BREW_USER configuration
  load_brew_user

  # Handle root user - need to delegate to a standard user
  if is_root; then
    warn "Running as root. Homebrew must be installed as a non-root user."
    echo ""

    # Check if BREW_USER is already configured and user exists
    if [[ -n "${BREW_USER:-}" ]] && user_exists "${BREW_USER}"; then
      info "Using configured brew user: ${BREW_USER}"
      # Ensure user is in admin group (idempotent)
      if ! user_in_admin_group "${BREW_USER}"; then
        info "Ensuring '${BREW_USER}' has admin/sudo access..."
        if is_macos; then
          sudo dseditgroup -o edit -a "${BREW_USER}" -t user admin 2>/dev/null || true
        else
          if getent group sudo &> /dev/null; then
            sudo usermod -aG sudo "${BREW_USER}" 2>/dev/null || true
          elif getent group wheel &> /dev/null; then
            sudo usermod -aG wheel "${BREW_USER}" 2>/dev/null || true
          fi
        fi
      fi
    elif [[ -n "${BREW_USER:-}" ]]; then
      # BREW_USER is set but user doesn't exist - create it (non-interactive)
      info "BREW_USER='${BREW_USER}' is configured but user does not exist."
      local brew_user
      brew_user=$(create_brew_user "${BREW_USER}" "true")
      if [[ -z "${brew_user}" ]]; then
        error "Failed to create configured brew user."
        return 1
      fi
      configure_brew_delegation "${brew_user}"
    else
      # Need to set up brew user delegation interactively
      if ! confirm "Would you like to configure a user for brew operations?"; then
        warn "Skipping brew setup. Homebrew requires a non-root user."
        return 1
      fi

      local brew_user
      brew_user=$(create_brew_user "jay" "false")

      if [[ -z "${brew_user}" ]]; then
        error "Brew user setup cancelled."
        return 1
      fi

      configure_brew_delegation "${brew_user}"
    fi

    # Check if brew is already installed
    local BREW_PREFIX
    BREW_PREFIX=$(detect_brew_path)

    if [[ -n "${BREW_PREFIX}" ]]; then
      success "Homebrew is already installed at: ${BREW_PREFIX}"
      info "Brew commands will be delegated to user: ${BREW_USER}"
      return 0
    fi

    # Install Homebrew as the brew user
    info "Installing Homebrew as user: ${BREW_USER}"
    echo ""

    # Prepare the linuxbrew directory with proper ownership
    if is_linux || grep -qi microsoft /proc/version 2> /dev/null; then
      if [[ ! -d "/home/linuxbrew" ]]; then
        info "Creating /home/linuxbrew directory..."
        mkdir -p /home/linuxbrew/.linuxbrew
        chown -R "${BREW_USER}:${BREW_USER}" /home/linuxbrew
      elif [[ ! -w "/home/linuxbrew/.linuxbrew" ]] || [[ "$(stat -c '%U' /home/linuxbrew 2>/dev/null)" != "${BREW_USER}" ]]; then
        info "Fixing ownership of /home/linuxbrew..."
        chown -R "${BREW_USER}:${BREW_USER}" /home/linuxbrew
      fi
    fi

    local install_script
    install_script="$(mktemp)"
    chmod 644 "${install_script}"

    if curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh -o "${install_script}"; then
      if sudo -u "${BREW_USER}" NONINTERACTIVE=1 /bin/bash "${install_script}"; then
        rm -f "${install_script}"
        success "Homebrew installed successfully for user: ${BREW_USER}"
        info ""
        info "To use brew commands as root, use: jsh brew <command>"
        info "The BREW_USER setting is saved in $(get_root_dir)/.env"
        return 0
      else
        rm -f "${install_script}"
        error "Failed to install Homebrew as user: ${BREW_USER}"
        return 1
      fi
    else
      error "Failed to download Homebrew install script."
      return 1
    fi
  fi

  # Non-root path - original behavior
  local BREW_PREFIX
  BREW_PREFIX=$(detect_brew_path)

  if [[ -n "${BREW_PREFIX}" ]]; then
    success "Homebrew is already installed at: ${BREW_PREFIX}"
    info "Configuring environment..."

    if apply_brew_shellenv "${BREW_PREFIX}/bin/brew"; then
      success "Homebrew environment configured"
      return 0
    else
      warn "Failed to configure Homebrew environment"
      return 1
    fi
  fi

  # Check for sudo access before attempting installation
  if ! sudo -n true 2> /dev/null; then
    error "Homebrew installation requires sudo access"
    info "Please ensure you have sudo permissions, or use an alternative installation method:"
    info "https://docs.brew.sh/Installation#alternative-installs"
    return 1
  fi

  info "Installing Homebrew/Linuxbrew..."
  echo ""

  # Run official install script
  /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"

  # Try to apply environment after installation
  BREW_PREFIX=$(detect_brew_path)
  if [[ -n "${BREW_PREFIX}" ]]; then
    if apply_brew_shellenv "${BREW_PREFIX}/bin/brew"; then
      success "Homebrew installation and configuration complete!"
      return 0
    fi
  fi

  warn "Homebrew installation complete, but environment could not be configured automatically"
  info "Please follow the instructions above to add Homebrew to your PATH"
  return 1
}

# ============================================================================
# Check Command - Helper Functions
# ============================================================================

# Extract package names from JSON config files
extract_packages_from_json() {
  local file="$1"
  if [[ ! -f "${file}" ]]; then
    echo ""
    return
  fi
  jq -r '.packages[]? // empty' "${file}" 2>/dev/null | sort -u
}

# Check if a package is available in Homebrew API
check_package_in_api() {
  local pkg="$1"
  local pkg_type="$2" # "formula" or "cask"

  local api_url=""
  if [[ "${pkg_type}" == "cask" ]]; then
    api_url="https://formulae.brew.sh/api/cask/${pkg}.json"
  else
    api_url="https://formulae.brew.sh/api/formula/${pkg}.json"
  fi

  # Use curl to check if the package exists in the API
  if curl -sf "${api_url}" &> /dev/null; then
    return 0
  else
    return 1
  fi
}

# Check if a package exists locally
check_package_locally() {
  local pkg="$1"
  local pkg_type="$2" # "formula" or "cask"

  if [[ "${pkg_type}" == "cask" ]]; then
    brew info --cask "${pkg}" &> /dev/null
    return $?
  else
    brew info --formula "${pkg}" &> /dev/null
    return $?
  fi
}

# Validate a specific package exists
validate_package() {
  local pkg="$1"
  local forced_platform="${2:-}" # Optional forced platform: 'linux' or 'darwin'

  info "Checking package: ${pkg}"

  # Determine which platform to check against
  local check_platform="${forced_platform}"
  if [[ -z "${check_platform}" ]]; then
    if is_macos; then
      check_platform="darwin"
    else
      check_platform="linux"
    fi
  fi

  # Try as formula first
  if check_package_locally "${pkg}" "formula"; then
    # On Linux, check if the formula has macOS-only requirements
    if [[ "${check_platform}" == "linux" ]]; then
      # Get the formula info and check for platform requirements
      local brew_info
      brew_info=$(brew info --formula "${pkg}" 2>&1 || echo "")

      if echo "${brew_info}" | grep -q "Required: macOS"; then
        error "Package '${pkg}' is not supported on Linux (macOS-only package)"
        return 1
      fi
    fi

    success "Package '${pkg}' is available as a formula"
    return 0
  fi

  # Try as cask on macOS
  if [[ "${check_platform}" == "darwin" ]]; then
    if check_package_locally "${pkg}" "cask"; then
      success "Package '${pkg}' is available as a cask"
      return 0
    fi
  fi

  # Check API with platform validation
  if check_package_in_api "${pkg}" "formula"; then
    # For Linux, double-check via API metadata
    if is_linux || grep -qi microsoft /proc/version 2> /dev/null; then
      # Fetch API metadata to check platform support
      local api_response
      api_response=$(curl -sf "https://formulae.brew.sh/api/formula/${pkg}.json" 2> /dev/null || echo "")

      if [[ -n "${api_response}" ]]; then
        # Check if the package has platform requirements
        local platforms
        platforms=$(echo "${api_response}" | jq -r '.platform | keys[]' 2> /dev/null || echo "")

        if [[ -n "${platforms}" ]]; then
          # If platform info exists, check if linux is in it
          if echo "${platforms}" | grep -q "linux"; then
            success "Package '${pkg}' exists in Homebrew repository and supports Linux"
            return 0
          else
            error "Package '${pkg}' is not supported on Linux (Darwin-only package)"
            return 1
          fi
        else
          # No platform info, assume it's cross-platform
          success "Package '${pkg}' exists in Homebrew repository"
          return 0
        fi
      fi
    else
      success "Package '${pkg}' exists in Homebrew repository"
      return 0
    fi
  fi

  if is_macos && check_package_in_api "${pkg}" "cask"; then
    success "Package '${pkg}' exists as a cask in Homebrew repository"
    return 0
  fi

  error "Package '${pkg}' not found in Homebrew repository"
  return 1
}

# Comprehensive check: outdated packages, invalid packages, unsupported platform packages
comprehensive_check() {
  local forced_platform="${1:-}"  # Optional forced platform: 'linux' or 'darwin'
  local quiet_mode="${2:-false}"  # Optional quiet mode
  local force_check="${3:-false}" # Optional force check
  local root_dir
  root_dir="$(get_root_dir)"

  local marker_file="${root_dir}/.brewcheck"

  if [[ "${force_check}" != "true" ]] && [[ -f "${marker_file}" ]]; then
    # Check if file is less than 24 hours old
    if [[ -n $(find "${marker_file}" -mtime -1 2> /dev/null) ]]; then
      if [[ "${quiet_mode}" != "true" ]]; then
        # Calculate relative time
        local now file_time elapsed_secs
        now=$(date +%s)
        if is_macos; then
          file_time=$(stat -f %m "${marker_file}")
        else
          file_time=$(stat -c %Y "${marker_file}")
        fi
        elapsed_secs=$((now - file_time))

        local time_ago
        if [[ ${elapsed_secs} -lt 60 ]]; then
          time_ago="just now"
        elif [[ ${elapsed_secs} -lt 3600 ]]; then
          time_ago="$((elapsed_secs / 60))m ago"
        else
          time_ago="$((elapsed_secs / 3600))h ago"
        fi
        info "â³ Brew check ran ${time_ago}. Skipping... (use --force to override)"
      fi
      return 0
    fi
  fi

  if [[ "${quiet_mode}" != "true" ]]; then
    info "ðŸ” Running comprehensive Homebrew check..."
    echo ""
  fi

  # Get current OS or use forced platform
  local current_os="${forced_platform}"
  if [[ -z "${current_os}" ]]; then
    if is_macos; then
      current_os="darwin"
    else
      current_os="linux"
    fi
  fi

  local issues_found=0

  # 1. Check for outdated packages (only on actual platform, not forced)
  if [[ -z "${1:-}" ]]; then
    [[ "${quiet_mode}" != "true" ]] && info "ðŸ“¦ Checking for outdated packages..."
    local outdated_count=0

    if outdated=$(brew outdated --quiet 2> /dev/null); then
      outdated_count=$(echo "${outdated}" | grep -c . 2> /dev/null || true)
      outdated_count=${outdated_count:-0}
      outdated_count=$((${outdated_count//[!0-9]/}))
      if [[ ${outdated_count} -gt 0 ]]; then
        if [[ "${quiet_mode}" != "true" ]]; then
          warn "Found ${outdated_count} outdated package(s):"
          echo "${outdated}" | while IFS= read -r pkg; do
            [[ -n "${pkg}" ]] && echo "  - ${pkg}"
          done
        fi
        ((issues_found++))
      else
        [[ "${quiet_mode}" != "true" ]] && success "All packages are up to date"
      fi
    fi
    [[ "${quiet_mode}" != "true" ]] && echo ""
  else
    [[ "${quiet_mode}" != "true" ]] && info "ðŸ“¦ Skipping outdated package check (forced platform mode)"
    [[ "${quiet_mode}" != "true" ]] && echo ""
  fi

  # Update marker file
  touch "${marker_file}"

  # Summary
  if [[ ${issues_found} -eq 0 ]]; then
    [[ "${quiet_mode}" != "true" ]] && success "All checks passed! No issues found."
    return 0
  else
    if [[ "${quiet_mode}" == "true" ]]; then
      echo "jsh: ${outdated_count} outdated brew package(s). Run 'jsh brew check' or 'brew upgrade'"
    else
      warn "Found ${issues_found} issue(s). Review the output above."
    fi
    return 1
  fi
}

brew_check() {
  # Check if brew is installed (handle root delegation)
  load_brew_user

  local brew_available=false
  if is_root; then
    # When root, check if brew path exists and BREW_USER is configured
    if [[ -n "${BREW_USER:-}" ]] && [[ -n "$(detect_brew_path)" ]]; then
      brew_available=true
    fi
  else
    if command -v brew &> /dev/null; then
      brew_available=true
    fi
  fi

  if [[ "${brew_available}" != "true" ]]; then
    warn "Homebrew is not installed. Run: jsh brew setup"
    return 1
  fi

  local forced_platform=""
  local quiet_mode=false
  local force_check=false
  local -a pkg_args
  pkg_args=()

  # Parse platform flags
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --linux)
        forced_platform="linux"
        shift
        ;;
      --darwin | --macos)
        forced_platform="darwin"
        shift
        ;;
      --quiet | -q)
        quiet_mode=true
        shift
        ;;
      --force | -f)
        force_check=true
        shift
        ;;
      --help | -h)
        info "Usage: jsh brew check [--quiet] [--force] [--linux|--darwin|--macos] [package]"
        info "  --quiet   Silent mode, only output if issues found"
        info "  --force   Force check even if run recently"
        info "  --linux   Force check as if on Linux platform"
        info "  --darwin  Force check as if on Darwin/macOS platform"
        info "  --macos   Alias for --darwin"
        return 0
        ;;
      -*)
        error "Unknown flag: $1"
        info "Usage: jsh brew check [--quiet] [--force] [--linux|--darwin|--macos] [package]"
        return 1
        ;;
      *)
        pkg_args+=("$1")
        shift
        ;;
    esac
  done

  # If a package name is provided, just validate that package
  if [[ ${#pkg_args[@]} -gt 0 ]]; then
    validate_package "${pkg_args[0]}" "${forced_platform}"
    return $?
  fi

  # Otherwise run comprehensive checks
  comprehensive_check "${forced_platform}" "${quiet_mode}" "${force_check}"
}

# ============================================================================
# Brew Wrapper Function (with root delegation)
# ============================================================================

# Helper function to run brew (handles root delegation)
run_brew() {
  load_brew_user

  if is_root; then
    if [[ -z "${BREW_USER:-}" ]]; then
      error "Running as root without configured brew user."
      info "Run: jsh brew setup"
      return 1
    fi

    if ! user_exists "${BREW_USER}"; then
      error "Brew user '${BREW_USER}' does not exist."
      info "Run: jsh brew setup"
      return 1
    fi

    # Run brew as the delegated user (cd to /tmp first to avoid "directory does not exist" errors)
    sudo -u "${BREW_USER}" env -C /tmp brew "$@"
  else
    brew "$@"
  fi
}

# Wrapper for brew command that handles root delegation
brew_cmd() {
  if is_root; then
    if [[ -z "${BREW_USER:-}" ]]; then
      warn "Running as root without configured brew user."
      warn "Please run 'jsh brew setup' to configure brew delegation."
      return 1
    fi
    run_as_brew_user brew "$@"
  else
    brew "$@"
  fi
}

# Get the user's login shell
get_user_shell() {
  local user_shell
  if is_macos; then
    user_shell=$(dscl . -read ~/ UserShell 2> /dev/null | awk '{print $2}')
  else
    user_shell=$(getent passwd "$(whoami)" 2> /dev/null | cut -d: -f7)
  fi
  echo "${user_shell}"
}

# src/lib/colors.sh
# Common colors and output functions for jsh

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
BOLD='\033[1m'
RESET='\033[0m'

log() { echo -e "${BLUE}ðŸ”¹ $1${RESET}"; }
info() { echo -e "${CYAN}â„¹ï¸  $1${RESET}"; }
warn() { echo -e "${YELLOW}âš ï¸  $1${RESET}"; }
error() { echo -e "${RED}âŒ $1${RESET}"; exit 1; }
success() { echo -e "${GREEN}âœ… $1${RESET}"; }
header() { echo -e "\n${BOLD}${BLUE}â–¶ $1${RESET}\n"; }

confirm() {
  local prompt="$1"
  local response
  read -n 1 -r -p "${prompt} (y/N): " response
  echo
  case "$response" in
    y | Y) return 0 ;;
    *) return 1 ;;
  esac
}

cmd_exists() { command -v "$1" &> /dev/null; }
is_macos() { [[ "$(uname -s)" == "Darwin" ]]; }
is_linux() { [[ "$(uname -s)" == "Linux" ]]; }
is_wsl() { grep -qi microsoft /proc/version 2> /dev/null; }
is_root() { [[ "${EUID:-$(id -u)}" -eq 0 ]]; }

# Get jsh root directory
get_root_dir() {
  if [[ -n "${JSH_ROOT:-}" ]]; then
    echo "$JSH_ROOT"
  else
    # When compiled by bashly, the script is at the repo root
    local script_path
    script_path="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    # Check if we're the compiled jsh script at root
    if [[ -f "$script_path/src/bashly.yml" ]]; then
      echo "$script_path"
    elif [[ -f "$script_path/../src/bashly.yml" ]]; then
      # We're in bin/
      dirname "$script_path"
    else
      # Fallback: look for .git directory
      local dir="$script_path"
      while [[ "$dir" != "/" ]]; do
        if [[ -d "$dir/.git" ]]; then
          echo "$dir"
          return
        fi
        dir="$(dirname "$dir")"
      done
      echo "$script_path"
    fi
  fi
}

# src/lib/packages.sh
# Package management functions for jsh

# Load packages from JSON file into stdout (one per line)
load_packages_from_json() {
  local json_file="$1"
  if [[ ! -f "$json_file" ]]; then
    return 1
  fi

  if command -v jq &> /dev/null; then
    jq -r '.[]' "$json_file" 2> /dev/null
  else
    grep -o '"[^"]*"' "$json_file" | tr -d '"'
  fi
}

# Add a package to a JSON array file (sorted, no duplicates)
add_package_to_json() {
  local json_file="$1"
  local package="$2"

  if [[ -z "$json_file" || -z "$package" ]]; then
    error "Usage: add_package_to_json <json_file> <package>"
  fi

  if ! command -v jq &> /dev/null; then
    error "jq is required for JSON manipulation"
  fi

  if [[ ! -f "$json_file" ]]; then
    echo "[]" > "$json_file"
  fi

  if jq -e --arg pkg "$package" 'index($pkg) != null' "$json_file" > /dev/null 2>&1; then
    info "Package '$package' already in $(basename "$json_file")"
    return 0
  fi

  local temp_file
  temp_file=$(mktemp)
  if jq --arg pkg "$package" '. + [$pkg] | sort' "$json_file" > "$temp_file"; then
    mv "$temp_file" "$json_file"
    success "Added '$package' to $(basename "$json_file")"
    return 0
  else
    rm -f "$temp_file"
    error "Failed to add package to $json_file"
  fi
}

# Remove a package from a JSON array file
remove_package_from_json() {
  local json_file="$1"
  local package="$2"

  if [[ -z "$json_file" || -z "$package" ]]; then
    error "Usage: remove_package_from_json <json_file> <package>"
  fi

  if ! command -v jq &> /dev/null; then
    error "jq is required for JSON manipulation"
  fi

  if [[ ! -f "$json_file" ]]; then
    warn "Config file does not exist: $json_file"
    return 1
  fi

  if ! jq -e --arg pkg "$package" 'index($pkg) != null' "$json_file" > /dev/null 2>&1; then
    info "Package '$package' not found in $(basename "$json_file")"
    return 1
  fi

  local temp_file
  temp_file=$(mktemp)
  if jq --arg pkg "$package" 'map(select(. != $pkg))' "$json_file" > "$temp_file"; then
    mv "$temp_file" "$json_file"
    success "Removed '$package' from $(basename "$json_file")"
    return 0
  else
    rm -f "$temp_file"
    error "Failed to remove package from $json_file"
  fi
}

# Search for linuxbrew equivalent
search_linuxbrew_package() {
  local package="$1"
  local root_dir
  root_dir="$(get_root_dir)"
  local linux_formulae_file="$root_dir/configs/linux/formulae.json"

  local search_results
  search_results=$(brew search "$package" 2>/dev/null | grep -v "^==" | grep -v "^$" || true)

  if [[ -z "$search_results" ]]; then
    log "No linuxbrew equivalent found for '$package'"
    return 0
  fi

  local matches=()
  while IFS= read -r line; do
    [[ -n "$line" ]] && matches+=("$line")
  done <<< "$search_results"

  local match_count=${#matches[@]}

  if [[ $match_count -eq 0 ]]; then
    log "No linuxbrew equivalent found for '$package'"
    return 0
  elif [[ $match_count -eq 1 ]]; then
    local linux_package="${matches[0]}"
    info "Found linuxbrew equivalent: $linux_package"
    add_package_to_json "$linux_formulae_file" "$linux_package"
  else
    echo ""
    info "Multiple linuxbrew matches found for '$package':"
    local i=1
    for match in "${matches[@]}"; do
      echo "  $i) $match"
      ((i++))
    done
    echo "  0) Skip"
    echo ""

    local selection
    read -r -p "Select package number [0-$match_count]: " selection

    if [[ "$selection" =~ ^[0-9]+$ ]] && [[ "$selection" -ge 1 ]] && [[ "$selection" -le "$match_count" ]]; then
      local selected_package="${matches[$((selection-1))]}"
      info "Adding linuxbrew package: $selected_package"
      add_package_to_json "$linux_formulae_file" "$selected_package"
    fi
  fi
}

# Prompt for winget package ID
prompt_winget_package() {
  local package="$1"
  local root_dir
  root_dir="$(get_root_dir)"
  local winget_file="$root_dir/configs/windows/winget.json"

  echo ""
  info "Enter the winget package ID for '$package' (or press Enter to skip):"
  info "Hint: Search at https://winget.run or https://winstall.app"
  echo ""

  local winget_id
  read -r -p "Winget package ID: " winget_id

  if [[ -n "$winget_id" ]]; then
    info "Adding winget package: $winget_id"
    add_package_to_json "$winget_file" "$winget_id"
  fi
}

# Search for cross-platform equivalents
search_cross_platform_packages() {
  local package="$1"
  [[ -z "$package" ]] && return 0

  log "Searching for cross-platform package equivalents..."
  search_linuxbrew_package "$package"
  prompt_winget_package "$package"
}

# Update package manager cache
update_package_cache() {
  if is_linux; then
    if command -v apt-get &> /dev/null; then
      sudo apt-get update
    elif command -v dnf &> /dev/null; then
      sudo dnf check-update || true
    elif command -v yum &> /dev/null; then
      sudo yum check-update || true
    elif command -v pacman &> /dev/null; then
      sudo pacman -Sy
    elif command -v apk &> /dev/null; then
      sudo apk update
    elif command -v zypper &> /dev/null; then
      sudo zypper refresh
    fi
  fi
}

# Install a package using the system package manager
install_package() {
  local package="$1"

  if is_macos; then
    if command -v brew &> /dev/null; then
      brew install "$package"
    else
      warn "No package manager available on macOS"
      return 1
    fi
  elif is_linux; then
    if command -v apt-get &> /dev/null; then
      sudo apt-get install -y "$package"
    elif command -v dnf &> /dev/null; then
      sudo dnf install -y "$package"
    elif command -v yum &> /dev/null; then
      sudo yum install -y "$package"
    elif command -v pacman &> /dev/null; then
      sudo pacman -S --noconfirm "$package"
    elif command -v apk &> /dev/null; then
      sudo apk add "$package"
    elif command -v zypper &> /dev/null; then
      sudo zypper install -y "$package"
    else
      warn "No supported package manager found"
      return 1
    fi
  else
    warn "Unsupported operating system"
    return 1
  fi
}

# Upgrade all packages
upgrade_packages() {
  if is_macos; then
    if command -v brew &> /dev/null; then
      brew update && brew upgrade
    fi
  elif is_linux; then
    if command -v apt-get &> /dev/null; then
      sudo apt-get update && sudo apt-get upgrade -y
    elif command -v dnf &> /dev/null; then
      sudo dnf upgrade -y
    elif command -v yum &> /dev/null; then
      sudo yum update -y
    elif command -v pacman &> /dev/null; then
      sudo pacman -Syu --noconfirm
    elif command -v apk &> /dev/null; then
      sudo apk upgrade
    elif command -v zypper &> /dev/null; then
      sudo zypper update -y
    fi
  fi
}

# :command.command_functions
# :command.function
jsh_init_command() {

  # src/init_command.sh
  root_dir="$(get_root_dir)"

  # Parse flags
  install_packages=true
  skip_brew=false
  dry_run=false
  interactive=true
  target_shell=""
  setup_type=""
  run_setup=false

  [[ "${args[--non-interactive]}" ]] && interactive=false
  [[ "${args[--shell]}" ]] && target_shell="${args[--shell]}"
  [[ "${args[--minimal]}" ]] && setup_type="minimal"
  [[ "${args[--full]}" ]] && setup_type="full"
  [[ "${args[--setup]}" ]] && run_setup=true
  [[ "${args[--no-install]}" ]] && install_packages=false
  [[ "${args[--skip-brew]}" ]] && skip_brew=true
  [[ "${args[--dry-run]}" ]] && dry_run=true

  header "Initializing jsh environment"

  # Interactive prompts
  if [[ "$interactive" == "true" ]]; then
    echo ""
    info "Welcome to jsh! Let's configure your shell environment."
    echo ""

    # Shell selection
    if [[ -z "$target_shell" ]]; then
      echo -e "${BOLD}Shell Selection:${RESET}"
      echo "  1) zsh   (recommended)"
      echo "  2) bash  (traditional)"
      echo "  3) skip  (keep current: $(basename "$SHELL"))"
      echo ""
      read -n 1 -r -p "Choose your shell (1-3): " shell_choice
      echo ""
      echo ""

      case "$shell_choice" in
        1) target_shell="zsh" ;;
        2) target_shell="bash" ;;
        3) target_shell="skip" ;;
        *) target_shell="zsh" ;;
      esac
    fi

    # Setup type selection
    if [[ -z "$setup_type" ]]; then
      echo -e "${BOLD}Setup Type:${RESET}"
      echo "  1) Minimal  - Core tools only"
      echo "  2) Full     - Themes, plugins, completions"
      echo ""
      read -n 1 -r -p "Choose setup type (1-2): " setup_choice
      echo ""
      echo ""

      case "$setup_choice" in
        1) setup_type="minimal" ;;
        2) setup_type="full" ;;
        *) setup_type="full" ;;
      esac
    fi

    # Package installation confirmation
    if [[ "$install_packages" == "true" ]]; then
      echo -e "${BOLD}Package Installation:${RESET}"
      info "This will install Homebrew and essential tools."
      echo ""

      if ! confirm "Proceed with package installation?"; then
        install_packages=false
        skip_brew=true
      fi
    fi
  else
    # Non-interactive defaults
    [[ -z "$target_shell" ]] && target_shell="zsh"
    [[ -z "$setup_type" ]] && setup_type="full"
  fi

  if [[ "$setup_type" == "minimal" ]]; then
    export ZSH_MINIMAL=1
    info "Minimal setup selected"
    echo ""
  fi

  header "Starting initialization"

  # 1. Git Submodules
  if [[ -f "$root_dir/.gitmodules" ]]; then
    log "Initializing git submodules..."
    if [[ "$dry_run" == "false" ]]; then
      git -C "$root_dir" submodule update --init --recursive
    fi
  fi

  # 2. Install fzf
  if [[ -f "$root_dir/.fzf/install" && ! -f "$root_dir/.fzf/bin/fzf" ]]; then
    log "Installing fzf..."
    if [[ "$dry_run" == "false" ]]; then
      "$root_dir/.fzf/install" --bin
      export PATH="$root_dir/.fzf/bin:$PATH"
    fi
  fi

  # 3. Homebrew
  if [[ "$install_packages" == "true" && "$skip_brew" == "false" ]]; then
    if [[ "$dry_run" == "false" ]]; then
      non_interactive_flag="false"
      [[ "$interactive" == "false" ]] && non_interactive_flag="true"
      if ! ensure_brew "$non_interactive_flag"; then
        warn "Continuing without Homebrew..."
      fi
    fi
  fi

  # 4. Basic Tools
  if [[ "$install_packages" == "true" ]]; then
    log "Installing basic tools..."
    basic_tools=(curl jq make python timeout vim)
    if command -v brew &> /dev/null; then
      for tool in "${basic_tools[@]}"; do
        if ! command -v "$tool" &> /dev/null; then
          log "Installing $tool..."
          pkg="$tool"
          [[ "$tool" == "timeout" ]] && pkg="coreutils"
          if [[ "$dry_run" == "false" ]]; then
            brew install "$pkg" 2>/dev/null || true
          fi
        fi
      done
    fi
  fi

  # 5. Shell Setup
  if [[ "$install_packages" == "true" && "$target_shell" != "skip" ]]; then
    log "Configuring shell: $target_shell"

    if ! command -v "$target_shell" &> /dev/null; then
      log "$target_shell not found, installing..."
      if [[ "$dry_run" == "false" ]]; then
        install_package "$target_shell" || true
      fi
    fi

    if command -v "$target_shell" &> /dev/null; then
      current_shell=$(get_user_shell)

      if [[ "$current_shell" != *"$target_shell"* ]]; then
        shell_path=$(command -v "$target_shell")

        if ! grep -q "^$shell_path$" /etc/shells 2> /dev/null; then
          log "Adding $shell_path to /etc/shells..."
          if [[ "$dry_run" == "false" ]]; then
            echo "$shell_path" | sudo tee -a /etc/shells > /dev/null
          fi
        fi

        log "Changing default shell to $target_shell..."
        if [[ "$dry_run" == "false" ]]; then
          chsh -s "$shell_path" || warn "Failed to change shell"
        fi
      else
        info "Shell is already $target_shell"
      fi
    fi
  fi

  # 6. Link dotfiles
  if [[ "$dry_run" == "false" ]]; then
    "$0" dotfiles
  fi

  # 7. Zinit installation
  if [[ "$install_packages" == "true" && "$dry_run" == "false" && "$target_shell" == "zsh" ]]; then
    zinit_home="${XDG_DATA_HOME:-${HOME}/.local/share}/zinit/zinit.git"

    if [[ "$setup_type" == "full" && ! -d "${zinit_home}" ]]; then
      if [[ "$interactive" == "true" ]]; then
        echo ""
        info "Zinit enables themes, syntax highlighting, and auto-suggestions."
        echo ""

        if confirm "Install zinit and plugins?"; then
          log "Installing zinit..."
          mkdir -p "${zinit_home%/*}"
          git clone https://github.com/zdharma-continuum/zinit.git "${zinit_home}" || warn "Failed to install zinit"
        fi
      else
        log "Installing zinit..."
        mkdir -p "${zinit_home%/*}"
        git clone https://github.com/zdharma-continuum/zinit.git "${zinit_home}" 2>/dev/null || true
      fi
    fi
  fi

  # 8. Run setup if requested
  if [[ "$run_setup" == "true" && "$dry_run" == "false" ]]; then
    header "Running full setup"
    "$0" install
    "$0" configure
  fi

  success "Initialization complete!"

  echo ""
  info "Summary:"
  info "  Shell:      $target_shell"
  info "  Setup type: $setup_type"
  info "  Packages:   $(if [[ "$install_packages" == "true" ]]; then echo "installed"; else echo "skipped"; fi)"
  info "  Full setup: $(if [[ "$run_setup" == "true" ]]; then echo "yes"; else echo "no"; fi)"
  echo ""

  if [[ "$dry_run" == "false" && "$target_shell" != "skip" ]]; then
    if [[ "$interactive" == "false" ]]; then
      log "Starting $target_shell session..."
      exec "$target_shell"
    else
      info "To activate your new shell, run: exec $target_shell"
      echo ""
      if confirm "Start new $target_shell session now?"; then
        exec "$target_shell"
      fi
    fi
  fi

}

# :command.function
jsh_install_command() {

  # src/install_command.sh
  # jsh install - Package installation command
  #
  # Usage:
  #   jsh install                  - Install all packages from config files
  #   jsh install <package>        - Install a single package (auto-detect package manager)
  #   jsh install <package> --brew - Install via specific package manager
  #
  # Behavior:
  #   - Single package: Uses Homebrew/Linuxbrew by default, or specified package manager
  #   - Bulk install: Uses config JSONs (system package managers + brew formulae)
  #   - Root delegation: When running as root, delegates brew commands to BREW_USER
  #
  # Environment Variables:
  #   - BREW_USER: User to run Homebrew as when executing as root (loaded from .env)

  root_dir="$(get_root_dir)"
  package="${args[package]:-}"

  # Determine which package manager to use based on flags
  detect_package_manager() {
    [[ "${args[--brew]}" ]] && echo "brew" && return
    [[ "${args[--gem]}" ]] && echo "gem" && return
    [[ "${args[--bun]}" ]] && echo "bun" && return
    [[ "${args[--npm]}" ]] && echo "npm" && return
    [[ "${args[--pip]}" ]] && echo "pip" && return
    [[ "${args[--cargo]}" ]] && echo "cargo" && return
    [[ "${args[--apt]}" ]] && echo "apt" && return
    [[ "${args[--dnf]}" ]] && echo "dnf" && return
    [[ "${args[--pacman]}" ]] && echo "pacman" && return
    [[ "${args[--yum]}" ]] && echo "yum" && return
    [[ "${args[--zypper]}" ]] && echo "zypper" && return
    echo "auto"
  }

  # Install a package via specified package manager
  install_via_package_manager() {
    local pkg="$1"
    local pm="$2"

    case "$pm" in
      brew)
        if is_macos; then
          # Try cask first, then formula
          if brew_cmd install --cask "$pkg" 2>/dev/null; then
            success "Installed cask: $pkg"
            add_package_to_json "$root_dir/configs/macos/casks.json" "$pkg"
            return 0
          elif brew_cmd install "$pkg" 2>/dev/null; then
            success "Installed formula: $pkg"
            add_package_to_json "$root_dir/configs/macos/formulae.json" "$pkg"
            return 0
          fi
        else
          if brew_cmd install "$pkg" 2>/dev/null; then
            success "Installed via brew: $pkg"
            add_package_to_json "$root_dir/configs/linux/formulae.json" "$pkg"
            return 0
          fi
        fi
        return 1
        ;;
      gem)
        if command -v gem &>/dev/null; then
          gem install "$pkg" && success "Installed gem: $pkg" && return 0
        else
          error "gem not found. Install Ruby first."
        fi
        return 1
        ;;
      bun)
        if command -v bun &>/dev/null; then
          bun install -g "$pkg" && success "Installed bun package: $pkg" && return 0
        else
          error "bun not found. Install from https://bun.sh"
        fi
        return 1
        ;;
      npm)
        if command -v npm &>/dev/null; then
          npm install -g "$pkg" && success "Installed npm package: $pkg" && return 0
        else
          error "npm not found. Install Node.js first."
        fi
        return 1
        ;;
      pip)
        if command -v pip3 &>/dev/null; then
          pip3 install --user "$pkg" && success "Installed pip package: $pkg" && return 0
        elif command -v pip &>/dev/null; then
          pip install --user "$pkg" && success "Installed pip package: $pkg" && return 0
        else
          error "pip not found. Install Python first."
        fi
        return 1
        ;;
      cargo)
        if command -v cargo &>/dev/null; then
          cargo install "$pkg" && success "Installed cargo package: $pkg" && return 0
        else
          error "cargo not found. Install Rust first."
        fi
        return 1
        ;;
      apt)
        if command -v apt-get &>/dev/null; then
          sudo apt-get install -y "$pkg" && success "Installed apt package: $pkg" && return 0
        else
          error "apt-get not found."
        fi
        return 1
        ;;
      dnf)
        if command -v dnf &>/dev/null; then
          sudo dnf install -y "$pkg" && success "Installed dnf package: $pkg" && return 0
        else
          error "dnf not found."
        fi
        return 1
        ;;
      pacman)
        if command -v pacman &>/dev/null; then
          sudo pacman -S --noconfirm "$pkg" && success "Installed pacman package: $pkg" && return 0
        else
          error "pacman not found."
        fi
        return 1
        ;;
      yum)
        if command -v yum &>/dev/null; then
          sudo yum install -y "$pkg" && success "Installed yum package: $pkg" && return 0
        else
          error "yum not found."
        fi
        return 1
        ;;
      zypper)
        if command -v zypper &>/dev/null; then
          sudo zypper install -y "$pkg" && success "Installed zypper package: $pkg" && return 0
        else
          error "zypper not found."
        fi
        return 1
        ;;
      *)
        error "Unknown package manager: $pm"
        return 1
        ;;
    esac
  }

  if [[ -z "$package" ]]; then
    # Install all packages from config (brew + system packages)
    header "Installing packages"

    if is_linux; then
      # Install Linux system packages from config
      # Note: These are managed via system package managers (apt, dnf, pacman)
      log "Updating package cache..."
      update_package_cache

      # Determine package manager
      packages=()
      if command -v apt-get &> /dev/null; then
        while IFS= read -r line; do
          [[ -n "$line" ]] && packages+=("$line")
        done < <(load_packages_from_json "$root_dir/configs/linux/apt.json")
      elif command -v dnf &> /dev/null; then
        while IFS= read -r line; do
          [[ -n "$line" ]] && packages+=("$line")
        done < <(load_packages_from_json "$root_dir/configs/linux/dnf.json")
      elif command -v pacman &> /dev/null; then
        while IFS= read -r line; do
          [[ -n "$line" ]] && packages+=("$line")
        done < <(load_packages_from_json "$root_dir/configs/linux/pacman.json")
      fi

      for pkg in "${packages[@]}"; do
        install_package "$pkg" || warn "Failed to install $pkg"
      done
    fi

    if is_macos && check_brew; then
      # Install casks
      log "Installing Casks..."
      casks=()
      while IFS= read -r line; do
        [[ -n "$line" ]] && casks+=("$line")
      done < <(load_packages_from_json "$root_dir/configs/macos/casks.json")

      if [[ ${#casks[@]} -gt 0 ]]; then
        brew install --force --cask "${casks[@]}" 2>/dev/null || true
      fi
    fi

    if check_brew; then
      # Install formulae
      log "Installing Formulae..."
      formulae=()
      if is_macos; then
        while IFS= read -r line; do
          [[ -n "$line" ]] && formulae+=("$line")
        done < <(load_packages_from_json "$root_dir/configs/macos/formulae.json")
      else
        while IFS= read -r line; do
          [[ -n "$line" ]] && formulae+=("$line")
        done < <(load_packages_from_json "$root_dir/configs/linux/formulae.json")
      fi

      if [[ ${#formulae[@]} -gt 0 ]]; then
        brew install --force "${formulae[@]}" 2>/dev/null || true
      fi

      # Start services
      log "Starting Services..."
      services=()
      if is_macos; then
        while IFS= read -r line; do
          [[ -n "$line" ]] && services+=("$line")
        done < <(load_packages_from_json "$root_dir/configs/macos/services.json")
      else
        while IFS= read -r line; do
          [[ -n "$line" ]] && services+=("$line")
        done < <(load_packages_from_json "$root_dir/configs/linux/services.json")
      fi

      for svc in "${services[@]}"; do
        brew services start "$svc" 2>/dev/null || true
      done
    fi

    success "Package installation complete"
  else
    # Install single package
    header "Installing package: $package"

    # Detect package manager
    pm=$(detect_package_manager)

    if [[ "$pm" == "auto" ]]; then
      # Auto-detect: prefer brew on both platforms
      if is_macos; then
        if ! check_brew; then
          error "Homebrew is required on macOS for auto-install"
          exit 1
        fi
        pm="brew"
      elif is_linux; then
        if ! check_brew; then
          error "Homebrew/Linuxbrew is required for auto-install. Run 'jsh init' to install it."
          exit 1
        fi
        pm="brew"
      else
        error "Unsupported operating system"
        exit 1
      fi
    fi

    # Install via specified package manager
    if install_via_package_manager "$package" "$pm"; then
      search_cross_platform_packages "$package"
    else
      error "Failed to install '$package' via $pm"
      exit 1
    fi
  fi

}

# :command.function
jsh_uninstall_command() {

  # src/uninstall_command.sh
  root_dir="$(get_root_dir)"
  package="${args[package]}"

  header "Uninstalling package: $package"

  found=false

  if is_macos; then
    if ! check_brew; then
      error "Homebrew is required on macOS"
    fi

    # Check if it's a cask
    casks_file="$root_dir/configs/macos/casks.json"
    if [[ -f "$casks_file" ]] && jq -e --arg pkg "$package" 'index($pkg) != null' "$casks_file" > /dev/null 2>&1; then
      log "Uninstalling cask: $package"
      brew_cmd uninstall --cask "$package" 2>/dev/null || warn "Failed to uninstall cask"
      remove_package_from_json "$casks_file" "$package"
      found=true
    fi

    # Check if it's a formula
    formulae_file="$root_dir/configs/macos/formulae.json"
    if [[ -f "$formulae_file" ]] && jq -e --arg pkg "$package" 'index($pkg) != null' "$formulae_file" > /dev/null 2>&1; then
      log "Uninstalling formula: $package"
      brew_cmd uninstall "$package" 2>/dev/null || warn "Failed to uninstall formula"
      remove_package_from_json "$formulae_file" "$package"
      found=true
    fi

    # If not found in config, try to uninstall anyway
    if [[ "$found" == "false" ]]; then
      log "Package not in config files, attempting uninstall..."
      if brew_cmd uninstall --cask "$package" 2>/dev/null; then
        success "Uninstalled cask: $package"
      elif brew_cmd uninstall "$package" 2>/dev/null; then
        success "Uninstalled formula: $package"
      else
        error "Package '$package' not found or failed to uninstall"
      fi
    fi

  elif is_linux; then
    # Check brew formulae first
    formulae_file="$root_dir/configs/linux/formulae.json"
    if [[ -f "$formulae_file" ]] && jq -e --arg pkg "$package" 'index($pkg) != null' "$formulae_file" > /dev/null 2>&1; then
      log "Uninstalling brew formula: $package"
      brew_cmd uninstall "$package" 2>/dev/null || warn "Failed to uninstall via brew"
      remove_package_from_json "$formulae_file" "$package"
      found=true
    fi

    # Check system package manager configs
    config_files=(
      "apt:$root_dir/configs/linux/apt.json"
      "dnf:$root_dir/configs/linux/dnf.json"
      "pacman:$root_dir/configs/linux/pacman.json"
    )

    for entry in "${config_files[@]}"; do
      pm="${entry%%:*}"
      config_file="${entry#*:}"

      if [[ -f "$config_file" ]] && jq -e --arg pkg "$package" 'index($pkg) != null' "$config_file" > /dev/null 2>&1; then
        log "Found in $pm config, uninstalling..."
        case "$pm" in
          apt) sudo apt-get remove -y "$package" 2>/dev/null || warn "apt remove failed" ;;
          dnf) sudo dnf remove -y "$package" 2>/dev/null || warn "dnf remove failed" ;;
          pacman) sudo pacman -Rs --noconfirm "$package" 2>/dev/null || warn "pacman remove failed" ;;
        esac
        remove_package_from_json "$config_file" "$package"
        found=true
      fi
    done

    # If not found in config, try to uninstall anyway
    if [[ "$found" == "false" ]]; then
      log "Package not in config files, attempting uninstall..."
      if command -v brew &> /dev/null && brew_cmd uninstall "$package" 2>/dev/null; then
        success "Uninstalled via brew: $package"
      elif command -v apt-get &> /dev/null && sudo apt-get remove -y "$package" 2>/dev/null; then
        success "Uninstalled via apt: $package"
      elif command -v dnf &> /dev/null && sudo dnf remove -y "$package" 2>/dev/null; then
        success "Uninstalled via dnf: $package"
      elif command -v pacman &> /dev/null && sudo pacman -Rs --noconfirm "$package" 2>/dev/null; then
        success "Uninstalled via pacman: $package"
      else
        error "Package '$package' not found or failed to uninstall"
      fi
    fi
  else
    error "Unsupported operating system"
  fi

  if [[ "$found" == "true" ]]; then
    success "Uninstalled: $package"
  fi

}

# :command.function
jsh_upgrade_command() {

  # src/upgrade_command.sh
  root_dir="$(get_root_dir)"

  header "Upgrading packages"

  # Update zinit if present
  if command -v zsh &> /dev/null; then
    log "Cleaning zinit..."
    zsh -ic 'zinit delete --clean' 2> /dev/null || true
    log "Updating zinit..."
    zsh -ic 'zinit self-update' 2> /dev/null || true
    zsh -ic 'zinit update --all' 2> /dev/null || true
  fi

  if is_macos; then
    if command -v brew &> /dev/null; then
      log "Upgrading Homebrew packages..."
      brew update && brew upgrade
    fi
    if command -v mas &> /dev/null; then
      log "Upgrading Mac App Store apps..."
      mas upgrade
    fi
  elif is_linux; then
    log "Upgrading packages..."
    upgrade_packages
    if command -v brew &> /dev/null; then
      log "Upgrading Homebrew packages..."
      brew update && brew upgrade
    fi
  fi

  success "Upgrade complete"

}

# :command.function
jsh_configure_command() {

  # src/configure_command.sh
  root_dir="$(get_root_dir)"

  header "Configuring environment"

  # Deploy dotfiles
  "$0" dotfiles

  # Configure brew links
  if check_brew; then
    log "Configuring Brew Links..."
    brew link --overwrite --force mpv tlrc 2>/dev/null || true
  fi

  if is_macos; then
    log "Configuring macOS..."
    bash "$root_dir/scripts/macos/configure-settings.sh" 2>/dev/null || true
    bash "$root_dir/scripts/macos/configure-dock.sh" 2>/dev/null || true

    # VSCode
    if [[ -d "/Applications/Visual Studio Code.app" ]]; then
      log "Configuring VSCode..."
      vscode_user="$HOME/Library/Application Support/Code/User"
      mkdir -p "$vscode_user"
      ln -sf "$root_dir/configs/vscode/keybindings.json" "$vscode_user/keybindings.json"
      ln -sf "$root_dir/configs/vscode/settings.json" "$vscode_user/settings.json"
    fi
  elif is_linux; then
    log "Configuring Linux..."
    bash "$root_dir/scripts/linux/configure-sudoers.sh" 2>/dev/null || true
  fi

  success "Configuration complete"

}

# :command.function
jsh_dotfiles_command() {

  # src/dotfiles_command.sh
  root_dir="$(get_root_dir)"
  dotfiles_dir="$root_dir/dotfiles"

  # Handle flags
  if [[ "${args[--status]}" ]]; then
    # Show status
    header "Dotfile Symlink Status"

    for item in "$dotfiles_dir"/.* "$dotfiles_dir"/*; do
      [[ "$(basename "$item")" == "." || "$(basename "$item")" == ".." ]] && continue
      [[ ! -e "$item" ]] && continue

      basename_item=$(basename "$item")

      if [[ "$basename_item" == ".config" ]]; then
        for config_item in "$item"/*; do
          [[ ! -e "$config_item" ]] && continue
          config_basename=$(basename "$config_item")
          config_target="$HOME/.config/$config_basename"

          if [[ -L "$config_target" ]]; then
            link_target=$(readlink "$config_target" 2>/dev/null || true)
            if [[ "$link_target" == "$config_item" ]]; then
              echo -e "  ${GREEN}âœ“${RESET} .config/$config_basename"
            else
              echo -e "  ${YELLOW}âš ${RESET} .config/$config_basename (wrong target)"
            fi
          elif [[ -e "$config_target" ]]; then
            echo -e "  ${YELLOW}âš ${RESET} .config/$config_basename (file exists)"
          else
            echo -e "  ${RED}âœ—${RESET} .config/$config_basename (not linked)"
          fi
        done
      else
        target="$HOME/$basename_item"
        if [[ -L "$target" ]]; then
          link_target=$(readlink "$target" 2>/dev/null || true)
          if [[ "$link_target" == "$item" ]]; then
            echo -e "  ${GREEN}âœ“${RESET} $basename_item"
          else
            echo -e "  ${YELLOW}âš ${RESET} $basename_item (wrong target)"
          fi
        elif [[ -e "$target" ]]; then
          echo -e "  ${YELLOW}âš ${RESET} $basename_item (file exists)"
        else
          echo -e "  ${RED}âœ—${RESET} $basename_item (not linked)"
        fi
      fi
    done
    exit 0
  fi

  if [[ "${args[--remove]}" ]]; then
    # Remove symlinks
    log "Removing jsh-managed symlinks..."

    find ~ -maxdepth 1 -type l -print 2>/dev/null | while read -r link; do
      target=$(readlink "$link" 2> /dev/null || echo "")
      if [[ "$target" == *"$root_dir/dotfiles"* ]]; then
        echo "ðŸ—‘ï¸  Removing symlink: $link"
        rm "$link"
      fi
    done

    if [[ -d "$HOME/.config" ]]; then
      find "$HOME/.config" -maxdepth 1 -type l -print 2>/dev/null | while read -r link; do
        target=$(readlink "$link" 2> /dev/null || echo "")
        if [[ "$target" == *"$root_dir/dotfiles/.config"* ]]; then
          echo "ðŸ—‘ï¸  Removing symlink: $link"
          rm "$link"
        fi
      done
    fi

    success "Dotfiles symlinks removed"
    exit 0
  fi

  # Default: deploy dotfiles
  log "Deploying dotfiles..."
  mkdir -p "$HOME/.config"

  for item in "$dotfiles_dir"/.* "$dotfiles_dir"/*; do
    [[ "$(basename "$item")" == "." || "$(basename "$item")" == ".." ]] && continue
    [[ ! -e "$item" ]] && continue

    basename_item=$(basename "$item")
    target="$HOME/$basename_item"

    if [[ "$basename_item" == ".config" ]]; then
      log "Processing .config directory..."
      for config_item in "$item"/*; do
        [[ ! -e "$config_item" ]] && continue
        config_basename=$(basename "$config_item")
        config_target="$HOME/.config/$config_basename"

        if [[ -e "$config_target" || -L "$config_target" ]]; then
          link_target=$(readlink "$config_target" 2> /dev/null || echo "")
          if [[ "$link_target" != "$config_item" ]]; then
            # Prompt user for existing file
            echo ""
            warn "Conflict: $config_target already exists"
            if [[ -L "$config_target" ]]; then
              info "  Current symlink points to: $link_target"
            fi
            echo "  [s]kip  [b]ackup and replace  [o]verwrite"
            read -n 1 -r -p "  Choice: " choice
            echo ""
            case "$choice" in
              b|B)
                mv "$config_target" "${config_target}-backup"
                ln -sf "$config_item" "$config_target"
                echo "  âœ“ Backed up and linked $config_basename"
                ;;
              o|O)
                rm -rf "$config_target"
                ln -sf "$config_item" "$config_target"
                echo "  âœ“ Overwritten $config_basename"
                ;;
              *)
                echo "  â­ Skipped $config_basename"
                ;;
            esac
          else
            rm "$config_target"
            ln -sf "$config_item" "$config_target"
          fi
        else
          ln -sf "$config_item" "$config_target"
          echo "  âœ“ Linked $config_basename"
        fi
      done
    else
      if [[ -e "$target" || -L "$target" ]]; then
        link_target=$(readlink "$target" 2> /dev/null || echo "")
        if [[ "$link_target" != "$item" ]]; then
          echo ""
          warn "Conflict: $target already exists"
          if [[ -L "$target" ]]; then
            info "  Current symlink points to: $link_target"
          fi
          echo "  [s]kip  [b]ackup and replace  [o]verwrite"
          read -n 1 -r -p "  Choice: " choice
          echo ""
          case "$choice" in
            b|B)
              mv "$target" "${target}-backup"
              ln -sf "$item" "$target"
              echo "  âœ“ Backed up and linked $basename_item"
              ;;
            o|O)
              rm -rf "$target"
              ln -sf "$item" "$target"
              echo "  âœ“ Overwritten $basename_item"
              ;;
            *)
              echo "  â­ Skipped $basename_item"
              ;;
          esac
        else
          rm "$target"
          ln -sf "$item" "$target"
        fi
      else
        ln -sf "$item" "$target"
        echo "  âœ“ Linked $basename_item"
      fi
    fi
  done

  success "Dotfiles deployed successfully"

}

# :command.function
jsh_clean_command() {

  # src/clean_command.sh
  root_dir="$(get_root_dir)"
  header "Cleaning up system"
  bash "$root_dir/scripts/unix/cleanup.sh" "$root_dir"

}

# :command.function
jsh_status_command() {

  # src/status_command.sh
  root_dir="$(get_root_dir)"

  header "System Status"

  check_brew || exit 1

  # Homebrew formulae
  echo -e "${BOLD}${MAGENTA}Homebrew Formulae:${RESET}"
  if cmd_exists brew; then
    formulae_count=$(brew list --formula 2> /dev/null | wc -l | tr -d ' ')
    echo -e "  Installed: ${GREEN}${formulae_count}${RESET} formulae"

    outdated=$(brew outdated --formula 2> /dev/null | wc -l | tr -d ' ')
    if [[ "$outdated" -gt 0 ]]; then
      echo -e "  Outdated:  ${YELLOW}${outdated}${RESET} formulae"
    else
      echo -e "  Outdated:  ${GREEN}0${RESET} (all up to date)"
    fi
  fi
  echo

  # Homebrew casks (macOS only)
  if is_macos; then
    echo -e "${BOLD}${MAGENTA}Homebrew Casks:${RESET}"
    casks_count=$(brew list --cask 2> /dev/null | wc -l | tr -d ' ')
    echo -e "  Installed: ${GREEN}${casks_count}${RESET} casks"

    outdated_casks=$(brew outdated --cask 2> /dev/null | wc -l | tr -d ' ')
    if [[ "$outdated_casks" -gt 0 ]]; then
      echo -e "  Outdated:  ${YELLOW}${outdated_casks}${RESET} casks"
    else
      echo -e "  Outdated:  ${GREEN}0${RESET} (all up to date)"
    fi
    echo
  fi

  # Homebrew services
  echo -e "${BOLD}${MAGENTA}Homebrew Services:${RESET}"
  if cmd_exists brew; then
    while IFS= read -r line; do
      service=$(echo "$line" | awk '{print $1}')
      svc_status=$(echo "$line" | awk '{print $2}')

      if [[ "$svc_status" == "started" ]]; then
        echo -e "  ${GREEN}â—${RESET} ${service} (${GREEN}running${RESET})"
      elif [[ "$svc_status" == "stopped" ]]; then
        echo -e "  ${RED}â—${RESET} ${service} (${RED}stopped${RESET})"
      else
        echo -e "  ${YELLOW}â—${RESET} ${service} (${YELLOW}${svc_status}${RESET})"
      fi
    done < <(brew services list 2> /dev/null | tail -n +2)
  fi
  echo

  # Symlinks
  echo -e "${BOLD}${MAGENTA}Dotfile Symlinks:${RESET}"
  symlink_count=0
  broken_count=0

  for link in "$HOME"/.* "$HOME"/*; do
    [[ ! -L "$link" ]] && continue
    target=$(readlink "$link" 2>/dev/null || true)
    [[ -z "$target" ]] && continue

    case "$target" in
      "$root_dir"*) ;;
      *) continue ;;
    esac

    ((++symlink_count))
    if [[ ! -e "$link" ]]; then
      ((++broken_count))
    fi
  done

  echo -e "  Total:  ${GREEN}${symlink_count}${RESET} symlinks"
  if [[ "$broken_count" -gt 0 ]]; then
    echo -e "  Broken: ${RED}${broken_count}${RESET} symlinks"
  else
    echo -e "  Broken: ${GREEN}0${RESET} (all valid)"
  fi
  echo

  # Git status
  echo -e "${BOLD}${MAGENTA}Git Repository:${RESET}"
  if [[ -d "${root_dir}/.git" ]]; then
    pushd "${root_dir}" > /dev/null
    branch=$(git branch --show-current 2> /dev/null || echo "unknown")
    echo -e "  Branch:  ${CYAN}${branch}${RESET}"

    git_status=$(git status --porcelain 2> /dev/null | wc -l | tr -d ' ')
    if [[ "$git_status" -gt 0 ]]; then
      echo -e "  Changes: ${YELLOW}${git_status}${RESET} uncommitted changes"
    else
      echo -e "  Changes: ${GREEN}clean${RESET}"
    fi
    popd > /dev/null
  fi
  echo

  # System info
  echo -e "${BOLD}${MAGENTA}System Information:${RESET}"
  echo -e "  OS:     $(uname -s) $(uname -r)"
  echo -e "  Shell:  ${SHELL} (${ZSH_VERSION:-bash})"
  echo -e "  Arch:   $(uname -m)"
  echo

}

# :command.function
jsh_doctor_command() {

  # src/doctor_command.sh
  root_dir="$(get_root_dir)"

  header "Running jsh diagnostics"

  issues=0

  # Check for required commands
  echo -e "${BOLD}Checking required commands...${RESET}"
  required_cmds=(brew git curl jq vim)
  for cmd in "${required_cmds[@]}"; do
    if cmd_exists "$cmd"; then
      echo -e "  ${GREEN}âœ“${RESET} ${cmd}"
    else
      echo -e "  ${RED}âœ—${RESET} ${cmd} (missing)"
      ((issues++))
    fi
  done
  echo

  # Check for broken symlinks
  echo -e "${BOLD}Checking for broken symlinks...${RESET}"
  broken_links=()
  while IFS= read -r link; do
    broken_links+=("$link")
  done < <(find "$HOME" -maxdepth 1 -type l ! -exec test -e {} \; -print 2> /dev/null)

  if [[ ${#broken_links[@]} -eq 0 ]]; then
    echo -e "  ${GREEN}âœ“${RESET} No broken symlinks found"
  else
    echo -e "  ${YELLOW}âš ${RESET} Found ${#broken_links[@]} broken symlink(s):"
    for link in "${broken_links[@]}"; do
      echo -e "    ${RED}â†’${RESET} $link"
      ((issues++))
    done
  fi
  echo

  # Check Git repository status
  echo -e "${BOLD}Checking Git repository...${RESET}"
  if [[ -d "${root_dir}/.git" ]]; then
    pushd "${root_dir}" > /dev/null
    if git rev-parse --git-dir > /dev/null 2>&1; then
      echo -e "  ${GREEN}âœ“${RESET} Git repository is valid"
    else
      echo -e "  ${RED}âœ—${RESET} Git repository is corrupted"
      ((issues++))
    fi

    if [[ -f "${root_dir}/.gitmodules" ]]; then
      if git submodule status | grep -q '^-'; then
        echo -e "  ${YELLOW}âš ${RESET} Some submodules are not initialized"
        ((issues++))
      else
        echo -e "  ${GREEN}âœ“${RESET} All submodules initialized"
      fi
    fi
    popd > /dev/null
  else
    echo -e "  ${RED}âœ—${RESET} Not a Git repository"
    ((issues++))
  fi
  echo

  # Check Homebrew health
  if cmd_exists brew; then
    echo -e "${BOLD}Checking Homebrew...${RESET}"
    if brew doctor > /dev/null 2>&1; then
      echo -e "  ${GREEN}âœ“${RESET} Homebrew is healthy"
    else
      echo -e "  ${YELLOW}âš ${RESET} Homebrew has warnings (run 'brew doctor' for details)"
    fi
  fi
  echo

  # Summary
  if [[ $issues -eq 0 ]]; then
    success "All checks passed! No issues found."
  else
    warn "Found ${issues} issue(s). Please review the output above."
    exit 1
  fi

}

# :command.function
jsh_deinit_command() {

  # src/deinit_command.sh
  root_dir="$(get_root_dir)"
  dotfiles_dir="$root_dir/dotfiles"

  header "Deinitializing jsh"

  warn "This will remove all jsh-managed symlinks and restore original files."
  if ! confirm "Continue with uninstall?"; then
    info "Uninstall cancelled"
    exit 0
  fi

  removed_count=0
  restored_count=0

  log "Removing jsh-managed symlinks from home directory..."

  # Process home directory symlinks
  for item in "$dotfiles_dir"/.* "$dotfiles_dir"/*; do
    [[ "$(basename "$item")" == "." || "$(basename "$item")" == ".." ]] && continue
    [[ ! -e "$item" ]] && continue

    basename_item=$(basename "$item")
    target="$HOME/$basename_item"

    [[ "$basename_item" == ".config" ]] && continue

    if [[ -L "$target" ]]; then
      link_target=$(readlink "$target" 2> /dev/null || echo "")

      if [[ "$link_target" == "$item" ]]; then
        echo "ðŸ—‘ï¸  Removing symlink: $target"
        rm "$target"
        ((removed_count++))

        backup_path="${target}-backup"
        if [[ -e "$backup_path" || -L "$backup_path" ]]; then
          echo "â™»ï¸  Restoring backup: $backup_path -> $target"
          mv "$backup_path" "$target"
          ((restored_count++))
        fi
      fi
    fi
  done

  log "Removing jsh-managed symlinks from .config directory..."

  if [[ -d "$dotfiles_dir/.config" ]]; then
    for config_item in "$dotfiles_dir/.config"/*; do
      [[ ! -e "$config_item" ]] && continue

      config_basename=$(basename "$config_item")
      config_target="$HOME/.config/$config_basename"

      if [[ -L "$config_target" ]]; then
        link_target=$(readlink "$config_target" 2> /dev/null || echo "")

        if [[ "$link_target" == "$config_item" ]]; then
          echo "ðŸ—‘ï¸  Removing symlink: $config_target"
          rm "$config_target"
          ((removed_count++))

          backup_path="${config_target}-backup"
          if [[ -e "$backup_path" || -L "$backup_path" ]]; then
            echo "â™»ï¸  Restoring backup: $backup_path -> $config_target"
            mv "$backup_path" "$config_target"
            ((restored_count++))
          fi
        fi
      fi
    done
  fi

  info "Note: You may want to remove '$root_dir/bin' from your PATH"

  echo ""
  success "Uninstall complete!"
  info "  Removed symlinks: $removed_count"
  info "  Restored backups: $restored_count"

  if [[ $restored_count -gt 0 ]]; then
    info ""
    info "Your original files have been restored."
  fi

  info ""
  info "To completely remove jsh, run: rm -rf $root_dir"

}

# :command.function
jsh_brew_command() {

  # src/brew_command.sh
  subcmd="${args[subcommand]:-help}"

  # Parse extra args from catch_all
  # Bashly stores catch_all args in other_args array
  extra_args=("${other_args[@]}")

  # Build flags to pass through
  flags=()
  [[ -n "${args[--quiet]}" ]] && flags+=("--quiet")
  [[ -n "${args[--force]}" ]] && flags+=("--force")

  case "${subcmd}" in
    setup)
      brew_setup
      ;;
    check)
      brew_check "${flags[@]}" "${extra_args[@]}"
      ;;
    help|--help|-h)
      echo -e "${BOLD}${CYAN}jsh brew${RESET} - Homebrew wrapper"
      echo ""
      echo "Subcommands:"
      echo "  setup                 Install or update Homebrew"
      echo "  check [package]       Verify package or run comprehensive checks"
      echo "  <brew command>        Pass through to brew (e.g., install, list, update)"
      echo ""
      echo "Check Options:"
      echo "  --quiet, -q          Silent mode (for check command)"
      echo "  --force, -f          Force check even if run recently"
      echo "  --linux              Force check as if on Linux platform"
      echo "  --darwin, --macos    Force check as if on Darwin/macOS platform"
      ;;
    *)
      if ! check_brew; then
        exit 1
      fi
      run_brew "${subcmd}" "${extra_args[@]}"
      ;;
  esac

}

# :command.function
jsh_completions_command() {

  # src/completions_command.sh
  if [[ "${args[--install]}" ]]; then
    # Install completions
    completion_file="$HOME/.jsh-completion.zsh"
    "$0" completions > "$completion_file"

    # Add to .zshrc if not already there
    if ! grep -q "source.*jsh-completion" "$HOME/.zshrc" 2>/dev/null; then
      echo "" >> "$HOME/.zshrc"
      echo "# jsh completions" >> "$HOME/.zshrc"
      echo "source $completion_file" >> "$HOME/.zshrc"
      success "Completions installed to $completion_file and added to .zshrc"
    else
      success "Completions updated at $completion_file"
    fi
    exit 0
  fi

  # Generate completions
  cat << 'EOF'
#compdef jsh

_jsh() {
  local -a commands
  commands=(
    'init:Set up shell environment'
    'install:Install packages'
    'uninstall:Uninstall a package and remove from config'
    'upgrade:Upgrade all packages'
    'configure:Apply dotfiles, OS settings, and app configs'
    'dotfiles:Manage dotfile symlinks'
    'clean:Remove caches, temp files, old Homebrew versions'
    'status:Show brew packages, services, symlinks, git status'
    'doctor:Check for missing tools, broken symlinks, repo issues'
    'deinit:Remove jsh symlinks and restore backups'
    'brew:Homebrew wrapper'
    'completions:Generate shell completion script'
  )

  _arguments -C \
    '1: :->command' \
    '*:: :->args'

  case $state in
    command)
      _describe -t commands 'jsh command' commands
      ;;
    args)
      case $line[1] in
        init)
          _arguments \
            '(-y --non-interactive)'{-y,--non-interactive}'[Use defaults]' \
            '--shell[Pre-select shell]:shell:(zsh bash skip)' \
            '--minimal[Lightweight setup]' \
            '--full[Full setup with plugins]' \
            '--setup[Also run install + configure]' \
            '--no-install[Skip package installation]' \
            '--skip-brew[Skip Homebrew]' \
            '--dry-run[Preview changes]'
          ;;
        dotfiles)
          _arguments \
            '(-s --status)'{-s,--status}'[Show symlink status]' \
            '(-d --remove)'{-d,--remove}'[Remove symlinks]'
          ;;
        install)
          # Could add package completion here
          ;;
        uninstall)
          # Could add installed package completion here
          ;;
        completions)
          _arguments \
            '(-i --install)'{-i,--install}'[Install to shell config]'
          ;;
      esac
      ;;
  esac
}

_jsh
EOF

}

# :command.parse_requirements
parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        jsh_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.environment_variables_filter

  env_var_names+=("JSH_ROOT")
  env_var_names+=("BREW_USER")

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    init)
      action="init"
      shift
      jsh_init_parse_requirements "$@"
      shift $#
      ;;

    install)
      action="install"
      shift
      jsh_install_parse_requirements "$@"
      shift $#
      ;;

    uninstall)
      action="uninstall"
      shift
      jsh_uninstall_parse_requirements "$@"
      shift $#
      ;;

    upgrade | update)
      action="upgrade"
      shift
      jsh_upgrade_parse_requirements "$@"
      shift $#
      ;;

    configure)
      action="configure"
      shift
      jsh_configure_parse_requirements "$@"
      shift $#
      ;;

    dotfiles)
      action="dotfiles"
      shift
      jsh_dotfiles_parse_requirements "$@"
      shift $#
      ;;

    clean | cleanup)
      action="clean"
      shift
      jsh_clean_parse_requirements "$@"
      shift $#
      ;;

    status)
      action="status"
      shift
      jsh_status_parse_requirements "$@"
      shift $#
      ;;

    doctor | check)
      action="doctor"
      shift
      jsh_doctor_parse_requirements "$@"
      shift $#
      ;;

    deinit)
      action="deinit"
      shift
      jsh_deinit_parse_requirements "$@"
      shift $#
      ;;

    brew)
      action="brew"
      shift
      jsh_brew_parse_requirements "$@"
      shift $#
      ;;

    completions)
      action="completions"
      shift
      jsh_completions_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      jsh_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
jsh_init_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        jsh_init_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="init"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --non-interactive | -y)

        # :flag.case_no_arg
        args['--non-interactive']=1
        shift
        ;;

      # :flag.case
      --shell)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--shell']="$2"
          shift
          shift
        else
          printf "%s\n" "--shell requires an argument: --shell SHELL" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --minimal)

        # :flag.case_no_arg
        args['--minimal']=1
        shift
        ;;

      # :flag.case
      --full)

        # :flag.case_no_arg
        args['--full']=1
        shift
        ;;

      # :flag.case
      --setup)

        # :flag.case_no_arg
        args['--setup']=1
        shift
        ;;

      # :flag.case
      --no-install)

        # :flag.case_no_arg
        args['--no-install']=1
        shift
        ;;

      # :flag.case
      --skip-brew)

        # :flag.case_no_arg
        args['--skip-brew']=1
        shift
        ;;

      # :flag.case
      --dry-run)

        # :flag.case_no_arg
        args['--dry-run']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
jsh_install_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        jsh_install_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="install"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --brew)

        # :flag.case_no_arg
        args['--brew']=1
        shift
        ;;

      # :flag.case
      --gem)

        # :flag.case_no_arg
        args['--gem']=1
        shift
        ;;

      # :flag.case
      --bun)

        # :flag.case_no_arg
        args['--bun']=1
        shift
        ;;

      # :flag.case
      --npm)

        # :flag.case_no_arg
        args['--npm']=1
        shift
        ;;

      # :flag.case
      --pip)

        # :flag.case_no_arg
        args['--pip']=1
        shift
        ;;

      # :flag.case
      --cargo)

        # :flag.case_no_arg
        args['--cargo']=1
        shift
        ;;

      # :flag.case
      --apt)

        # :flag.case_no_arg
        args['--apt']=1
        shift
        ;;

      # :flag.case
      --dnf)

        # :flag.case_no_arg
        args['--dnf']=1
        shift
        ;;

      # :flag.case
      --pacman)

        # :flag.case_no_arg
        args['--pacman']=1
        shift
        ;;

      # :flag.case
      --yum)

        # :flag.case_no_arg
        args['--yum']=1
        shift
        ;;

      # :flag.case
      --zypper)

        # :flag.case_no_arg
        args['--zypper']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['package']+x} ]]; then
          args['package']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
jsh_uninstall_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        jsh_uninstall_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="uninstall"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['package']+x} ]]; then
          args['package']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['package']+x} ]]; then
    printf "missing required argument: PACKAGE\nusage: jsh uninstall PACKAGE\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
jsh_upgrade_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        jsh_upgrade_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="upgrade"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
jsh_configure_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        jsh_configure_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="configure"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
jsh_dotfiles_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        jsh_dotfiles_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="dotfiles"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --status | -s)

        # :flag.case_no_arg
        args['--status']=1
        shift
        ;;

      # :flag.case
      --remove | -d)

        # :flag.case_no_arg
        args['--remove']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
jsh_clean_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        jsh_clean_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="clean"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
jsh_status_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        jsh_status_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="status"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
jsh_doctor_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        jsh_doctor_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="doctor"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
jsh_deinit_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        jsh_deinit_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="deinit"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
jsh_brew_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        jsh_brew_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="brew"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --quiet | -q)

        # :flag.case_no_arg
        args['--quiet']=1
        shift
        ;;

      # :flag.case
      --force | -f)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      --)
        shift
        other_args+=("$@")
        break
        ;;

      -?*)
        other_args+=("$1")
        shift
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_catch_all
        # :argument.case
        if [[ -z ${args['subcommand']+x} ]]; then
          args['subcommand']=$1
          shift
        else
          other_args+=("$1")
          shift
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
jsh_completions_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        jsh_completions_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="completions"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --install | -i)

        # :flag.case_no_arg
        args['--install']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.initialize
initialize() {
  declare -g version="0.1.0"
  set -e

  # src/initialize.sh
  # Load environment variables from .env file if it exists
  root_dir="${JSH_ROOT:-$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)}"
  env_file="${root_dir}/.env"

  if [[ -f "$env_file" ]]; then
    # Source the .env file to load BREW_USER and other environment variables
    # Only export variables that are defined in the file
    while IFS='=' read -r key value; do
      # Skip comments and empty lines
      [[ "$key" =~ ^[[:space:]]*# ]] && continue
      [[ -z "$key" ]] && continue

      # Remove leading/trailing whitespace
      key=$(echo "$key" | xargs)
      value=$(echo "$value" | xargs)

      # Export the variable
      export "$key=$value"
    done < "$env_file"
  fi

}

# :command.run
run() {
  # :command.globals
  declare -g long_usage=''
  declare -g -A args=()
  declare -g -a other_args=()
  declare -g -A deps=()
  declare -g -a env_var_names=()
  declare -g -a input=()

  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "init") jsh_init_command ;;
    "install") jsh_install_command ;;
    "uninstall") jsh_uninstall_command ;;
    "upgrade") jsh_upgrade_command ;;
    "configure") jsh_configure_command ;;
    "dotfiles") jsh_dotfiles_command ;;
    "clean") jsh_clean_command ;;
    "status") jsh_status_command ;;
    "doctor") jsh_doctor_command ;;
    "deinit") jsh_deinit_command ;;
    "brew") jsh_brew_command ;;
    "completions") jsh_completions_command ;;
  esac
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  # :command.start
  command_line_args=("$@")
  initialize
  run "${command_line_args[@]}"
fi
